{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs12\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\*\listtable
{\list\listtemplateid1
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8662 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid1}
{\list\listtemplateid2
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid2}
{\list\listtemplateid3
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
qcustomplot.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/anton/OneDrive - Universidad de Córdoba/Doctorado_ARR/Qt/Versiones/DWM1001DEV_APP/Github/UCO-DWM1001-DEV/src/qcustomplot.h}
{\xe \v C:/Users/anton/OneDrive - Universidad de Córdoba/Doctorado_ARR/Qt/Versiones/DWM1001DEV_APP/Github/UCO-DWM1001-DEV/src/qcustomplot.h}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
26 {\cf21 #ifndef QCUSTOMPLOT_H}\par
27 {\cf21 #define QCUSTOMPLOT_H}\par
28 \par
29 {\cf21 #include <QtCore/qglobal.h>}\par
30 \par
31 {\cf20 // some Qt version/configuration dependent macros to include or exclude certain code paths:}\par
32 {\cf21 #ifdef QCUSTOMPLOT_USE_OPENGL}\par
33 {\cf21 #  if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)}\par
34 {\cf21 #    define QCP_OPENGL_PBUFFER}\par
35 {\cf21 #  else}\par
36 {\cf21 #    define QCP_OPENGL_FBO}\par
37 {\cf21 #  endif}\par
38 {\cf21 #  if QT_VERSION >= QT_VERSION_CHECK(5, 3, 0)}\par
39 {\cf21 #    define QCP_OPENGL_OFFSCREENSURFACE}\par
40 {\cf21 #  endif}\par
41 {\cf21 #endif}\par
42 \par
43 {\cf21 #if QT_VERSION >= QT_VERSION_CHECK(5, 4, 0)}\par
44 {\cf21 #  define QCP_DEVICEPIXELRATIO_SUPPORTED}\par
45 {\cf21 #  if QT_VERSION >= QT_VERSION_CHECK(5, 6, 0)}\par
46 {\cf21 #    define QCP_DEVICEPIXELRATIO_FLOAT}\par
47 {\cf21 #  endif}\par
48 {\cf21 #endif}\par
49 \par
50 {\cf21 #include <QtCore/QObject>}\par
51 {\cf21 #include <QtCore/QPointer>}\par
52 {\cf21 #include <QtCore/QSharedPointer>}\par
53 {\cf21 #include <QtCore/QTimer>}\par
54 {\cf21 #include <QtGui/QPainter>}\par
55 {\cf21 #include <QtGui/QPainterPath>}\par
56 {\cf21 #include <QtGui/QPaintEvent>}\par
57 {\cf21 #include <QtGui/QMouseEvent>}\par
58 {\cf21 #include <QtGui/QWheelEvent>}\par
59 {\cf21 #include <QtGui/QPixmap>}\par
60 {\cf21 #include <QtCore/QVector>}\par
61 {\cf21 #include <QtCore/QString>}\par
62 {\cf21 #include <QtCore/QDateTime>}\par
63 {\cf21 #include <QtCore/QMultiMap>}\par
64 {\cf21 #include <QtCore/QFlags>}\par
65 {\cf21 #include <QtCore/QDebug>}\par
66 {\cf21 #include <QtCore/QStack>}\par
67 {\cf21 #include <QtCore/QCache>}\par
68 {\cf21 #include <QtCore/QMargins>}\par
69 {\cf21 #include <qmath.h>}\par
70 {\cf21 #include <limits>}\par
71 {\cf21 #include <algorithm>}\par
72 {\cf21 #ifdef QCP_OPENGL_FBO}\par
73 {\cf21 #  include <QtGui/QOpenGLContext>}\par
74 {\cf21 #  if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)}\par
75 {\cf21 #    include <QtGui/QOpenGLFramebufferObject>}\par
76 {\cf21 #  else}\par
77 {\cf21 #    include <QOpenGLFramebufferObject>}\par
78 {\cf21 #    include <QOpenGLPaintDevice>}\par
79 {\cf21 #  endif}\par
80 {\cf21 #  ifdef QCP_OPENGL_OFFSCREENSURFACE}\par
81 {\cf21 #    include <QtGui/QOffscreenSurface>}\par
82 {\cf21 #  else}\par
83 {\cf21 #    include <QtGui/QWindow>}\par
84 {\cf21 #  endif}\par
85 {\cf21 #endif}\par
86 {\cf21 #ifdef QCP_OPENGL_PBUFFER}\par
87 {\cf21 #  include <QtOpenGL/QGLPixelBuffer>}\par
88 {\cf21 #endif}\par
89 {\cf21 #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)}\par
90 {\cf21 #  include <qnumeric.h>}\par
91 {\cf21 #  include <QtGui/QWidget>}\par
92 {\cf21 #  include <QtGui/QPrinter>}\par
93 {\cf21 #  include <QtGui/QPrintEngine>}\par
94 {\cf21 #else}\par
95 {\cf21 #  include <QtNumeric>}\par
96 {\cf21 #  include <QtWidgets/QWidget>}\par
97 {\cf21 #  include <QtPrintSupport/QtPrintSupport>}\par
98 {\cf21 #endif}\par
99 {\cf21 #if QT_VERSION >= QT_VERSION_CHECK(4, 8, 0)}\par
100 {\cf21 #  include <QtCore/QElapsedTimer>}\par
101 {\cf21 #endif}\par
102 {\cf21 # if QT_VERSION >= QT_VERSION_CHECK(5, 2, 0)}\par
103 {\cf21 #  include <QtCore/QTimeZone>}\par
104 {\cf21 #endif}\par
105 \par
106 {\cf17 class }QCPPainter;\par
107 {\cf17 class }QCustomPlot;\par
108 {\cf17 class }QCPLayerable;\par
109 {\cf17 class }QCPLayoutElement;\par
110 {\cf17 class }QCPLayout;\par
111 {\cf17 class }QCPAxis;\par
112 {\cf17 class }QCPAxisRect;\par
113 {\cf17 class }QCPAxisPainterPrivate;\par
114 {\cf17 class }QCPAbstractPlottable;\par
115 {\cf17 class }QCPGraph;\par
116 {\cf17 class }QCPAbstractItem;\par
117 {\cf17 class }QCPPlottableInterface1D;\par
118 {\cf17 class }QCPLegend;\par
119 {\cf17 class }QCPItemPosition;\par
120 {\cf17 class }QCPLayer;\par
121 {\cf17 class }QCPAbstractLegendItem;\par
122 {\cf17 class }QCPSelectionRect;\par
123 {\cf17 class }QCPColorMap;\par
124 {\cf17 class }QCPColorScale;\par
125 {\cf17 class }QCPBars;\par
126 {\cf17 class }QCPPolarAxisRadial;\par
127 {\cf17 class }QCPPolarAxisAngular;\par
128 {\cf17 class }QCPPolarGrid;\par
129 {\cf17 class }QCPPolarGraph;\par
130 \par
131 {\cf20 /* including file 'src/global.h'            */}\par
132 {\cf20 /* modified 2022-11-06T12:45:57, size 18102 */}\par
133 \par
134 {\cf21 #define QCUSTOMPLOT_VERSION_STR "2.1.1"}\par
135 {\cf21 #define QCUSTOMPLOT_VERSION 0x020101}\par
136 \par
137 {\cf20 // decl definitions for shared library compilation/usage:}\par
138 {\cf21 #if defined(QT_STATIC_BUILD)}\par
139 {\cf21 #  define QCP_LIB_DECL}\par
140 {\cf21 #elif defined(QCUSTOMPLOT_COMPILE_LIBRARY)}\par
141 {\cf21 #  define QCP_LIB_DECL Q_DECL_EXPORT}\par
142 {\cf21 #elif defined(QCUSTOMPLOT_USE_LIBRARY)}\par
143 {\cf21 #  define QCP_LIB_DECL Q_DECL_IMPORT}\par
144 {\cf21 #else}\par
145 {\cf21 #  define QCP_LIB_DECL}\par
146 {\cf21 #endif}\par
147 \par
148 {\cf20 // define empty macro for Q_DECL_OVERRIDE if it doesn't exist (Qt < 5)}\par
149 {\cf21 #ifndef Q_DECL_OVERRIDE}\par
150 {\cf21 #  define Q_DECL_OVERRIDE}\par
151 {\cf21 #endif}\par
152 \par
160 {\cf20 // Qt version < 6.2.0: to get metatypes Q_GADGET/Q_ENUMS/Q_FLAGS in namespace we have to make it look like a class during moc-run}\par
161 {\cf21 #if QT_VERSION >= 0x060200 }{\cf20 // don't use QT_VERSION_CHECK here, some moc versions don't understand it}\par
162 {\cf17 namespace }QCP \{\par
163   Q_NAMESPACE {\cf20 // this is how to add the staticMetaObject to namespaces in newer Qt versions}\par
164 {\cf21 #else }{\cf20 // Qt version older than 6.2.0}\par
165 {\cf21 #  ifndef Q_MOC_RUN}\par
166 {\cf17 namespace }QCP \{\par
167 {\cf21 #  else }{\cf20 // not in moc run}\par
168 {\cf17 class }QCP \{\par
169   Q_GADGET\par
170   Q_ENUMS(ExportPen)\par
171   Q_ENUMS(ResolutionUnit)\par
172   Q_ENUMS(SignDomain)\par
173   Q_ENUMS(MarginSide)\par
174   Q_ENUMS(AntialiasedElement)\par
175   Q_ENUMS(PlottingHint)\par
176   Q_ENUMS(Interaction)\par
177   Q_ENUMS(SelectionRectMode)\par
178   Q_ENUMS(SelectionType)\par
179   \par
180   Q_FLAGS(AntialiasedElements)\par
181   Q_FLAGS(PlottingHints)\par
182   Q_FLAGS(MarginSides)\par
183   Q_FLAGS(Interactions)\par
184 {\cf17 public}:\par
185 {\cf21 #  endif}\par
186 {\cf21 #endif}\par
187 \par
188 \par
195 {\cf17 enum} ResolutionUnit \{ ruDotsPerMeter       \par
196                       ,ruDotsPerCentimeter \par
197                       ,ruDotsPerInch       \par
198                     \};\par
199 \par
205 {\cf17 enum} ExportPen \{ epNoCosmetic     \par
206                  ,epAllowCosmetic \par
207                \};\par
208 \par
216 {\cf17 enum} SignDomain \{ sdNegative  \par
217                   ,sdBoth     \par
218                   ,sdPositive \par
219                 \};\par
220 \par
226 {\cf17 enum} MarginSide \{ msLeft     = 0x01 \par
227                   ,msRight   = 0x02 \par
228                   ,msTop     = 0x04 \par
229                   ,msBottom  = 0x08 \par
230                   ,msAll     = 0xFF \par
231                   ,msNone    = 0x00 \par
232                 \};\par
233 Q_DECLARE_FLAGS(MarginSides, MarginSide)\par
234 \par
235 \par
244 enum AntialiasedElement \{ aeAxes           = 0x0001 \par
245                           ,aeGrid          = 0x0002 \par
246                           ,aeSubGrid       = 0x0004 \par
247                           ,aeLegend        = 0x0008 \par
248                           ,aeLegendItems   = 0x0010 \par
249                           ,aePlottables    = 0x0020 \par
250                           ,aeItems         = 0x0040 \par
251                           ,aeScatters      = 0x0080 \par
252                           ,aeFills         = 0x0100 \par
253                           ,aeZeroLine      = 0x0200 \par
254                           ,aeOther         = 0x8000 \par
255                           ,aeAll           = 0xFFFF \par
256                           ,aeNone          = 0x0000 \par
257                         \};\par
258 Q_DECLARE_FLAGS(AntialiasedElements, AntialiasedElement)\par
259 \par
260 \par
265 enum PlottingHint \{ phNone              = 0x000 \par
266                     ,phFastPolylines    = 0x001 \par
268                     ,phImmediateRefresh = 0x002 \par
270                     ,phCacheLabels      = 0x004 \par
271                   \};\par
272 Q_DECLARE_FLAGS(PlottingHints, PlottingHint)\par
273 \par
274 \par
281 enum Interaction \{ iNone              = 0x000 \par
282                    ,iRangeDrag        = 0x001 \par
283                    ,iRangeZoom        = 0x002 \par
284                    ,iMultiSelect      = 0x004 \par
285                    ,iSelectPlottables = 0x008 \par
286                    ,iSelectAxes       = 0x010 \par
287                    ,iSelectLegend     = 0x020 \par
288                    ,iSelectItems      = 0x040 \par
289                    ,iSelectOther      = 0x080 \par
290                    ,iSelectPlottablesBeyondAxisRect = 0x100 \par
291                  \};\par
292 Q_DECLARE_FLAGS(Interactions, Interaction)\par
293 \par
294 \par
299 enum SelectionRectMode \{ srmNone    \par
300                          ,srmZoom   \par
301                          ,srmSelect \par
302                          ,srmCustom \par
303                        \};\par
304 \par
323 {\cf17 enum} SelectionType \{ stNone                \par
324                      ,stWhole              \par
325                      ,stSingleData         \par
326                      ,stDataRange          \par
327                      ,stMultipleDataRanges \par
328                     \};\par
329 \par
336 {\cf17 inline} {\cf18 bool} isInvalidData({\cf18 double} value)\par
337 \{\par
338   {\cf19 return} qIsNaN(value) || qIsInf(value);\par
339 \}\par
340 \par
346 {\cf17 inline} {\cf18 bool} isInvalidData({\cf18 double} value1, {\cf18 double} value2)\par
347 \{\par
348   {\cf19 return} isInvalidData(value1) || isInvalidData(value2);\par
349 \}\par
350 \par
357 {\cf17 inline} {\cf18 void} setMarginValue(QMargins &margins, QCP::MarginSide side, {\cf18 int} value)\par
358 \{\par
359   {\cf19 switch} (side)\par
360   \{\par
361     {\cf19 case} QCP::msLeft: margins.setLeft(value); {\cf19 break};\par
362     {\cf19 case} QCP::msRight: margins.setRight(value); {\cf19 break};\par
363     {\cf19 case} QCP::msTop: margins.setTop(value); {\cf19 break};\par
364     {\cf19 case} QCP::msBottom: margins.setBottom(value); {\cf19 break};\par
365     {\cf19 case} QCP::msAll: margins = QMargins(value, value, value, value); {\cf19 break};\par
366     {\cf19 default}: {\cf19 break};\par
367   \}\par
368 \}\par
369 \par
377 {\cf17 inline} {\cf18 int} getMarginValue({\cf17 const} QMargins &margins, QCP::MarginSide side)\par
378 \{\par
379   {\cf19 switch} (side)\par
380   \{\par
381     {\cf19 case} QCP::msLeft: {\cf19 return} margins.left();\par
382     {\cf19 case} QCP::msRight: {\cf19 return} margins.right();\par
383     {\cf19 case} QCP::msTop: {\cf19 return} margins.top();\par
384     {\cf19 case} QCP::msBottom: {\cf19 return} margins.bottom();\par
385     {\cf19 default}: {\cf19 break};\par
386   \}\par
387   {\cf19 return} 0;\par
388 \}\par
389 \par
390 {\cf20 // for newer Qt versions we have to declare the enums/flags as metatypes inside the namespace using Q_ENUM_NS/Q_FLAG_NS:}\par
391 {\cf20 // if you change anything here, don't forget to change it for older Qt versions below, too,}\par
392 {\cf20 // and at the start of the namespace in the fake moc-run class}\par
393 {\cf21 #if QT_VERSION >= 0x060200}\par
394 Q_ENUM_NS(ExportPen)\par
395 Q_ENUM_NS(ResolutionUnit)\par
396 Q_ENUM_NS(SignDomain)\par
397 Q_ENUM_NS(MarginSide)\par
398 Q_ENUM_NS(AntialiasedElement)\par
399 Q_ENUM_NS(PlottingHint)\par
400 Q_ENUM_NS(Interaction)\par
401 Q_ENUM_NS(SelectionRectMode)\par
402 Q_ENUM_NS(SelectionType)\par
403 \par
404 Q_FLAG_NS(AntialiasedElements)\par
405 Q_FLAG_NS(PlottingHints)\par
406 Q_FLAG_NS(MarginSides)\par
407 Q_FLAG_NS(Interactions)\par
408 {\cf21 #else}\par
409 {\cf17 extern} {\cf17 const} QMetaObject staticMetaObject;\par
410 {\cf21 #endif}\par
411 \par
412 \} {\cf20 // end of namespace QCP}\par
413 \par
414 Q_DECLARE_OPERATORS_FOR_FLAGS(QCP::AntialiasedElements)\par
415 Q_DECLARE_OPERATORS_FOR_FLAGS(QCP::PlottingHints)\par
416 Q_DECLARE_OPERATORS_FOR_FLAGS(QCP::MarginSides)\par
417 Q_DECLARE_OPERATORS_FOR_FLAGS(QCP::Interactions)\par
418 \par
419 {\cf20 // for older Qt versions we have to declare the enums/flags as metatypes outside the namespace using Q_DECLARE_METATYPE:}\par
420 {\cf20 // if you change anything here, don't forget to change it for newer Qt versions above, too,}\par
421 {\cf20 // and at the start of the namespace in the fake moc-run class}\par
422 {\cf21 #if QT_VERSION < QT_VERSION_CHECK(6, 2, 0)}\par
423 Q_DECLARE_METATYPE(QCP::ExportPen)\par
424 Q_DECLARE_METATYPE(QCP::ResolutionUnit)\par
425 Q_DECLARE_METATYPE(QCP::SignDomain)\par
426 Q_DECLARE_METATYPE(QCP::MarginSide)\par
427 Q_DECLARE_METATYPE(QCP::AntialiasedElement)\par
428 Q_DECLARE_METATYPE(QCP::PlottingHint)\par
429 Q_DECLARE_METATYPE(QCP::Interaction)\par
430 Q_DECLARE_METATYPE(QCP::SelectionRectMode)\par
431 Q_DECLARE_METATYPE(QCP::SelectionType)\par
432 {\cf21 #endif}\par
433 \par
434 {\cf20 /* end of 'src/global.h' */}\par
435 \par
436 \par
437 {\cf20 /* including file 'src/vector2d.h'         */}\par
438 {\cf20 /* modified 2022-11-06T12:45:56, size 4988 */}\par
439 \par
440 {\cf17 class }QCP_LIB_DECL QCPVector2D\par
441 \{\par
442 {\cf17 public}:\par
443   QCPVector2D();\par
444   QCPVector2D({\cf18 double} x, {\cf18 double} y);\par
445   QCPVector2D({\cf17 const} QPoint &point);\par
446   QCPVector2D({\cf17 const} QPointF &point);\par
447   \par
448   {\cf20 // getters:}\par
449   {\cf18 double} x(){\cf17  const }\{ {\cf19 return} mX; \}\par
450   {\cf18 double} y(){\cf17  const }\{ {\cf19 return} mY; \}\par
451   {\cf18 double} &rx() \{ {\cf19 return} mX; \}\par
452   {\cf18 double} &ry() \{ {\cf19 return} mY; \}\par
453   \par
454   {\cf20 // setters:}\par
455   {\cf18 void} setX({\cf18 double} x) \{ mX = x; \}\par
456   {\cf18 void} setY({\cf18 double} y) \{ mY = y; \}\par
457   \par
458   {\cf20 // non-virtual methods:}\par
459   {\cf18 double} length(){\cf17  const }\{ {\cf19 return} qSqrt(mX*mX+mY*mY); \}\par
460   {\cf18 double} lengthSquared(){\cf17  const }\{ {\cf19 return} mX*mX+mY*mY; \}\par
461   {\cf18 double} angle(){\cf17  const }\{ {\cf19 return} qAtan2(mY, mX); \}\par
462   QPoint toPoint(){\cf17  const }\{ {\cf19 return} QPoint({\cf18 int}(mX), {\cf18 int}(mY)); \}\par
463   QPointF toPointF(){\cf17  const }\{ {\cf19 return} QPointF(mX, mY); \}\par
464   \par
465   {\cf18 bool} isNull(){\cf17  const }\{ {\cf19 return} qIsNull(mX) && qIsNull(mY); \}\par
466   {\cf18 void} normalize();\par
467   QCPVector2D normalized() {\cf17 const};\par
468   QCPVector2D perpendicular(){\cf17  const }\{ {\cf19 return} QCPVector2D(-mY, mX); \}\par
469   {\cf18 double} dot({\cf17 const} QCPVector2D &vec){\cf17  const }\{ {\cf19 return} mX*vec.mX+mY*vec.mY; \}\par
470   {\cf18 double} distanceSquaredToLine({\cf17 const} QCPVector2D &start, {\cf17 const} QCPVector2D &end) {\cf17 const};\par
471   {\cf18 double} distanceSquaredToLine({\cf17 const} QLineF &line) {\cf17 const};\par
472   {\cf18 double} distanceToStraightLine({\cf17 const} QCPVector2D &base, {\cf17 const} QCPVector2D &direction) {\cf17 const};\par
473   \par
474   QCPVector2D &operator*=({\cf18 double} factor);\par
475   QCPVector2D &operator/=({\cf18 double} divisor);\par
476   QCPVector2D &operator+=({\cf17 const} QCPVector2D &vector);\par
477   QCPVector2D &operator-=({\cf17 const} QCPVector2D &vector);\par
478   \par
479 {\cf17 private}:\par
480   {\cf20 // property members:}\par
481   {\cf18 double} mX, mY;\par
482   \par
483   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPVector2D operator*({\cf18 double} factor, {\cf17 const} QCPVector2D &vec);\par
484   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPVector2D operator*({\cf17 const} QCPVector2D &vec, {\cf18 double} factor);\par
485   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPVector2D operator/({\cf17 const} QCPVector2D &vec, {\cf18 double} divisor);\par
486   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPVector2D operator+({\cf17 const} QCPVector2D &vec1, {\cf17 const} QCPVector2D &vec2);\par
487   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPVector2D operator-({\cf17 const} QCPVector2D &vec1, {\cf17 const} QCPVector2D &vec2);\par
488   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPVector2D operator-({\cf17 const} QCPVector2D &vec);\par
489 \};\par
490 Q_DECLARE_TYPEINFO(QCPVector2D, Q_MOVABLE_TYPE);\par
491 \par
492 {\cf17 inline} {\cf17 const} QCPVector2D operator*({\cf18 double} factor, {\cf17 const} QCPVector2D &vec) \{ {\cf19 return} QCPVector2D(vec.mX*factor, vec.mY*factor); \}\par
493 {\cf17 inline} {\cf17 const} QCPVector2D operator*({\cf17 const} QCPVector2D &vec, {\cf18 double} factor) \{ {\cf19 return} QCPVector2D(vec.mX*factor, vec.mY*factor); \}\par
494 {\cf17 inline} {\cf17 const} QCPVector2D operator/({\cf17 const} QCPVector2D &vec, {\cf18 double} divisor) \{ {\cf19 return} QCPVector2D(vec.mX/divisor, vec.mY/divisor); \}\par
495 {\cf17 inline} {\cf17 const} QCPVector2D operator+({\cf17 const} QCPVector2D &vec1, {\cf17 const} QCPVector2D &vec2) \{ {\cf19 return} QCPVector2D(vec1.mX+vec2.mX, vec1.mY+vec2.mY); \}\par
496 {\cf17 inline} {\cf17 const} QCPVector2D operator-({\cf17 const} QCPVector2D &vec1, {\cf17 const} QCPVector2D &vec2) \{ {\cf19 return} QCPVector2D(vec1.mX-vec2.mX, vec1.mY-vec2.mY); \}\par
497 {\cf17 inline} {\cf17 const} QCPVector2D operator-({\cf17 const} QCPVector2D &vec) \{ {\cf19 return} QCPVector2D(-vec.mX, -vec.mY); \}\par
498 \par
503 {\cf17 inline} QDebug operator<< (QDebug d, {\cf17 const} QCPVector2D &vec)\par
504 \{\par
505     d.nospace() << {\cf22 "QCPVector2D("} << vec.x() << {\cf22 ", "} << vec.y() << {\cf22 ")"};\par
506     {\cf19 return} d.space();\par
507 \}\par
508 \par
509 {\cf20 /* end of 'src/vector2d.h' */}\par
510 \par
511 \par
512 {\cf20 /* including file 'src/painter.h'          */}\par
513 {\cf20 /* modified 2022-11-06T12:45:56, size 4035 */}\par
514 \par
515 {\cf17 class }QCP_LIB_DECL QCPPainter : {\cf17 public} QPainter\par
516 \{\par
517   Q_GADGET\par
518 {\cf17 public}:\par
523   {\cf17 enum} PainterMode \{ pmDefault       = 0x00   \par
524                      ,pmVectorized   = 0x01   \par
525                      ,pmNoCaching    = 0x02   \par
526                      ,pmNonCosmetic  = 0x04   \par
527                    \};\par
528   Q_ENUMS(PainterMode)\par
529   Q_FLAGS(PainterModes)\par
530   Q_DECLARE_FLAGS(PainterModes, PainterMode)\par
531   \par
532   QCPPainter();\par
533   explicit QCPPainter(QPaintDevice *device);\par
534   \par
535   {\cf20 // getters:}\par
536   {\cf18 bool} antialiasing(){\cf17  const }\{ {\cf19 return} testRenderHint(QPainter::Antialiasing); \}\par
537   PainterModes modes(){\cf17  const }\{ {\cf19 return} mModes; \}\par
538 \par
539   {\cf20 // setters:}\par
540   {\cf18 void} setAntialiasing({\cf18 bool} enabled);\par
541   {\cf18 void} setMode(PainterMode mode, {\cf18 bool} enabled={\cf17 true});\par
542   {\cf18 void} setModes(PainterModes modes);\par
543 \par
544   {\cf20 // methods hiding non-virtual base class functions (QPainter bug workarounds):}\par
545   {\cf18 bool} begin(QPaintDevice *device);\par
546   {\cf18 void} setPen({\cf17 const} QPen &pen);\par
547   {\cf18 void} setPen({\cf17 const} QColor &color);\par
548   {\cf18 void} setPen(Qt::PenStyle penStyle);\par
549   {\cf18 void} drawLine({\cf17 const} QLineF &line);\par
550   {\cf18 void} drawLine({\cf17 const} QPointF &p1, {\cf17 const} QPointF &p2) \{drawLine(QLineF(p1, p2));\}\par
551   {\cf18 void} save();\par
552   {\cf18 void} restore();\par
553   \par
554   {\cf20 // non-virtual methods:}\par
555   {\cf18 void} makeNonCosmetic();\par
556   \par
557 {\cf17 protected}:\par
558   {\cf20 // property members:}\par
559   PainterModes mModes;\par
560   {\cf18 bool} mIsAntialiasing;\par
561   \par
562   {\cf20 // non-property members:}\par
563   QStack<bool> mAntialiasingStack;\par
564 \};\par
565 Q_DECLARE_OPERATORS_FOR_FLAGS(QCPPainter::PainterModes)\par
566 Q_DECLARE_METATYPE(QCPPainter::PainterMode)\par
567 \par
568 {\cf20 /* end of 'src/painter.h' */}\par
569 \par
570 \par
571 {\cf20 /* including file 'src/paintbuffer.h'      */}\par
572 {\cf20 /* modified 2022-11-06T12:45:56, size 5006 */}\par
573 \par
574 class QCP_LIB_DECL QCPAbstractPaintBuffer\par
575 \{\par
576 {\cf17 public}:\par
577   {\cf17 explicit} QCPAbstractPaintBuffer({\cf17 const} QSize &size, {\cf18 double} devicePixelRatio);\par
578   {\cf17 virtual} ~QCPAbstractPaintBuffer();\par
579   \par
580   {\cf20 // getters:}\par
581   QSize size(){\cf17  const }\{ {\cf19 return} mSize; \}\par
582   {\cf18 bool} invalidated(){\cf17  const }\{ {\cf19 return} mInvalidated; \}\par
583   {\cf18 double} devicePixelRatio(){\cf17  const }\{ {\cf19 return} mDevicePixelRatio; \}\par
584   \par
585   {\cf20 // setters:}\par
586   {\cf18 void} setSize({\cf17 const} QSize &size);\par
587   {\cf18 void} setInvalidated({\cf18 bool} invalidated={\cf17 true});\par
588   {\cf18 void} setDevicePixelRatio({\cf18 double} ratio);\par
589   \par
590   {\cf20 // introduced virtual methods:}\par
591   {\cf17 virtual} QCPPainter *startPainting() = 0;\par
592   {\cf17 virtual} {\cf18 void} donePainting() \{\}\par
593   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) {\cf17 const} = 0;\par
594   {\cf17 virtual} {\cf18 void} clear({\cf17 const} QColor &color) = 0;\par
595   \par
596 {\cf17 protected}:\par
597   {\cf20 // property members:}\par
598   QSize mSize;\par
599   {\cf18 double} mDevicePixelRatio;\par
600   \par
601   {\cf20 // non-property members:}\par
602   {\cf18 bool} mInvalidated;\par
603   \par
604   {\cf20 // introduced virtual methods:}\par
605   {\cf17 virtual} {\cf18 void} reallocateBuffer() = 0;\par
606 \};\par
607 \par
608 \par
609 {\cf17 class }QCP_LIB_DECL QCPPaintBufferPixmap : {\cf17 public} QCPAbstractPaintBuffer\par
610 \{\par
611 {\cf17 public}:\par
612   {\cf17 explicit} QCPPaintBufferPixmap({\cf17 const} QSize &size, {\cf18 double} devicePixelRatio);\par
613   {\cf17 virtual} ~QCPPaintBufferPixmap() Q_DECL_OVERRIDE;\par
614   \par
615   {\cf20 // reimplemented virtual methods:}\par
616   virtual QCPPainter *startPainting() Q_DECL_OVERRIDE;\par
617   virtual {\cf18 void} draw(QCPPainter *painter) const Q_DECL_OVERRIDE;\par
618   {\cf18 void} clear(const QColor &color) Q_DECL_OVERRIDE;\par
619   \par
620 protected:\par
621   {\cf20 // non-property members:}\par
622   QPixmap mBuffer;\par
623   \par
624   {\cf20 // reimplemented virtual methods:}\par
625   virtual {\cf18 void} reallocateBuffer() Q_DECL_OVERRIDE;\par
626 \};\par
627 \par
628 \par
629 {\cf21 #ifdef QCP_OPENGL_PBUFFER}\par
630 {\cf17 class }QCP_LIB_DECL QCPPaintBufferGlPbuffer : {\cf17 public} QCPAbstractPaintBuffer\par
631 \{\par
632 {\cf17 public}:\par
633   {\cf17 explicit} QCPPaintBufferGlPbuffer({\cf17 const} QSize &size, {\cf18 double} devicePixelRatio, {\cf18 int} multisamples);\par
634   {\cf17 virtual} ~QCPPaintBufferGlPbuffer() Q_DECL_OVERRIDE;\par
635   \par
636   {\cf20 // reimplemented virtual methods:}\par
637   {\cf17 virtual} QCPPainter *startPainting() Q_DECL_OVERRIDE;\par
638   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) {\cf17 const} Q_DECL_OVERRIDE;\par
639   {\cf18 void} clear({\cf17 const} QColor &color) Q_DECL_OVERRIDE;\par
640   \par
641 {\cf17 protected}:\par
642   {\cf20 // non-property members:}\par
643   QGLPixelBuffer *mGlPBuffer;\par
644   {\cf18 int} mMultisamples;\par
645   \par
646   {\cf20 // reimplemented virtual methods:}\par
647   {\cf17 virtual} {\cf18 void} reallocateBuffer() Q_DECL_OVERRIDE;\par
648 \};\par
649 {\cf21 #endif }{\cf20 // QCP_OPENGL_PBUFFER}\par
650 \par
651 \par
652 {\cf21 #ifdef QCP_OPENGL_FBO}\par
653 {\cf17 class }QCP_LIB_DECL QCPPaintBufferGlFbo : {\cf17 public} QCPAbstractPaintBuffer\par
654 \{\par
655 {\cf17 public}:\par
656   {\cf17 explicit} QCPPaintBufferGlFbo({\cf17 const} QSize &size, {\cf18 double} devicePixelRatio, QWeakPointer<QOpenGLContext> glContext, QWeakPointer<QOpenGLPaintDevice> glPaintDevice);\par
657   {\cf17 virtual} ~QCPPaintBufferGlFbo() Q_DECL_OVERRIDE;\par
658   \par
659   {\cf20 // reimplemented virtual methods:}\par
660   virtual QCPPainter *startPainting() Q_DECL_OVERRIDE;\par
661   virtual {\cf18 void} donePainting() Q_DECL_OVERRIDE;\par
662   virtual {\cf18 void} draw(QCPPainter *painter) const Q_DECL_OVERRIDE;\par
663   {\cf18 void} clear(const QColor &color) Q_DECL_OVERRIDE;\par
664   \par
665 protected:\par
666   {\cf20 // non-property members:}\par
667   QWeakPointer<QOpenGLContext> mGlContext;\par
668   QWeakPointer<QOpenGLPaintDevice> mGlPaintDevice;\par
669   QOpenGLFramebufferObject *mGlFrameBuffer;\par
670   \par
671   {\cf20 // reimplemented virtual methods:}\par
672   virtual {\cf18 void} reallocateBuffer() Q_DECL_OVERRIDE;\par
673 \};\par
674 {\cf21 #endif }{\cf20 // QCP_OPENGL_FBO}\par
675 \par
676 {\cf20 /* end of 'src/paintbuffer.h' */}\par
677 \par
678 \par
679 {\cf20 /* including file 'src/layer.h'            */}\par
680 {\cf20 /* modified 2022-11-06T12:45:56, size 7038 */}\par
681 \par
682 {\cf17 class }QCP_LIB_DECL QCPLayer : {\cf17 public} QObject\par
683 \{\par
684   Q_OBJECT\par
686   Q_PROPERTY(QCustomPlot* parentPlot READ parentPlot)\par
687   Q_PROPERTY(QString name READ name)\par
688   Q_PROPERTY({\cf18 int} index READ index)\par
689   Q_PROPERTY(QList<QCPLayerable*> children READ children)\par
690   Q_PROPERTY({\cf18 bool} visible READ visible WRITE setVisible)\par
691   Q_PROPERTY(LayerMode mode READ mode WRITE setMode)\par
693 {\cf17 public}:\par
694   \par
702   {\cf17 enum} LayerMode \{ lmLogical   \par
703                    ,lmBuffered \par
704                  \};\par
705   Q_ENUMS(LayerMode)\par
706   \par
707   QCPLayer(QCustomPlot* parentPlot, const QString &layerName);\par
708   virtual ~QCPLayer();\par
709   \par
710   {\cf20 // getters:}\par
711   QCustomPlot *parentPlot(){\cf17  const }\{ {\cf19 return} mParentPlot; \}\par
712   QString name(){\cf17  const }\{ {\cf19 return} mName; \}\par
713   {\cf18 int} index(){\cf17  const }\{ {\cf19 return} mIndex; \}\par
714   QList<QCPLayerable*> children(){\cf17  const }\{ {\cf19 return} mChildren; \}\par
715   {\cf18 bool} visible(){\cf17  const }\{ {\cf19 return} mVisible; \}\par
716   LayerMode mode(){\cf17  const }\{ {\cf19 return} mMode; \}\par
717   \par
718   {\cf20 // setters:}\par
719   {\cf18 void} setVisible({\cf18 bool} visible);\par
720   {\cf18 void} setMode(LayerMode mode);\par
721   \par
722   {\cf20 // non-virtual methods:}\par
723   {\cf18 void} replot();\par
724   \par
725 {\cf17 protected}:\par
726   {\cf20 // property members:}\par
727   QCustomPlot *mParentPlot;\par
728   QString mName;\par
729   {\cf18 int} mIndex;\par
730   QList<QCPLayerable*> mChildren;\par
731   {\cf18 bool} mVisible;\par
732   LayerMode mMode;\par
733   \par
734   {\cf20 // non-property members:}\par
735   QWeakPointer<QCPAbstractPaintBuffer> mPaintBuffer;\par
736   \par
737   {\cf20 // non-virtual methods:}\par
738   {\cf18 void} draw(QCPPainter *painter);\par
739   {\cf18 void} drawToPaintBuffer();\par
740   {\cf18 void} addChild(QCPLayerable *layerable, {\cf18 bool} prepend);\par
741   {\cf18 void} removeChild(QCPLayerable *layerable);\par
742   \par
743 {\cf17 private}:\par
744   Q_DISABLE_COPY(QCPLayer)\par
745   \par
746   friend class QCustomPlot;\par
747   friend class QCPLayerable;\par
748 \};\par
749 Q_DECLARE_METATYPE(QCPLayer::LayerMode)\par
750 \par
751 class QCP_LIB_DECL QCPLayerable : public QObject\par
752 \{\par
753   Q_OBJECT\par
755   Q_PROPERTY({\cf18 bool} visible READ visible WRITE setVisible)\par
756   Q_PROPERTY(QCustomPlot* parentPlot READ parentPlot)\par
757   Q_PROPERTY(QCPLayerable* parentLayerable READ parentLayerable)\par
758   Q_PROPERTY(QCPLayer* layer READ layer WRITE setLayer NOTIFY layerChanged)\par
759   Q_PROPERTY({\cf18 bool} antialiased READ antialiased WRITE setAntialiased)\par
761 {\cf17 public}:\par
762   QCPLayerable(QCustomPlot *plot, QString targetLayer=QString(), QCPLayerable *parentLayerable={\cf17 nullptr});\par
763   {\cf17 virtual} ~QCPLayerable();\par
764   \par
765   {\cf20 // getters:}\par
766   {\cf18 bool} visible(){\cf17  const }\{ {\cf19 return} mVisible; \}\par
767   QCustomPlot *parentPlot(){\cf17  const }\{ {\cf19 return} mParentPlot; \}\par
768   QCPLayerable *parentLayerable(){\cf17  const }\{ {\cf19 return} mParentLayerable.data(); \}\par
769   QCPLayer *layer(){\cf17  const }\{ {\cf19 return} mLayer; \}\par
770   {\cf18 bool} antialiased(){\cf17  const }\{ {\cf19 return} mAntialiased; \}\par
771   \par
772   {\cf20 // setters:}\par
773   {\cf18 void} setVisible({\cf18 bool} on);\par
774   Q_SLOT {\cf18 bool} setLayer(QCPLayer *layer);\par
775   {\cf18 bool} setLayer({\cf17 const} QString &layerName);\par
776   {\cf18 void} setAntialiased({\cf18 bool} enabled);\par
777   \par
778   {\cf20 // introduced virtual methods:}\par
779   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) {\cf17 const};\par
780 \par
781   {\cf20 // non-property methods:}\par
782   {\cf18 bool} realVisibility() {\cf17 const};\par
783   \par
784 signals:\par
785   {\cf18 void} layerChanged(QCPLayer *newLayer);\par
786   \par
787 {\cf17 protected}:\par
788   {\cf20 // property members:}\par
789   {\cf18 bool} mVisible;\par
790   QCustomPlot *mParentPlot;\par
791   QPointer<QCPLayerable> mParentLayerable;\par
792   QCPLayer *mLayer;\par
793   {\cf18 bool} mAntialiased;\par
794   \par
795   {\cf20 // introduced virtual methods:}\par
796   {\cf17 virtual} {\cf18 void} parentPlotInitialized(QCustomPlot *parentPlot);\par
797   {\cf17 virtual} QCP::Interaction selectionCategory() {\cf17 const};\par
798   {\cf17 virtual} QRect clipRect() {\cf17 const};\par
799   {\cf17 virtual} {\cf18 void} applyDefaultAntialiasingHint(QCPPainter *painter) {\cf17 const} = 0;\par
800   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) = 0;\par
801   {\cf20 // selection events:}\par
802   {\cf17 virtual} {\cf18 void} selectEvent(QMouseEvent *event, {\cf18 bool} additive, {\cf17 const} QVariant &details, {\cf18 bool} *selectionStateChanged);\par
803   {\cf17 virtual} {\cf18 void} deselectEvent({\cf18 bool} *selectionStateChanged);\par
804   {\cf20 // low-level mouse events:}\par
805   {\cf17 virtual} {\cf18 void} mousePressEvent(QMouseEvent *event, {\cf17 const} QVariant &details);\par
806   {\cf17 virtual} {\cf18 void} mouseMoveEvent(QMouseEvent *event, {\cf17 const} QPointF &startPos);\par
807   {\cf17 virtual} {\cf18 void} mouseReleaseEvent(QMouseEvent *event, {\cf17 const} QPointF &startPos);\par
808   {\cf17 virtual} {\cf18 void} mouseDoubleClickEvent(QMouseEvent *event, {\cf17 const} QVariant &details);\par
809   {\cf17 virtual} {\cf18 void} wheelEvent(QWheelEvent *event);\par
810   \par
811   {\cf20 // non-property methods:}\par
812   {\cf18 void} initializeParentPlot(QCustomPlot *parentPlot);\par
813   {\cf18 void} setParentLayerable(QCPLayerable* parentLayerable);\par
814   {\cf18 bool} moveToLayer(QCPLayer *layer, {\cf18 bool} prepend);\par
815   {\cf18 void} applyAntialiasingHint(QCPPainter *painter, {\cf18 bool} localAntialiased, QCP::AntialiasedElement overrideElement) {\cf17 const};\par
816   \par
817 {\cf17 private}:\par
818   Q_DISABLE_COPY(QCPLayerable)\par
819   \par
820   friend class QCustomPlot;\par
821   friend class QCPLayer;\par
822   friend class QCPAxisRect;\par
823 \};\par
824 \par
825 {\cf20 /* end of 'src/layer.h' */}\par
826 \par
827 \par
828 {\cf20 /* including file 'src/axis/range.h'       */}\par
829 {\cf20 /* modified 2022-11-06T12:45:56, size 5280 */}\par
830 \par
831 class QCP_LIB_DECL QCPRange\par
832 \{\par
833 {\cf17 public}:\par
834   {\cf18 double} lower, upper;\par
835   \par
836   QCPRange();\par
837   QCPRange({\cf18 double} lower, {\cf18 double} upper);\par
838   \par
839   {\cf18 bool} operator==({\cf17 const} QCPRange& other){\cf17  const }\{ {\cf19 return} lower == other.lower && upper == other.upper; \}\par
840   {\cf18 bool} operator!=({\cf17 const} QCPRange& other){\cf17  const }\{ {\cf19 return} !(*{\cf17 this} == other); \}\par
841   \par
842   QCPRange &operator+=({\cf17 const} {\cf18 double}& value) \{ lower+=value; upper+=value; {\cf19 return} *{\cf17 this}; \}\par
843   QCPRange &operator-=({\cf17 const} {\cf18 double}& value) \{ lower-=value; upper-=value; {\cf19 return} *{\cf17 this}; \}\par
844   QCPRange &operator*=({\cf17 const} {\cf18 double}& value) \{ lower*=value; upper*=value; {\cf19 return} *{\cf17 this}; \}\par
845   QCPRange &operator/=({\cf17 const} {\cf18 double}& value) \{ lower/=value; upper/=value; {\cf19 return} *{\cf17 this}; \}\par
846   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPRange operator+({\cf17 const} QCPRange&, {\cf18 double});\par
847   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPRange operator+({\cf18 double}, {\cf17 const} QCPRange&);\par
848   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPRange operator-({\cf17 const} QCPRange& range, {\cf18 double} value);\par
849   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPRange operator*({\cf17 const} QCPRange& range, {\cf18 double} value);\par
850   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPRange operator*({\cf18 double} value, {\cf17 const} QCPRange& range);\par
851   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPRange operator/({\cf17 const} QCPRange& range, {\cf18 double} value);\par
852   \par
853   {\cf18 double} size(){\cf17  const }\{ {\cf19 return} upper-lower; \}\par
854   {\cf18 double} center(){\cf17  const }\{ {\cf19 return} (upper+lower)*0.5; \}\par
855   {\cf18 void} normalize() \{ {\cf19 if} (lower > upper) qSwap(lower, upper); \}\par
856   {\cf18 void} expand({\cf17 const} QCPRange &otherRange);\par
857   {\cf18 void} expand({\cf18 double} includeCoord);\par
858   QCPRange expanded({\cf17 const} QCPRange &otherRange) {\cf17 const};\par
859   QCPRange expanded({\cf18 double} includeCoord) {\cf17 const};\par
860   QCPRange bounded({\cf18 double} lowerBound, {\cf18 double} upperBound) {\cf17 const};\par
861   QCPRange sanitizedForLogScale() {\cf17 const};\par
862   QCPRange sanitizedForLinScale() {\cf17 const};\par
863   {\cf18 bool} contains({\cf18 double} value){\cf17  const }\{ {\cf19 return} value >= lower && value <= upper; \}\par
864   \par
865   {\cf17 static} {\cf18 bool} validRange({\cf18 double} lower, {\cf18 double} upper);\par
866   {\cf17 static} {\cf18 bool} validRange({\cf17 const} QCPRange &range);\par
867   {\cf17 static} {\cf17 const} {\cf18 double} minRange;\par
868   {\cf17 static} {\cf17 const} {\cf18 double} maxRange;\par
869   \par
870 \};\par
871 Q_DECLARE_TYPEINFO(QCPRange, Q_MOVABLE_TYPE);\par
872 \par
877 {\cf17 inline} QDebug operator<< (QDebug d, {\cf17 const} QCPRange &range)\par
878 \{\par
879     d.nospace() << {\cf22 "QCPRange("} << range.lower << {\cf22 ", "} << range.upper << {\cf22 ")"};\par
880     {\cf19 return} d.space();\par
881 \}\par
882 \par
886 {\cf17 inline} {\cf17 const} QCPRange operator+({\cf17 const} QCPRange& range, {\cf18 double} value)\par
887 \{\par
888   QCPRange result(range);\par
889   result += value;\par
890   {\cf19 return} result;\par
891 \}\par
892 \par
896 {\cf17 inline} {\cf17 const} QCPRange operator+({\cf18 double} value, {\cf17 const} QCPRange& range)\par
897 \{\par
898   QCPRange result(range);\par
899   result += value;\par
900   {\cf19 return} result;\par
901 \}\par
902 \par
906 {\cf17 inline} {\cf17 const} QCPRange operator-({\cf17 const} QCPRange& range, {\cf18 double} value)\par
907 \{\par
908   QCPRange result(range);\par
909   result -= value;\par
910   {\cf19 return} result;\par
911 \}\par
912 \par
916 {\cf17 inline} {\cf17 const} QCPRange operator*({\cf17 const} QCPRange& range, {\cf18 double} value)\par
917 \{\par
918   QCPRange result(range);\par
919   result *= value;\par
920   {\cf19 return} result;\par
921 \}\par
922 \par
926 {\cf17 inline} {\cf17 const} QCPRange operator*({\cf18 double} value, {\cf17 const} QCPRange& range)\par
927 \{\par
928   QCPRange result(range);\par
929   result *= value;\par
930   {\cf19 return} result;\par
931 \}\par
932 \par
936 {\cf17 inline} {\cf17 const} QCPRange operator/({\cf17 const} QCPRange& range, {\cf18 double} value)\par
937 \{\par
938   QCPRange result(range);\par
939   result /= value;\par
940   {\cf19 return} result;\par
941 \}\par
942 \par
943 {\cf20 /* end of 'src/axis/range.h' */}\par
944 \par
945 \par
946 {\cf20 /* including file 'src/selection.h'        */}\par
947 {\cf20 /* modified 2022-11-06T12:45:56, size 8569 */}\par
948 \par
949 {\cf17 class }QCP_LIB_DECL QCPDataRange\par
950 \{\par
951 {\cf17 public}:\par
952   QCPDataRange();\par
953   QCPDataRange({\cf18 int} begin, {\cf18 int} end);\par
954   \par
955   {\cf18 bool} operator==({\cf17 const} QCPDataRange& other){\cf17  const }\{ {\cf19 return} mBegin == other.mBegin && mEnd == other.mEnd; \}\par
956   {\cf18 bool} operator!=({\cf17 const} QCPDataRange& other){\cf17  const }\{ {\cf19 return} !(*{\cf17 this} == other); \}\par
957   \par
958   {\cf20 // getters:}\par
959   {\cf18 int} begin(){\cf17  const }\{ {\cf19 return} mBegin; \}\par
960   {\cf18 int} end(){\cf17  const }\{ {\cf19 return} mEnd; \}\par
961   {\cf18 int} size(){\cf17  const }\{ {\cf19 return} mEnd-mBegin; \}\par
962   {\cf18 int} length(){\cf17  const }\{ {\cf19 return} size(); \}\par
963   \par
964   {\cf20 // setters:}\par
965   {\cf18 void} setBegin({\cf18 int} begin) \{ mBegin = begin; \}\par
966   {\cf18 void} setEnd({\cf18 int} end)  \{ mEnd = end; \}\par
967   \par
968   {\cf20 // non-property methods:}\par
969   {\cf18 bool} isValid(){\cf17  const }\{ {\cf19 return} (mEnd >= mBegin) && (mBegin >= 0); \}\par
970   {\cf18 bool} isEmpty(){\cf17  const }\{ {\cf19 return} length() == 0; \}\par
971   QCPDataRange bounded({\cf17 const} QCPDataRange &other) {\cf17 const};\par
972   QCPDataRange expanded({\cf17 const} QCPDataRange &other) {\cf17 const};\par
973   QCPDataRange intersection({\cf17 const} QCPDataRange &other) {\cf17 const};\par
974   QCPDataRange adjusted({\cf18 int} changeBegin, {\cf18 int} changeEnd){\cf17  const }\{ {\cf19 return} QCPDataRange(mBegin+changeBegin, mEnd+changeEnd); \}\par
975   {\cf18 bool} intersects({\cf17 const} QCPDataRange &other) {\cf17 const};\par
976   {\cf18 bool} contains({\cf17 const} QCPDataRange &other) {\cf17 const};\par
977   \par
978 {\cf17 private}:\par
979   {\cf20 // property members:}\par
980   {\cf18 int} mBegin, mEnd;\par
981 \par
982 \};\par
983 Q_DECLARE_TYPEINFO(QCPDataRange, Q_MOVABLE_TYPE);\par
984 \par
985 \par
986 {\cf17 class }QCP_LIB_DECL QCPDataSelection\par
987 \{\par
988 {\cf17 public}:\par
989   {\cf17 explicit} QCPDataSelection();\par
990   {\cf17 explicit} QCPDataSelection({\cf17 const} QCPDataRange &range);\par
991   \par
992   {\cf18 bool} operator==({\cf17 const} QCPDataSelection& other) {\cf17 const};\par
993   {\cf18 bool} operator!=({\cf17 const} QCPDataSelection& other){\cf17  const }\{ {\cf19 return} !(*{\cf17 this} == other); \}\par
994   QCPDataSelection &operator+=({\cf17 const} QCPDataSelection& other);\par
995   QCPDataSelection &operator+=({\cf17 const} QCPDataRange& other);\par
996   QCPDataSelection &operator-=({\cf17 const} QCPDataSelection& other);\par
997   QCPDataSelection &operator-=({\cf17 const} QCPDataRange& other);\par
998   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPDataSelection operator+({\cf17 const} QCPDataSelection& a, {\cf17 const} QCPDataSelection& b);\par
999   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPDataSelection operator+({\cf17 const} QCPDataRange& a, {\cf17 const} QCPDataSelection& b);\par
1000   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPDataSelection operator+({\cf17 const} QCPDataSelection& a, {\cf17 const} QCPDataRange& b);\par
1001   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPDataSelection operator+({\cf17 const} QCPDataRange& a, {\cf17 const} QCPDataRange& b);\par
1002   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPDataSelection operator-({\cf17 const} QCPDataSelection& a, {\cf17 const} QCPDataSelection& b);\par
1003   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPDataSelection operator-({\cf17 const} QCPDataRange& a, {\cf17 const} QCPDataSelection& b);\par
1004   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPDataSelection operator-({\cf17 const} QCPDataSelection& a, {\cf17 const} QCPDataRange& b);\par
1005   {\cf17 friend} {\cf17 inline} {\cf17 const} QCPDataSelection operator-({\cf17 const} QCPDataRange& a, {\cf17 const} QCPDataRange& b);\par
1006   \par
1007   {\cf20 // getters:}\par
1008   {\cf18 int} dataRangeCount(){\cf17  const }\{ {\cf19 return} mDataRanges.size(); \}\par
1009   {\cf18 int} dataPointCount() {\cf17 const};\par
1010   QCPDataRange dataRange({\cf18 int} index=0) {\cf17 const};\par
1011   QList<QCPDataRange> dataRanges(){\cf17  const }\{ {\cf19 return} mDataRanges; \}\par
1012   QCPDataRange span() {\cf17 const};\par
1013   \par
1014   {\cf20 // non-property methods:}\par
1015   {\cf18 void} addDataRange({\cf17 const} QCPDataRange &dataRange, {\cf18 bool} simplify={\cf17 true});\par
1016   {\cf18 void} clear();\par
1017   {\cf18 bool} isEmpty(){\cf17  const }\{ {\cf19 return} mDataRanges.isEmpty(); \}\par
1018   {\cf18 void} simplify();\par
1019   {\cf18 void} enforceType(QCP::SelectionType type);\par
1020   {\cf18 bool} contains({\cf17 const} QCPDataSelection &other) {\cf17 const};\par
1021   QCPDataSelection intersection({\cf17 const} QCPDataRange &other) {\cf17 const};\par
1022   QCPDataSelection intersection({\cf17 const} QCPDataSelection &other) {\cf17 const};\par
1023   QCPDataSelection inverse({\cf17 const} QCPDataRange &outerRange) {\cf17 const};\par
1024   \par
1025 {\cf17 private}:\par
1026   {\cf20 // property members:}\par
1027   QList<QCPDataRange> mDataRanges;\par
1028   \par
1029   {\cf17 inline} {\cf17 static} {\cf18 bool} lessThanDataRangeBegin({\cf17 const} QCPDataRange &a, {\cf17 const} QCPDataRange &b) \{ {\cf19 return} a.begin() < b.begin(); \}\par
1030 \};\par
1031 Q_DECLARE_METATYPE(QCPDataSelection)\par
1032 \par
1033 \par
1034 \par
1038 inline const QCPDataSelection operator+(const QCPDataSelection& a, const QCPDataSelection& b)\par
1039 \{\par
1040   QCPDataSelection result(a);\par
1041   result += b;\par
1042   {\cf19 return} result;\par
1043 \}\par
1044 \par
1049 {\cf17 inline} {\cf17 const} QCPDataSelection operator+({\cf17 const} QCPDataRange& a, {\cf17 const} QCPDataSelection& b)\par
1050 \{\par
1051   QCPDataSelection result(a);\par
1052   result += b;\par
1053   {\cf19 return} result;\par
1054 \}\par
1055 \par
1060 {\cf17 inline} {\cf17 const} QCPDataSelection operator+({\cf17 const} QCPDataSelection& a, {\cf17 const} QCPDataRange& b)\par
1061 \{\par
1062   QCPDataSelection result(a);\par
1063   result += b;\par
1064   {\cf19 return} result;\par
1065 \}\par
1066 \par
1071 {\cf17 inline} {\cf17 const} QCPDataSelection operator+({\cf17 const} QCPDataRange& a, {\cf17 const} QCPDataRange& b)\par
1072 \{\par
1073   QCPDataSelection result(a);\par
1074   result += b;\par
1075   {\cf19 return} result;\par
1076 \}\par
1077 \par
1081 {\cf17 inline} {\cf17 const} QCPDataSelection operator-({\cf17 const} QCPDataSelection& a, {\cf17 const} QCPDataSelection& b)\par
1082 \{\par
1083   QCPDataSelection result(a);\par
1084   result -= b;\par
1085   {\cf19 return} result;\par
1086 \}\par
1087 \par
1091 {\cf17 inline} {\cf17 const} QCPDataSelection operator-({\cf17 const} QCPDataRange& a, {\cf17 const} QCPDataSelection& b)\par
1092 \{\par
1093   QCPDataSelection result(a);\par
1094   result -= b;\par
1095   {\cf19 return} result;\par
1096 \}\par
1097 \par
1101 {\cf17 inline} {\cf17 const} QCPDataSelection operator-({\cf17 const} QCPDataSelection& a, {\cf17 const} QCPDataRange& b)\par
1102 \{\par
1103   QCPDataSelection result(a);\par
1104   result -= b;\par
1105   {\cf19 return} result;\par
1106 \}\par
1107 \par
1111 {\cf17 inline} {\cf17 const} QCPDataSelection operator-({\cf17 const} QCPDataRange& a, {\cf17 const} QCPDataRange& b)\par
1112 \{\par
1113   QCPDataSelection result(a);\par
1114   result -= b;\par
1115   {\cf19 return} result;\par
1116 \}\par
1117 \par
1122 {\cf17 inline} QDebug operator<< (QDebug d, {\cf17 const} QCPDataRange &dataRange)\par
1123 \{\par
1124   d.nospace() << {\cf22 "QCPDataRange("} << dataRange.begin() << {\cf22 ", "} << dataRange.end() << {\cf22 ")"};\par
1125   {\cf19 return} d;\par
1126 \}\par
1127 \par
1132 {\cf17 inline} QDebug operator<< (QDebug d, {\cf17 const} QCPDataSelection &selection)\par
1133 \{\par
1134     d.nospace() << {\cf22 "QCPDataSelection("};\par
1135     {\cf19 for} ({\cf18 int} i=0; i<selection.dataRangeCount(); ++i)\par
1136     \{\par
1137       {\cf19 if} (i != 0)\par
1138         d << {\cf22 ", "};\par
1139       d << selection.dataRange(i);\par
1140     \}\par
1141     d << {\cf22 ")"};\par
1142     {\cf19 return} d;\par
1143 \}\par
1144 \par
1145 \par
1146 \par
1147 {\cf20 /* end of 'src/selection.h' */}\par
1148 \par
1149 \par
1150 {\cf20 /* including file 'src/selectionrect.h'    */}\par
1151 {\cf20 /* modified 2022-11-06T12:45:56, size 3354 */}\par
1152 \par
1153 {\cf17 class }QCP_LIB_DECL QCPSelectionRect : {\cf17 public} QCPLayerable\par
1154 \{\par
1155   Q_OBJECT\par
1156 {\cf17 public}:\par
1157   {\cf17 explicit} QCPSelectionRect(QCustomPlot *parentPlot);\par
1158   {\cf17 virtual} ~QCPSelectionRect() Q_DECL_OVERRIDE;\par
1159   \par
1160   {\cf20 // getters:}\par
1161   QRect rect(){\cf17  const }\{ {\cf19 return} mRect; \}\par
1162   QCPRange range({\cf17 const} QCPAxis *axis) {\cf17 const};\par
1163   QPen pen(){\cf17  const }\{ {\cf19 return} mPen; \}\par
1164   QBrush brush(){\cf17  const }\{ {\cf19 return} mBrush; \}\par
1165   {\cf18 bool} isActive(){\cf17  const }\{ {\cf19 return} mActive; \}\par
1166   \par
1167   {\cf20 // setters:}\par
1168   {\cf18 void} setPen({\cf17 const} QPen &pen);\par
1169   {\cf18 void} setBrush({\cf17 const} QBrush &brush);\par
1170   \par
1171   {\cf20 // non-property methods:}\par
1172   Q_SLOT {\cf18 void} cancel();\par
1173   \par
1174 signals:\par
1175   {\cf18 void} started(QMouseEvent *event);\par
1176   {\cf18 void} changed({\cf17 const} QRect &rect, QMouseEvent *event);\par
1177   {\cf18 void} canceled({\cf17 const} QRect &rect, QInputEvent *event);\par
1178   {\cf18 void} accepted({\cf17 const} QRect &rect, QMouseEvent *event);\par
1179   \par
1180 {\cf17 protected}:\par
1181   {\cf20 // property members:}\par
1182   QRect mRect;\par
1183   QPen mPen;\par
1184   QBrush mBrush;\par
1185   {\cf20 // non-property members:}\par
1186   {\cf18 bool} mActive;\par
1187   \par
1188   {\cf20 // introduced virtual methods:}\par
1189   {\cf17 virtual} {\cf18 void} startSelection(QMouseEvent *event);\par
1190   {\cf17 virtual} {\cf18 void} moveSelection(QMouseEvent *event);\par
1191   {\cf17 virtual} {\cf18 void} endSelection(QMouseEvent *event);\par
1192   {\cf17 virtual} {\cf18 void} keyPressEvent(QKeyEvent *event);\par
1193   \par
1194   {\cf20 // reimplemented virtual methods}\par
1195   {\cf17 virtual} {\cf18 void} applyDefaultAntialiasingHint(QCPPainter *painter) {\cf17 const} Q_DECL_OVERRIDE;\par
1196   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
1197   \par
1198   {\cf17 friend} {\cf17 class }QCustomPlot;\par
1199 \};\par
1200 \par
1201 {\cf20 /* end of 'src/selectionrect.h' */}\par
1202 \par
1203 \par
1204 {\cf20 /* including file 'src/layout.h'            */}\par
1205 {\cf20 /* modified 2022-11-06T12:45:56, size 14279 */}\par
1206 \par
1207 {\cf17 class }QCP_LIB_DECL QCPMarginGroup : {\cf17 public} QObject\par
1208 \{\par
1209   Q_OBJECT\par
1210 {\cf17 public}:\par
1211   {\cf17 explicit} QCPMarginGroup(QCustomPlot *parentPlot);\par
1212   {\cf17 virtual} ~QCPMarginGroup();\par
1213   \par
1214   {\cf20 // non-virtual methods:}\par
1215   QList<QCPLayoutElement*> elements(QCP::MarginSide side){\cf17  const }\{ {\cf19 return} mChildren.value(side); \}\par
1216   {\cf18 bool} isEmpty() {\cf17 const};\par
1217   {\cf18 void} clear();\par
1218   \par
1219 {\cf17 protected}:\par
1220   {\cf20 // non-property members:}\par
1221   QCustomPlot *mParentPlot;\par
1222   QHash<QCP::MarginSide, QList<QCPLayoutElement*> > mChildren;\par
1223   \par
1224   {\cf20 // introduced virtual methods:}\par
1225   {\cf17 virtual} {\cf18 int} commonMargin(QCP::MarginSide side) {\cf17 const};\par
1226   \par
1227   {\cf20 // non-virtual methods:}\par
1228   {\cf18 void} addChild(QCP::MarginSide side, QCPLayoutElement *element);\par
1229   {\cf18 void} removeChild(QCP::MarginSide side, QCPLayoutElement *element);\par
1230   \par
1231 {\cf17 private}:\par
1232   Q_DISABLE_COPY(QCPMarginGroup)\par
1233   \par
1234   friend class QCPLayoutElement;\par
1235 \};\par
1236 \par
1237 \par
1238 class QCP_LIB_DECL QCPLayoutElement : public QCPLayerable\par
1239 \{\par
1240   Q_OBJECT\par
1242   Q_PROPERTY(QCPLayout* layout READ layout)\par
1243   Q_PROPERTY(QRect rect READ rect)\par
1244   Q_PROPERTY(QRect outerRect READ outerRect WRITE setOuterRect)\par
1245   Q_PROPERTY(QMargins margins READ margins WRITE setMargins)\par
1246   Q_PROPERTY(QMargins minimumMargins READ minimumMargins WRITE setMinimumMargins)\par
1247   Q_PROPERTY(QSize minimumSize READ minimumSize WRITE setMinimumSize)\par
1248   Q_PROPERTY(QSize maximumSize READ maximumSize WRITE setMaximumSize)\par
1249   Q_PROPERTY(SizeConstraintRect sizeConstraintRect READ sizeConstraintRect WRITE setSizeConstraintRect)\par
1251 {\cf17 public}:\par
1256   {\cf17 enum} UpdatePhase \{ upPreparation \par
1257                      ,upMargins    \par
1258                      ,upLayout     \par
1259                    \};\par
1260   Q_ENUMS(UpdatePhase)\par
1261   \par
1262   \par
1270   enum SizeConstraintRect \{ scrInnerRect \par
1271                             , scrOuterRect \par
1272                           \};\par
1273   Q_ENUMS(SizeConstraintRect)\par
1274 \par
1275   explicit QCPLayoutElement(QCustomPlot *parentPlot={\cf18 nullptr});\par
1276   virtual ~QCPLayoutElement() Q_DECL_OVERRIDE;\par
1277   \par
1278   {\cf20 // getters:}\par
1279   QCPLayout *layout(){\cf17  const }\{ {\cf19 return} mParentLayout; \}\par
1280   QRect rect(){\cf17  const }\{ {\cf19 return} mRect; \}\par
1281   QRect outerRect(){\cf17  const }\{ {\cf19 return} mOuterRect; \}\par
1282   QMargins margins(){\cf17  const }\{ {\cf19 return} mMargins; \}\par
1283   QMargins minimumMargins(){\cf17  const }\{ {\cf19 return} mMinimumMargins; \}\par
1284   QCP::MarginSides autoMargins(){\cf17  const }\{ {\cf19 return} mAutoMargins; \}\par
1285   QSize minimumSize(){\cf17  const }\{ {\cf19 return} mMinimumSize; \}\par
1286   QSize maximumSize(){\cf17  const }\{ {\cf19 return} mMaximumSize; \}\par
1287   SizeConstraintRect sizeConstraintRect(){\cf17  const }\{ {\cf19 return} mSizeConstraintRect; \}\par
1288   QCPMarginGroup *marginGroup(QCP::MarginSide side){\cf17  const }\{ {\cf19 return} mMarginGroups.value(side, {\cf17 nullptr}); \}\par
1289   QHash<QCP::MarginSide, QCPMarginGroup*> marginGroups(){\cf17  const }\{ {\cf19 return} mMarginGroups; \}\par
1290   \par
1291   {\cf20 // setters:}\par
1292   {\cf18 void} setOuterRect({\cf17 const} QRect &rect);\par
1293   {\cf18 void} setMargins({\cf17 const} QMargins &margins);\par
1294   {\cf18 void} setMinimumMargins({\cf17 const} QMargins &margins);\par
1295   {\cf18 void} setAutoMargins(QCP::MarginSides sides);\par
1296   {\cf18 void} setMinimumSize({\cf17 const} QSize &size);\par
1297   {\cf18 void} setMinimumSize({\cf18 int} width, {\cf18 int} height);\par
1298   {\cf18 void} setMaximumSize({\cf17 const} QSize &size);\par
1299   {\cf18 void} setMaximumSize({\cf18 int} width, {\cf18 int} height);\par
1300   {\cf18 void} setSizeConstraintRect(SizeConstraintRect constraintRect);\par
1301   {\cf18 void} setMarginGroup(QCP::MarginSides sides, QCPMarginGroup *group);\par
1302   \par
1303   {\cf20 // introduced virtual methods:}\par
1304   {\cf17 virtual} {\cf18 void} update(UpdatePhase phase);\par
1305   {\cf17 virtual} QSize minimumOuterSizeHint() {\cf17 const};\par
1306   {\cf17 virtual} QSize maximumOuterSizeHint() {\cf17 const};\par
1307   {\cf17 virtual} QList<QCPLayoutElement*> elements({\cf18 bool} recursive) {\cf17 const};\par
1308   \par
1309   {\cf20 // reimplemented virtual methods:}\par
1310   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
1311   \par
1312 protected:\par
1313   {\cf20 // property members:}\par
1314   QCPLayout *mParentLayout;\par
1315   QSize mMinimumSize, mMaximumSize;\par
1316   SizeConstraintRect mSizeConstraintRect;\par
1317   QRect mRect, mOuterRect;\par
1318   QMargins mMargins, mMinimumMargins;\par
1319   QCP::MarginSides mAutoMargins;\par
1320   QHash<QCP::MarginSide, QCPMarginGroup*> mMarginGroups;\par
1321   \par
1322   {\cf20 // introduced virtual methods:}\par
1323   virtual {\cf18 int} calculateAutoMargin(QCP::MarginSide side);\par
1324   virtual {\cf18 void} layoutChanged();\par
1325   \par
1326   {\cf20 // reimplemented virtual methods:}\par
1327   virtual {\cf18 void} applyDefaultAntialiasingHint(QCPPainter *painter) const Q_DECL_OVERRIDE \{ Q_UNUSED(painter) \}\par
1328   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE \{ Q_UNUSED(painter) \}\par
1329   {\cf17 virtual} {\cf18 void} parentPlotInitialized(QCustomPlot *parentPlot) Q_DECL_OVERRIDE;\par
1330 \par
1331 {\cf17 private}:\par
1332   Q_DISABLE_COPY(QCPLayoutElement)\par
1333   \par
1334   friend class QCustomPlot;\par
1335   friend class QCPLayout;\par
1336   friend class QCPMarginGroup;\par
1337 \};\par
1338 Q_DECLARE_METATYPE(QCPLayoutElement::UpdatePhase)\par
1339 \par
1340 \par
1341 class QCP_LIB_DECL QCPLayout : public QCPLayoutElement\par
1342 \{\par
1343   Q_OBJECT\par
1344 {\cf17 public}:\par
1345   {\cf17 explicit} QCPLayout();\par
1346   \par
1347   {\cf20 // reimplemented virtual methods:}\par
1348   {\cf17 virtual} {\cf18 void} update(UpdatePhase phase) Q_DECL_OVERRIDE;\par
1349   {\cf17 virtual} QList<QCPLayoutElement*> elements({\cf18 bool} recursive) {\cf17 const} Q_DECL_OVERRIDE;\par
1350   \par
1351   {\cf20 // introduced virtual methods:}\par
1352   {\cf17 virtual} {\cf18 int} elementCount() {\cf17 const} = 0;\par
1353   {\cf17 virtual} QCPLayoutElement* elementAt({\cf18 int} index) {\cf17 const} = 0;\par
1354   {\cf17 virtual} QCPLayoutElement* takeAt({\cf18 int} index) = 0;\par
1355   {\cf17 virtual} {\cf18 bool} take(QCPLayoutElement* element) = 0;\par
1356   {\cf17 virtual} {\cf18 void} simplify();\par
1357   \par
1358   {\cf20 // non-virtual methods:}\par
1359   {\cf18 bool} removeAt({\cf18 int} index);\par
1360   {\cf18 bool} remove(QCPLayoutElement* element);\par
1361   {\cf18 void} clear();\par
1362   \par
1363 {\cf17 protected}:\par
1364   {\cf20 // introduced virtual methods:}\par
1365   {\cf17 virtual} {\cf18 void} updateLayout();\par
1366   \par
1367   {\cf20 // non-virtual methods:}\par
1368   {\cf18 void} sizeConstraintsChanged() {\cf17 const};\par
1369   {\cf18 void} adoptElement(QCPLayoutElement *el);\par
1370   {\cf18 void} releaseElement(QCPLayoutElement *el);\par
1371   QVector<int> getSectionSizes(QVector<int> maxSizes, QVector<int> minSizes, QVector<double> stretchFactors, {\cf18 int} totalSize) {\cf17 const};\par
1372   {\cf17 static} QSize getFinalMinimumOuterSize({\cf17 const} QCPLayoutElement *el);\par
1373   {\cf17 static} QSize getFinalMaximumOuterSize({\cf17 const} QCPLayoutElement *el);\par
1374   \par
1375 {\cf17 private}:\par
1376   Q_DISABLE_COPY(QCPLayout)\par
1377   friend class QCPLayoutElement;\par
1378 \};\par
1379 \par
1380 \par
1381 class QCP_LIB_DECL QCPLayoutGrid : public QCPLayout\par
1382 \{\par
1383   Q_OBJECT\par
1385   Q_PROPERTY({\cf18 int} rowCount READ rowCount)\par
1386   Q_PROPERTY({\cf18 int} columnCount READ columnCount)\par
1387   Q_PROPERTY(QList<double> columnStretchFactors READ columnStretchFactors WRITE setColumnStretchFactors)\par
1388   Q_PROPERTY(QList<double> rowStretchFactors READ rowStretchFactors WRITE setRowStretchFactors)\par
1389   Q_PROPERTY({\cf18 int} columnSpacing READ columnSpacing WRITE setColumnSpacing)\par
1390   Q_PROPERTY({\cf18 int} rowSpacing READ rowSpacing WRITE setRowSpacing)\par
1391   Q_PROPERTY(FillOrder fillOrder READ fillOrder WRITE setFillOrder)\par
1392   Q_PROPERTY({\cf18 int} wrap READ wrap WRITE setWrap)\par
1394 {\cf17 public}:\par
1395   \par
1403   {\cf17 enum} FillOrder \{ foRowsFirst    \par
1404                   ,foColumnsFirst \par
1405                 \};\par
1406   Q_ENUMS(FillOrder)\par
1407   \par
1408   explicit QCPLayoutGrid();\par
1409   virtual ~QCPLayoutGrid() Q_DECL_OVERRIDE;\par
1410   \par
1411   {\cf20 // getters:}\par
1412   {\cf18 int} rowCount(){\cf17  const }\{ {\cf19 return} mElements.size(); \}\par
1413   {\cf18 int} columnCount(){\cf17  const }\{ {\cf19 return} mElements.size() > 0 ? mElements.first().size() : 0; \}\par
1414   QList<double> columnStretchFactors(){\cf17  const }\{ {\cf19 return} mColumnStretchFactors; \}\par
1415   QList<double> rowStretchFactors(){\cf17  const }\{ {\cf19 return} mRowStretchFactors; \}\par
1416   {\cf18 int} columnSpacing(){\cf17  const }\{ {\cf19 return} mColumnSpacing; \}\par
1417   {\cf18 int} rowSpacing(){\cf17  const }\{ {\cf19 return} mRowSpacing; \}\par
1418   {\cf18 int} wrap(){\cf17  const }\{ {\cf19 return} mWrap; \}\par
1419   FillOrder fillOrder(){\cf17  const }\{ {\cf19 return} mFillOrder; \}\par
1420   \par
1421   {\cf20 // setters:}\par
1422   {\cf18 void} setColumnStretchFactor({\cf18 int} column, {\cf18 double} factor);\par
1423   {\cf18 void} setColumnStretchFactors({\cf17 const} QList<double> &factors);\par
1424   {\cf18 void} setRowStretchFactor({\cf18 int} row, {\cf18 double} factor);\par
1425   {\cf18 void} setRowStretchFactors({\cf17 const} QList<double> &factors);\par
1426   {\cf18 void} setColumnSpacing({\cf18 int} pixels);\par
1427   {\cf18 void} setRowSpacing({\cf18 int} pixels);\par
1428   {\cf18 void} setWrap({\cf18 int} count);\par
1429   {\cf18 void} setFillOrder(FillOrder order, {\cf18 bool} rearrange={\cf17 true});\par
1430   \par
1431   {\cf20 // reimplemented virtual methods:}\par
1432   {\cf17 virtual} {\cf18 void} updateLayout() Q_DECL_OVERRIDE;\par
1433   virtual {\cf18 int} elementCount() const Q_DECL_OVERRIDE \{ {\cf19 return} rowCount()*columnCount(); \}\par
1434   {\cf17 virtual} QCPLayoutElement* elementAt({\cf18 int} index) {\cf17 const} Q_DECL_OVERRIDE;\par
1435   {\cf17 virtual} QCPLayoutElement* takeAt({\cf18 int} index) Q_DECL_OVERRIDE;\par
1436   {\cf17 virtual} {\cf18 bool} take(QCPLayoutElement* element) Q_DECL_OVERRIDE;\par
1437   {\cf17 virtual} QList<QCPLayoutElement*> elements({\cf18 bool} recursive) {\cf17 const} Q_DECL_OVERRIDE;\par
1438   {\cf17 virtual} {\cf18 void} simplify() Q_DECL_OVERRIDE;\par
1439   virtual QSize minimumOuterSizeHint() const Q_DECL_OVERRIDE;\par
1440   virtual QSize maximumOuterSizeHint() const Q_DECL_OVERRIDE;\par
1441   \par
1442   {\cf20 // non-virtual methods:}\par
1443   QCPLayoutElement *element({\cf18 int} row, {\cf18 int} column) const;\par
1444   {\cf18 bool} addElement({\cf18 int} row, {\cf18 int} column, QCPLayoutElement *element);\par
1445   {\cf18 bool} addElement(QCPLayoutElement *element);\par
1446   {\cf18 bool} hasElement({\cf18 int} row, {\cf18 int} column);\par
1447   {\cf18 void} expandTo({\cf18 int} newRowCount, {\cf18 int} newColumnCount);\par
1448   {\cf18 void} insertRow({\cf18 int} newIndex);\par
1449   {\cf18 void} insertColumn({\cf18 int} newIndex);\par
1450   {\cf18 int} rowColToIndex({\cf18 int} row, {\cf18 int} column) const;\par
1451   {\cf18 void} indexToRowCol({\cf18 int} index, {\cf18 int} &row, {\cf18 int} &column) const;\par
1452   \par
1453 protected:\par
1454   {\cf20 // property members:}\par
1455   QList<QList<QCPLayoutElement*> > mElements;\par
1456   QList<{\cf18 double}> mColumnStretchFactors;\par
1457   QList<{\cf18 double}> mRowStretchFactors;\par
1458   {\cf18 int} mColumnSpacing, mRowSpacing;\par
1459   {\cf18 int} mWrap;\par
1460   FillOrder mFillOrder;\par
1461   \par
1462   {\cf20 // non-virtual methods:}\par
1463   {\cf18 void} getMinimumRowColSizes(QVector<{\cf18 int}> *minColWidths, QVector<{\cf18 int}> *minRowHeights) const;\par
1464   {\cf18 void} getMaximumRowColSizes(QVector<{\cf18 int}> *maxColWidths, QVector<{\cf18 int}> *maxRowHeights) const;\par
1465   \par
1466 private:\par
1467   Q_DISABLE_COPY(QCPLayoutGrid)\par
1468 \};\par
1469 Q_DECLARE_METATYPE(QCPLayoutGrid::FillOrder)\par
1470 \par
1471 \par
1472 class QCP_LIB_DECL QCPLayoutInset : public QCPLayout\par
1473 \{\par
1474   Q_OBJECT\par
1475 {\cf17 public}:\par
1479   {\cf17 enum} InsetPlacement \{ ipFree            \par
1480                         ,ipBorderAligned  \par
1481                       \};\par
1482   Q_ENUMS(InsetPlacement)\par
1483   \par
1484   explicit QCPLayoutInset();\par
1485   virtual ~QCPLayoutInset() Q_DECL_OVERRIDE;\par
1486   \par
1487   {\cf20 // getters:}\par
1488   InsetPlacement insetPlacement({\cf18 int} index) const;\par
1489   Qt::Alignment insetAlignment({\cf18 int} index) const;\par
1490   QRectF insetRect({\cf18 int} index) const;\par
1491   \par
1492   {\cf20 // setters:}\par
1493   {\cf18 void} setInsetPlacement({\cf18 int} index, InsetPlacement placement);\par
1494   {\cf18 void} setInsetAlignment({\cf18 int} index, Qt::Alignment alignment);\par
1495   {\cf18 void} setInsetRect({\cf18 int} index, const QRectF &rect);\par
1496   \par
1497   {\cf20 // reimplemented virtual methods:}\par
1498   virtual {\cf18 void} updateLayout() Q_DECL_OVERRIDE;\par
1499   virtual {\cf18 int} elementCount() const Q_DECL_OVERRIDE;\par
1500   virtual QCPLayoutElement* elementAt({\cf18 int} index) const Q_DECL_OVERRIDE;\par
1501   virtual QCPLayoutElement* takeAt({\cf18 int} index) Q_DECL_OVERRIDE;\par
1502   virtual {\cf18 bool} take(QCPLayoutElement* element) Q_DECL_OVERRIDE;\par
1503   virtual {\cf18 void} simplify() Q_DECL_OVERRIDE \{\}\par
1504   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
1505   \par
1506   {\cf20 // non-virtual methods:}\par
1507   {\cf18 void} addElement(QCPLayoutElement *element, Qt::Alignment alignment);\par
1508   {\cf18 void} addElement(QCPLayoutElement *element, const QRectF &rect);\par
1509   \par
1510 protected:\par
1511   {\cf20 // property members:}\par
1512   QList<QCPLayoutElement*> mElements;\par
1513   QList<InsetPlacement> mInsetPlacement;\par
1514   QList<Qt::Alignment> mInsetAlignment;\par
1515   QList<QRectF> mInsetRect;\par
1516   \par
1517 private:\par
1518   Q_DISABLE_COPY(QCPLayoutInset)\par
1519 \};\par
1520 Q_DECLARE_METATYPE(QCPLayoutInset::InsetPlacement)\par
1521 \par
1522 {\cf20 /* end of 'src/layout.h' */}\par
1523 \par
1524 \par
1525 {\cf20 /* including file 'src/lineending.h'       */}\par
1526 {\cf20 /* modified 2022-11-06T12:45:56, size 4426 */}\par
1527 \par
1528 class QCP_LIB_DECL QCPLineEnding\par
1529 \{\par
1530   Q_GADGET\par
1531 {\cf17 public}:\par
1543   {\cf17 enum} EndingStyle \{ esNone          \par
1544                      ,esFlatArrow    \par
1545                      ,esSpikeArrow   \par
1546                      ,esLineArrow    \par
1547                      ,esDisc         \par
1548                      ,esSquare       \par
1549                      ,esDiamond      \par
1550                      ,esBar          \par
1551                      ,esHalfBar      \par
1552                      ,esSkewedBar    \par
1553                    \};\par
1554   Q_ENUMS(EndingStyle)\par
1555   \par
1556   QCPLineEnding();\par
1557   QCPLineEnding(EndingStyle style, {\cf18 double} width=8, {\cf18 double} length=10, {\cf18 bool} inverted=false);\par
1558   \par
1559   {\cf20 // getters:}\par
1560   EndingStyle style(){\cf17  const }\{ {\cf19 return} mStyle; \}\par
1561   {\cf18 double} width(){\cf17  const }\{ {\cf19 return} mWidth; \}\par
1562   {\cf18 double} length(){\cf17  const }\{ {\cf19 return} mLength; \}\par
1563   {\cf18 bool} inverted(){\cf17  const }\{ {\cf19 return} mInverted; \}\par
1564   \par
1565   {\cf20 // setters:}\par
1566   {\cf18 void} setStyle(EndingStyle style);\par
1567   {\cf18 void} setWidth({\cf18 double} width);\par
1568   {\cf18 void} setLength({\cf18 double} length);\par
1569   {\cf18 void} setInverted({\cf18 bool} inverted);\par
1570   \par
1571   {\cf20 // non-property methods:}\par
1572   {\cf18 double} boundingDistance() {\cf17 const};\par
1573   {\cf18 double} realLength() {\cf17 const};\par
1574   {\cf18 void} draw(QCPPainter *painter, {\cf17 const} QCPVector2D &pos, {\cf17 const} QCPVector2D &dir) {\cf17 const};\par
1575   {\cf18 void} draw(QCPPainter *painter, {\cf17 const} QCPVector2D &pos, {\cf18 double} angle) {\cf17 const};\par
1576   \par
1577 {\cf17 protected}:\par
1578   {\cf20 // property members:}\par
1579   EndingStyle mStyle;\par
1580   {\cf18 double} mWidth, mLength;\par
1581   {\cf18 bool} mInverted;\par
1582 \};\par
1583 Q_DECLARE_TYPEINFO(QCPLineEnding, Q_MOVABLE_TYPE);\par
1584 Q_DECLARE_METATYPE(QCPLineEnding::EndingStyle)\par
1585 \par
1586 {\cf20 /* end of 'src/lineending.h' */}\par
1587 \par
1588 \par
1589 {\cf20 /* including file 'src/axis/labelpainter.h' */}\par
1590 {\cf20 /* modified 2022-11-06T12:45:56, size 7086  */}\par
1591 \par
1592 class QCPLabelPainterPrivate\par
1593 \{\par
1594   Q_GADGET\par
1595 {\cf17 public}:\par
1599   {\cf17 enum} AnchorMode \{ amRectangular    \par
1600                     ,amSkewedUpright \par
1601                     ,amSkewedRotated \par
1602                    \};\par
1603   Q_ENUMS(AnchorMode)\par
1604   \par
1605   \par
1608   enum AnchorReferenceType \{ artNormal    \par
1609                              ,artTangent \par
1610                            \};\par
1611   Q_ENUMS(AnchorReferenceType)\par
1612   \par
1613   \par
1616   enum AnchorSide \{ asLeft      \par
1617                     ,asRight    \par
1618                     ,asTop      \par
1619                     ,asBottom   \par
1620                     ,asTopLeft\par
1621                     ,asTopRight\par
1622                     ,asBottomRight\par
1623                     ,asBottomLeft\par
1624                    \};\par
1625   Q_ENUMS(AnchorSide)\par
1626   \par
1627   explicit QCPLabelPainterPrivate(QCustomPlot *parentPlot);\par
1628   virtual ~QCPLabelPainterPrivate();\par
1629   \par
1630   {\cf20 // setters:}\par
1631   {\cf18 void} setAnchorSide(AnchorSide side);\par
1632   {\cf18 void} setAnchorMode(AnchorMode mode);\par
1633   {\cf18 void} setAnchorReference(const QPointF &pixelPoint);\par
1634   {\cf18 void} setAnchorReferenceType(AnchorReferenceType type);\par
1635   {\cf18 void} setFont(const QFont &font);\par
1636   {\cf18 void} setColor(const QColor &color);\par
1637   {\cf18 void} setPadding({\cf18 int} padding);\par
1638   {\cf18 void} setRotation({\cf18 double} rotation);\par
1639   {\cf18 void} setSubstituteExponent({\cf18 bool} enabled);\par
1640   {\cf18 void} setMultiplicationSymbol(QChar symbol);\par
1641   {\cf18 void} setAbbreviateDecimalPowers({\cf18 bool} enabled);\par
1642   {\cf18 void} setCacheSize({\cf18 int} labelCount);\par
1643   \par
1644   {\cf20 // getters:}\par
1645   AnchorMode anchorMode(){\cf17  const }\{ {\cf19 return} mAnchorMode; \}\par
1646   AnchorSide anchorSide(){\cf17  const }\{ {\cf19 return} mAnchorSide; \}\par
1647   QPointF anchorReference(){\cf17  const }\{ {\cf19 return} mAnchorReference; \}\par
1648   AnchorReferenceType anchorReferenceType(){\cf17  const }\{ {\cf19 return} mAnchorReferenceType; \}\par
1649   QFont font(){\cf17  const }\{ {\cf19 return} mFont; \}\par
1650   QColor color(){\cf17  const }\{ {\cf19 return} mColor; \}\par
1651   {\cf18 int} padding(){\cf17  const }\{ {\cf19 return} mPadding; \}\par
1652   {\cf18 double} rotation(){\cf17  const }\{ {\cf19 return} mRotation; \}\par
1653   {\cf18 bool} substituteExponent(){\cf17  const }\{ {\cf19 return} mSubstituteExponent; \}\par
1654   QChar multiplicationSymbol(){\cf17  const }\{ {\cf19 return} mMultiplicationSymbol; \}\par
1655   {\cf18 bool} abbreviateDecimalPowers(){\cf17  const }\{ {\cf19 return} mAbbreviateDecimalPowers; \}\par
1656   {\cf18 int} cacheSize() {\cf17 const};\par
1657   \par
1658   {\cf20 //virtual int size() const;}\par
1659   \par
1660   {\cf20 // non-property methods: }\par
1661   {\cf18 void} drawTickLabel(QCPPainter *painter, {\cf17 const} QPointF &tickPos, {\cf17 const} QString &text);\par
1662   {\cf18 void} clearCache();\par
1663   \par
1664   {\cf20 // constants that may be used with setMultiplicationSymbol:}\par
1665   {\cf17 static} {\cf17 const} QChar SymbolDot;\par
1666   {\cf17 static} {\cf17 const} QChar SymbolCross;\par
1667   \par
1668 {\cf17 protected}:\par
1669   {\cf17 struct }CachedLabel\par
1670   \{\par
1671     QPoint offset;\par
1672     QPixmap pixmap;\par
1673   \};\par
1674   {\cf17 struct }LabelData\par
1675   \{\par
1676     AnchorSide side;\par
1677     {\cf18 double} rotation; {\cf20 // angle in degrees}\par
1678     QTransform transform; {\cf20 // the transform about the label anchor which is at (0, 0). Does not contain final absolute x/y positioning on the plot/axis}\par
1679     QString basePart, expPart, suffixPart;\par
1680     QRect baseBounds, expBounds, suffixBounds;\par
1681     QRect totalBounds; {\cf20 // is in a coordinate system where label top left is at (0, 0)}\par
1682     QRect rotatedTotalBounds; {\cf20 // is in a coordinate system where the label anchor is at (0, 0)}\par
1683     QFont baseFont, expFont;\par
1684     QColor color;\par
1685   \};\par
1686   \par
1687   {\cf20 // property members:}\par
1688   AnchorMode mAnchorMode;\par
1689   AnchorSide mAnchorSide;\par
1690   QPointF mAnchorReference;\par
1691   AnchorReferenceType mAnchorReferenceType;\par
1692   QFont mFont;\par
1693   QColor mColor;\par
1694   {\cf18 int} mPadding;\par
1695   {\cf18 double} mRotation; {\cf20 // this is the rotation applied uniformly to all labels, not the heterogeneous rotation in amCircularRotated mode}\par
1696   {\cf18 bool} mSubstituteExponent;\par
1697   QChar mMultiplicationSymbol;\par
1698   {\cf18 bool} mAbbreviateDecimalPowers;\par
1699   {\cf20 // non-property members:}\par
1700   QCustomPlot *mParentPlot;\par
1701   QByteArray mLabelParameterHash; {\cf20 // to determine whether mLabelCache needs to be cleared due to changed parameters}\par
1702   QCache<QString, CachedLabel> mLabelCache;\par
1703   QRect mAxisSelectionBox, mTickLabelsSelectionBox, mLabelSelectionBox;\par
1704   {\cf18 int} mLetterCapHeight, mLetterDescent;\par
1705   \par
1706   {\cf20 // introduced virtual methods:}\par
1707   {\cf17 virtual} {\cf18 void} drawLabelMaybeCached(QCPPainter *painter, {\cf17 const} QFont &font, {\cf17 const} QColor &color, {\cf17 const} QPointF &pos, AnchorSide side, {\cf18 double} rotation, {\cf17 const} QString &text);\par
1708   {\cf17 virtual} QByteArray generateLabelParameterHash() {\cf17 const}; {\cf20 // TODO: get rid of this in favor of invalidation flag upon setters?}\par
1709 \par
1710   {\cf20 // non-virtual methods:}\par
1711   QPointF getAnchorPos({\cf17 const} QPointF &tickPos);\par
1712   {\cf18 void} drawText(QCPPainter *painter, {\cf17 const} QPointF &pos, {\cf17 const} LabelData &labelData) {\cf17 const};\par
1713   LabelData getTickLabelData({\cf17 const} QFont &font, {\cf17 const} QColor &color, {\cf18 double} rotation, AnchorSide side, {\cf17 const} QString &text) {\cf17 const};\par
1714   {\cf18 void} applyAnchorTransform(LabelData &labelData) {\cf17 const};\par
1715   {\cf20 //void getMaxTickLabelSize(const QFont &font, const QString &text, QSize *tickLabelsSize) const;}\par
1716   CachedLabel *createCachedLabel({\cf17 const} LabelData &labelData) {\cf17 const};\par
1717   QByteArray cacheKey({\cf17 const} QString &text, {\cf17 const} QColor &color, {\cf18 double} rotation, AnchorSide side) {\cf17 const};\par
1718   AnchorSide skewedAnchorSide({\cf17 const} QPointF &tickPos, {\cf18 double} sideExpandHorz, {\cf18 double} sideExpandVert) {\cf17 const};\par
1719   AnchorSide rotationCorrectedSide(AnchorSide side, {\cf18 double} rotation) {\cf17 const};\par
1720   {\cf18 void} analyzeFontMetrics();\par
1721 \};\par
1722 Q_DECLARE_METATYPE(QCPLabelPainterPrivate::AnchorMode)\par
1723 Q_DECLARE_METATYPE(QCPLabelPainterPrivate::AnchorSide)\par
1724 \par
1725 \par
1726 {\cf20 /* end of 'src/axis/labelpainter.h' */}\par
1727 \par
1728 \par
1729 {\cf20 /* including file 'src/axis/axisticker.h'  */}\par
1730 {\cf20 /* modified 2022-11-06T12:45:56, size 4230 */}\par
1731 \par
1732 class QCP_LIB_DECL QCPAxisTicker\par
1733 \{\par
1734   Q_GADGET\par
1735 {\cf17 public}:\par
1741   {\cf17 enum} TickStepStrategy\par
1742   \{\par
1743     tssReadability    \par
1744     ,tssMeetTickCount \par
1745   \};\par
1746   Q_ENUMS(TickStepStrategy)\par
1747   \par
1748   QCPAxisTicker();\par
1749   virtual ~QCPAxisTicker();\par
1750   \par
1751   {\cf20 // getters:}\par
1752   TickStepStrategy tickStepStrategy(){\cf17  const }\{ {\cf19 return} mTickStepStrategy; \}\par
1753   {\cf18 int} tickCount(){\cf17  const }\{ {\cf19 return} mTickCount; \}\par
1754   {\cf18 double} tickOrigin(){\cf17  const }\{ {\cf19 return} mTickOrigin; \}\par
1755   \par
1756   {\cf20 // setters:}\par
1757   {\cf18 void} setTickStepStrategy(TickStepStrategy strategy);\par
1758   {\cf18 void} setTickCount({\cf18 int} count);\par
1759   {\cf18 void} setTickOrigin({\cf18 double} origin);\par
1760   \par
1761   {\cf20 // introduced virtual methods:}\par
1762   {\cf17 virtual} {\cf18 void} generate({\cf17 const} QCPRange &range, {\cf17 const} QLocale &locale, QChar formatChar, {\cf18 int} precision, QVector<double> &ticks, QVector<double> *subTicks, QVector<QString> *tickLabels);\par
1763   \par
1764 {\cf17 protected}:\par
1765   {\cf20 // property members:}\par
1766   TickStepStrategy mTickStepStrategy;\par
1767   {\cf18 int} mTickCount;\par
1768   {\cf18 double} mTickOrigin;\par
1769   \par
1770   {\cf20 // introduced virtual methods:}\par
1771   {\cf17 virtual} {\cf18 double} getTickStep({\cf17 const} QCPRange &range);\par
1772   {\cf17 virtual} {\cf18 int} getSubTickCount({\cf18 double} tickStep);\par
1773   {\cf17 virtual} QString getTickLabel({\cf18 double} tick, {\cf17 const} QLocale &locale, QChar formatChar, {\cf18 int} precision);\par
1774   {\cf17 virtual} QVector<double> createTickVector({\cf18 double} tickStep, {\cf17 const} QCPRange &range);\par
1775   {\cf17 virtual} QVector<double> createSubTickVector({\cf18 int} subTickCount, {\cf17 const} QVector<double> &ticks);\par
1776   {\cf17 virtual} QVector<QString> createLabelVector({\cf17 const} QVector<double> &ticks, {\cf17 const} QLocale &locale, QChar formatChar, {\cf18 int} precision);\par
1777   \par
1778   {\cf20 // non-virtual methods:}\par
1779   {\cf18 void} trimTicks({\cf17 const} QCPRange &range, QVector<double> &ticks, {\cf18 bool} keepOneOutlier) {\cf17 const};\par
1780   {\cf18 double} pickClosest({\cf18 double} target, {\cf17 const} QVector<double> &candidates) {\cf17 const};\par
1781   {\cf18 double} getMantissa({\cf18 double} input, {\cf18 double} *magnitude={\cf17 nullptr}) {\cf17 const};\par
1782   {\cf18 double} cleanMantissa({\cf18 double} input) {\cf17 const};\par
1783   \par
1784 {\cf17 private}:\par
1785   Q_DISABLE_COPY(QCPAxisTicker)\par
1786   \par
1787 \};\par
1788 Q_DECLARE_METATYPE(QCPAxisTicker::TickStepStrategy)\par
1789 Q_DECLARE_METATYPE(QSharedPointer<QCPAxisTicker>)\par
1790 \par
1791 {\cf20 /* end of 'src/axis/axisticker.h' */}\par
1792 \par
1793 \par
1794 {\cf20 /* including file 'src/axis/axistickerdatetime.h' */}\par
1795 {\cf20 /* modified 2022-11-06T12:45:56, size 3600        */}\par
1796 \par
1797 class QCP_LIB_DECL QCPAxisTickerDateTime : public QCPAxisTicker\par
1798 \{\par
1799 {\cf17 public}:\par
1800   QCPAxisTickerDateTime();\par
1801   \par
1802   {\cf20 // getters:}\par
1803   QString dateTimeFormat(){\cf17  const }\{ {\cf19 return} mDateTimeFormat; \}\par
1804   Qt::TimeSpec dateTimeSpec(){\cf17  const }\{ {\cf19 return} mDateTimeSpec; \}\par
1805 {\cf21 # if QT_VERSION >= QT_VERSION_CHECK(5, 2, 0)}\par
1806   QTimeZone timeZone(){\cf17  const }\{ {\cf19 return} mTimeZone; \}\par
1807 {\cf21 #endif}\par
1808   \par
1809   {\cf20 // setters:}\par
1810   {\cf18 void} setDateTimeFormat({\cf17 const} QString &format);\par
1811   {\cf18 void} setDateTimeSpec(Qt::TimeSpec spec);\par
1812 {\cf21 # if QT_VERSION >= QT_VERSION_CHECK(5, 2, 0)}\par
1813   {\cf18 void} setTimeZone({\cf17 const} QTimeZone &zone);\par
1814 {\cf21 # endif}\par
1815   {\cf18 void} setTickOrigin({\cf18 double} origin); {\cf20 // hides base class method but calls baseclass implementation ("using" throws off IDEs and doxygen)}\par
1816   {\cf18 void} setTickOrigin({\cf17 const} QDateTime &origin);\par
1817   \par
1818   {\cf20 // static methods:}\par
1819   {\cf17 static} QDateTime keyToDateTime({\cf18 double} key);\par
1820   {\cf17 static} {\cf18 double} dateTimeToKey({\cf17 const} QDateTime &dateTime);\par
1821   {\cf17 static} {\cf18 double} dateTimeToKey({\cf17 const} QDate &date, Qt::TimeSpec timeSpec=Qt::LocalTime);\par
1822   \par
1823 {\cf17 protected}:\par
1824   {\cf20 // property members:}\par
1825   QString mDateTimeFormat;\par
1826   Qt::TimeSpec mDateTimeSpec;\par
1827 {\cf21 # if QT_VERSION >= QT_VERSION_CHECK(5, 2, 0)}\par
1828   QTimeZone mTimeZone;\par
1829 {\cf21 # endif}\par
1830   {\cf20 // non-property members:}\par
1831   {\cf17 enum} DateStrategy \{dsNone, dsUniformTimeInDay, dsUniformDayInMonth\} mDateStrategy;\par
1832   \par
1833   {\cf20 // reimplemented virtual methods:}\par
1834   {\cf17 virtual} {\cf18 double} getTickStep({\cf17 const} QCPRange &range) Q_DECL_OVERRIDE;\par
1835   {\cf17 virtual} {\cf18 int} getSubTickCount({\cf18 double} tickStep) Q_DECL_OVERRIDE;\par
1836   {\cf17 virtual} QString getTickLabel({\cf18 double} tick, {\cf17 const} QLocale &locale, QChar formatChar, {\cf18 int} precision) Q_DECL_OVERRIDE;\par
1837   {\cf17 virtual} QVector<double> createTickVector({\cf18 double} tickStep, {\cf17 const} QCPRange &range) Q_DECL_OVERRIDE;\par
1838 \};\par
1839 \par
1840 {\cf20 /* end of 'src/axis/axistickerdatetime.h' */}\par
1841 \par
1842 \par
1843 {\cf20 /* including file 'src/axis/axistickertime.h' */}\par
1844 {\cf20 /* modified 2022-11-06T12:45:56, size 3542    */}\par
1845 \par
1846 {\cf17 class }QCP_LIB_DECL QCPAxisTickerTime : {\cf17 public} QCPAxisTicker\par
1847 \{\par
1848   Q_GADGET\par
1849 {\cf17 public}:\par
1855   {\cf17 enum} TimeUnit \{ tuMilliseconds \par
1856                   ,tuSeconds     \par
1857                   ,tuMinutes     \par
1858                   ,tuHours       \par
1859                   ,tuDays        \par
1860                 \};\par
1861   Q_ENUMS(TimeUnit)\par
1862   \par
1863   QCPAxisTickerTime();\par
1864 \par
1865   {\cf20 // getters:}\par
1866   QString timeFormat(){\cf17  const }\{ {\cf19 return} mTimeFormat; \}\par
1867   {\cf18 int} fieldWidth(TimeUnit unit){\cf17  const }\{ {\cf19 return} mFieldWidth.value(unit); \}\par
1868   \par
1869   {\cf20 // setters:}\par
1870   {\cf18 void} setTimeFormat({\cf17 const} QString &format);\par
1871   {\cf18 void} setFieldWidth(TimeUnit unit, {\cf18 int} width);\par
1872   \par
1873 {\cf17 protected}:\par
1874   {\cf20 // property members:}\par
1875   QString mTimeFormat;\par
1876   QHash<TimeUnit, int> mFieldWidth;\par
1877   \par
1878   {\cf20 // non-property members:}\par
1879   TimeUnit mSmallestUnit, mBiggestUnit;\par
1880   QHash<TimeUnit, QString> mFormatPattern;\par
1881   \par
1882   {\cf20 // reimplemented virtual methods:}\par
1883   {\cf17 virtual} {\cf18 double} getTickStep({\cf17 const} QCPRange &range) Q_DECL_OVERRIDE;\par
1884   {\cf17 virtual} {\cf18 int} getSubTickCount({\cf18 double} tickStep) Q_DECL_OVERRIDE;\par
1885   {\cf17 virtual} QString getTickLabel({\cf18 double} tick, {\cf17 const} QLocale &locale, QChar formatChar, {\cf18 int} precision) Q_DECL_OVERRIDE;\par
1886   \par
1887   {\cf20 // non-virtual methods:}\par
1888   {\cf18 void} replaceUnit(QString &text, TimeUnit unit, {\cf18 int} value) {\cf17 const};\par
1889 \};\par
1890 Q_DECLARE_METATYPE(QCPAxisTickerTime::TimeUnit)\par
1891 \par
1892 {\cf20 /* end of 'src/axis/axistickertime.h' */}\par
1893 \par
1894 \par
1895 {\cf20 /* including file 'src/axis/axistickerfixed.h' */}\par
1896 {\cf20 /* modified 2022-11-06T12:45:56, size 3308     */}\par
1897 \par
1898 class QCP_LIB_DECL QCPAxisTickerFixed : public QCPAxisTicker\par
1899 \{\par
1900   Q_GADGET\par
1901 {\cf17 public}:\par
1908   {\cf17 enum} ScaleStrategy \{ ssNone      \par
1909                        ,ssMultiples \par
1910                        ,ssPowers    \par
1911                      \};\par
1912   Q_ENUMS(ScaleStrategy)\par
1913   \par
1914   QCPAxisTickerFixed();\par
1915   \par
1916   {\cf20 // getters:}\par
1917   {\cf18 double} tickStep(){\cf17  const }\{ {\cf19 return} mTickStep; \}\par
1918   ScaleStrategy scaleStrategy(){\cf17  const }\{ {\cf19 return} mScaleStrategy; \}\par
1919   \par
1920   {\cf20 // setters:}\par
1921   {\cf18 void} setTickStep({\cf18 double} step);\par
1922   {\cf18 void} setScaleStrategy(ScaleStrategy strategy);\par
1923   \par
1924 {\cf17 protected}:\par
1925   {\cf20 // property members:}\par
1926   {\cf18 double} mTickStep;\par
1927   ScaleStrategy mScaleStrategy;\par
1928   \par
1929   {\cf20 // reimplemented virtual methods:}\par
1930   {\cf17 virtual} {\cf18 double} getTickStep({\cf17 const} QCPRange &range) Q_DECL_OVERRIDE;\par
1931 \};\par
1932 Q_DECLARE_METATYPE(QCPAxisTickerFixed::ScaleStrategy)\par
1933 \par
1934 {\cf20 /* end of 'src/axis/axistickerfixed.h' */}\par
1935 \par
1936 \par
1937 {\cf20 /* including file 'src/axis/axistickertext.h' */}\par
1938 {\cf20 /* modified 2022-11-06T12:45:56, size 3090    */}\par
1939 \par
1940 class QCP_LIB_DECL QCPAxisTickerText : public QCPAxisTicker\par
1941 \{\par
1942 {\cf17 public}:\par
1943   QCPAxisTickerText();\par
1944   \par
1945   {\cf20 // getters:}\par
1946   QMap<double, QString> &ticks() \{ {\cf19 return} mTicks; \}\par
1947   {\cf18 int} subTickCount(){\cf17  const }\{ {\cf19 return} mSubTickCount; \}\par
1948   \par
1949   {\cf20 // setters:}\par
1950   {\cf18 void} setTicks({\cf17 const} QMap<double, QString> &ticks);\par
1951   {\cf18 void} setTicks({\cf17 const} QVector<double> &positions, {\cf17 const} QVector<QString> &labels);\par
1952   {\cf18 void} setSubTickCount({\cf18 int} subTicks);\par
1953   \par
1954   {\cf20 // non-virtual methods:}\par
1955   {\cf18 void} clear();\par
1956   {\cf18 void} addTick({\cf18 double} position, {\cf17 const} QString &label);\par
1957   {\cf18 void} addTicks({\cf17 const} QMap<double, QString> &ticks);\par
1958   {\cf18 void} addTicks({\cf17 const} QVector<double> &positions, {\cf17 const} QVector<QString> &labels);\par
1959   \par
1960 {\cf17 protected}:\par
1961   {\cf20 // property members:}\par
1962   QMap<double, QString> mTicks;\par
1963   {\cf18 int} mSubTickCount;\par
1964   \par
1965   {\cf20 // reimplemented virtual methods:}\par
1966   {\cf17 virtual} {\cf18 double} getTickStep({\cf17 const} QCPRange &range) Q_DECL_OVERRIDE;\par
1967   {\cf17 virtual} {\cf18 int} getSubTickCount({\cf18 double} tickStep) Q_DECL_OVERRIDE;\par
1968   {\cf17 virtual} QString getTickLabel({\cf18 double} tick, {\cf17 const} QLocale &locale, QChar formatChar, {\cf18 int} precision) Q_DECL_OVERRIDE;\par
1969   {\cf17 virtual} QVector<double> createTickVector({\cf18 double} tickStep, {\cf17 const} QCPRange &range) Q_DECL_OVERRIDE;\par
1970 \};\par
1971 \par
1972 {\cf20 /* end of 'src/axis/axistickertext.h' */}\par
1973 \par
1974 \par
1975 {\cf20 /* including file 'src/axis/axistickerpi.h' */}\par
1976 {\cf20 /* modified 2022-11-06T12:45:56, size 3911  */}\par
1977 \par
1978 {\cf17 class }QCP_LIB_DECL QCPAxisTickerPi : {\cf17 public} QCPAxisTicker\par
1979 \{\par
1980   Q_GADGET\par
1981 {\cf17 public}:\par
1987   {\cf17 enum} FractionStyle \{ fsFloatingPoint     \par
1988                        ,fsAsciiFractions   \par
1989                        ,fsUnicodeFractions \par
1990                      \};\par
1991   Q_ENUMS(FractionStyle)\par
1992   \par
1993   QCPAxisTickerPi();\par
1994   \par
1995   {\cf20 // getters:}\par
1996   QString piSymbol(){\cf17  const }\{ {\cf19 return} mPiSymbol; \}\par
1997   {\cf18 double} piValue(){\cf17  const }\{ {\cf19 return} mPiValue; \}\par
1998   {\cf18 bool} periodicity(){\cf17  const }\{ {\cf19 return} mPeriodicity; \}\par
1999   FractionStyle fractionStyle(){\cf17  const }\{ {\cf19 return} mFractionStyle; \}\par
2000   \par
2001   {\cf20 // setters:}\par
2002   {\cf18 void} setPiSymbol(QString symbol);\par
2003   {\cf18 void} setPiValue({\cf18 double} pi);\par
2004   {\cf18 void} setPeriodicity({\cf18 int} multiplesOfPi);\par
2005   {\cf18 void} setFractionStyle(FractionStyle style);\par
2006   \par
2007 {\cf17 protected}:\par
2008   {\cf20 // property members:}\par
2009   QString mPiSymbol;\par
2010   {\cf18 double} mPiValue;\par
2011   {\cf18 int} mPeriodicity;\par
2012   FractionStyle mFractionStyle;\par
2013   \par
2014   {\cf20 // non-property members:}\par
2015   {\cf18 double} mPiTickStep; {\cf20 // size of one tick step in units of mPiValue}\par
2016   \par
2017   {\cf20 // reimplemented virtual methods:}\par
2018   {\cf17 virtual} {\cf18 double} getTickStep({\cf17 const} QCPRange &range) Q_DECL_OVERRIDE;\par
2019   {\cf17 virtual} {\cf18 int} getSubTickCount({\cf18 double} tickStep) Q_DECL_OVERRIDE;\par
2020   {\cf17 virtual} QString getTickLabel({\cf18 double} tick, {\cf17 const} QLocale &locale, QChar formatChar, {\cf18 int} precision) Q_DECL_OVERRIDE;\par
2021   \par
2022   {\cf20 // non-virtual methods:}\par
2023   {\cf18 void} simplifyFraction({\cf18 int} &numerator, {\cf18 int} &denominator) {\cf17 const};\par
2024   QString fractionToString({\cf18 int} numerator, {\cf18 int} denominator) {\cf17 const};\par
2025   QString unicodeFraction({\cf18 int} numerator, {\cf18 int} denominator) {\cf17 const};\par
2026   QString unicodeSuperscript({\cf18 int} number) {\cf17 const};\par
2027   QString unicodeSubscript({\cf18 int} number) {\cf17 const};\par
2028 \};\par
2029 Q_DECLARE_METATYPE(QCPAxisTickerPi::FractionStyle)\par
2030 \par
2031 {\cf20 /* end of 'src/axis/axistickerpi.h' */}\par
2032 \par
2033 \par
2034 {\cf20 /* including file 'src/axis/axistickerlog.h' */}\par
2035 {\cf20 /* modified 2022-11-06T12:45:56, size 2594   */}\par
2036 \par
2037 class QCP_LIB_DECL QCPAxisTickerLog : public QCPAxisTicker\par
2038 \{\par
2039 {\cf17 public}:\par
2040   QCPAxisTickerLog();\par
2041   \par
2042   {\cf20 // getters:}\par
2043   {\cf18 double} logBase(){\cf17  const }\{ {\cf19 return} mLogBase; \}\par
2044   {\cf18 int} subTickCount(){\cf17  const }\{ {\cf19 return} mSubTickCount; \}\par
2045   \par
2046   {\cf20 // setters:}\par
2047   {\cf18 void} setLogBase({\cf18 double} base);\par
2048   {\cf18 void} setSubTickCount({\cf18 int} subTicks);\par
2049   \par
2050 {\cf17 protected}:\par
2051   {\cf20 // property members:}\par
2052   {\cf18 double} mLogBase;\par
2053   {\cf18 int} mSubTickCount;\par
2054   \par
2055   {\cf20 // non-property members:}\par
2056   {\cf18 double} mLogBaseLnInv;\par
2057   \par
2058   {\cf20 // reimplemented virtual methods:}\par
2059   {\cf17 virtual} {\cf18 int} getSubTickCount({\cf18 double} tickStep) Q_DECL_OVERRIDE;\par
2060   {\cf17 virtual} QVector<double> createTickVector({\cf18 double} tickStep, {\cf17 const} QCPRange &range) Q_DECL_OVERRIDE;\par
2061 \};\par
2062 \par
2063 {\cf20 /* end of 'src/axis/axistickerlog.h' */}\par
2064 \par
2065 \par
2066 {\cf20 /* including file 'src/axis/axis.h'         */}\par
2067 {\cf20 /* modified 2022-11-06T12:45:56, size 20913 */}\par
2068 \par
2069 {\cf17 class }QCP_LIB_DECL QCPGrid :{\cf17 public} QCPLayerable\par
2070 \{\par
2071   Q_OBJECT\par
2073   Q_PROPERTY({\cf18 bool} subGridVisible READ subGridVisible WRITE setSubGridVisible)\par
2074   Q_PROPERTY({\cf18 bool} antialiasedSubGrid READ antialiasedSubGrid WRITE setAntialiasedSubGrid)\par
2075   Q_PROPERTY({\cf18 bool} antialiasedZeroLine READ antialiasedZeroLine WRITE setAntialiasedZeroLine)\par
2076   Q_PROPERTY(QPen pen READ pen WRITE setPen)\par
2077   Q_PROPERTY(QPen subGridPen READ subGridPen WRITE setSubGridPen)\par
2078   Q_PROPERTY(QPen zeroLinePen READ zeroLinePen WRITE setZeroLinePen)\par
2080 {\cf17 public}:\par
2081   {\cf17 explicit} QCPGrid(QCPAxis *parentAxis);\par
2082   \par
2083   {\cf20 // getters:}\par
2084   {\cf18 bool} subGridVisible(){\cf17  const }\{ {\cf19 return} mSubGridVisible; \}\par
2085   {\cf18 bool} antialiasedSubGrid(){\cf17  const }\{ {\cf19 return} mAntialiasedSubGrid; \}\par
2086   {\cf18 bool} antialiasedZeroLine(){\cf17  const }\{ {\cf19 return} mAntialiasedZeroLine; \}\par
2087   QPen pen(){\cf17  const }\{ {\cf19 return} mPen; \}\par
2088   QPen subGridPen(){\cf17  const }\{ {\cf19 return} mSubGridPen; \}\par
2089   QPen zeroLinePen(){\cf17  const }\{ {\cf19 return} mZeroLinePen; \}\par
2090   \par
2091   {\cf20 // setters:}\par
2092   {\cf18 void} setSubGridVisible({\cf18 bool} visible);\par
2093   {\cf18 void} setAntialiasedSubGrid({\cf18 bool} enabled);\par
2094   {\cf18 void} setAntialiasedZeroLine({\cf18 bool} enabled);\par
2095   {\cf18 void} setPen({\cf17 const} QPen &pen);\par
2096   {\cf18 void} setSubGridPen({\cf17 const} QPen &pen);\par
2097   {\cf18 void} setZeroLinePen({\cf17 const} QPen &pen);\par
2098   \par
2099 {\cf17 protected}:\par
2100   {\cf20 // property members:}\par
2101   {\cf18 bool} mSubGridVisible;\par
2102   {\cf18 bool} mAntialiasedSubGrid, mAntialiasedZeroLine;\par
2103   QPen mPen, mSubGridPen, mZeroLinePen;\par
2104   \par
2105   {\cf20 // non-property members:}\par
2106   QCPAxis *mParentAxis;\par
2107   \par
2108   {\cf20 // reimplemented virtual methods:}\par
2109   {\cf17 virtual} {\cf18 void} applyDefaultAntialiasingHint(QCPPainter *painter) {\cf17 const} Q_DECL_OVERRIDE;\par
2110   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
2111   \par
2112   {\cf20 // non-virtual methods:}\par
2113   {\cf18 void} drawGridLines(QCPPainter *painter) {\cf17 const};\par
2114   {\cf18 void} drawSubGridLines(QCPPainter *painter) {\cf17 const};\par
2115   \par
2116   {\cf17 friend} {\cf17 class }QCPAxis;\par
2117 \};\par
2118 \par
2119 \par
2120 {\cf17 class }QCP_LIB_DECL QCPAxis : {\cf17 public} QCPLayerable\par
2121 \{\par
2122   Q_OBJECT\par
2124   Q_PROPERTY(AxisType axisType READ axisType)\par
2125   Q_PROPERTY(QCPAxisRect* axisRect READ axisRect)\par
2126   Q_PROPERTY(ScaleType scaleType READ scaleType WRITE setScaleType NOTIFY scaleTypeChanged)\par
2127   Q_PROPERTY(QCPRange range READ range WRITE setRange NOTIFY rangeChanged)\par
2128   Q_PROPERTY({\cf18 bool} rangeReversed READ rangeReversed WRITE setRangeReversed)\par
2129   Q_PROPERTY(QSharedPointer<QCPAxisTicker> ticker READ ticker WRITE setTicker)\par
2130   Q_PROPERTY({\cf18 bool} ticks READ ticks WRITE setTicks)\par
2131   Q_PROPERTY({\cf18 bool} tickLabels READ tickLabels WRITE setTickLabels)\par
2132   Q_PROPERTY({\cf18 int} tickLabelPadding READ tickLabelPadding WRITE setTickLabelPadding)\par
2133   Q_PROPERTY(QFont tickLabelFont READ tickLabelFont WRITE setTickLabelFont)\par
2134   Q_PROPERTY(QColor tickLabelColor READ tickLabelColor WRITE setTickLabelColor)\par
2135   Q_PROPERTY({\cf18 double} tickLabelRotation READ tickLabelRotation WRITE setTickLabelRotation)\par
2136   Q_PROPERTY(LabelSide tickLabelSide READ tickLabelSide WRITE setTickLabelSide)\par
2137   Q_PROPERTY(QString numberFormat READ numberFormat WRITE setNumberFormat)\par
2138   Q_PROPERTY({\cf18 int} numberPrecision READ numberPrecision WRITE setNumberPrecision)\par
2139   Q_PROPERTY(QVector<double> tickVector READ tickVector)\par
2140   Q_PROPERTY(QVector<QString> tickVectorLabels READ tickVectorLabels)\par
2141   Q_PROPERTY({\cf18 int} tickLengthIn READ tickLengthIn WRITE setTickLengthIn)\par
2142   Q_PROPERTY({\cf18 int} tickLengthOut READ tickLengthOut WRITE setTickLengthOut)\par
2143   Q_PROPERTY({\cf18 bool} subTicks READ subTicks WRITE setSubTicks)\par
2144   Q_PROPERTY({\cf18 int} subTickLengthIn READ subTickLengthIn WRITE setSubTickLengthIn)\par
2145   Q_PROPERTY({\cf18 int} subTickLengthOut READ subTickLengthOut WRITE setSubTickLengthOut)\par
2146   Q_PROPERTY(QPen basePen READ basePen WRITE setBasePen)\par
2147   Q_PROPERTY(QPen tickPen READ tickPen WRITE setTickPen)\par
2148   Q_PROPERTY(QPen subTickPen READ subTickPen WRITE setSubTickPen)\par
2149   Q_PROPERTY(QFont labelFont READ labelFont WRITE setLabelFont)\par
2150   Q_PROPERTY(QColor labelColor READ labelColor WRITE setLabelColor)\par
2151   Q_PROPERTY(QString label READ label WRITE setLabel)\par
2152   Q_PROPERTY({\cf18 int} labelPadding READ labelPadding WRITE setLabelPadding)\par
2153   Q_PROPERTY({\cf18 int} padding READ padding WRITE setPadding)\par
2154   Q_PROPERTY({\cf18 int} offset READ offset WRITE setOffset)\par
2155   Q_PROPERTY(SelectableParts selectedParts READ selectedParts WRITE setSelectedParts NOTIFY selectionChanged)\par
2156   Q_PROPERTY(SelectableParts selectableParts READ selectableParts WRITE setSelectableParts NOTIFY selectableChanged)\par
2157   Q_PROPERTY(QFont selectedTickLabelFont READ selectedTickLabelFont WRITE setSelectedTickLabelFont)\par
2158   Q_PROPERTY(QFont selectedLabelFont READ selectedLabelFont WRITE setSelectedLabelFont)\par
2159   Q_PROPERTY(QColor selectedTickLabelColor READ selectedTickLabelColor WRITE setSelectedTickLabelColor)\par
2160   Q_PROPERTY(QColor selectedLabelColor READ selectedLabelColor WRITE setSelectedLabelColor)\par
2161   Q_PROPERTY(QPen selectedBasePen READ selectedBasePen WRITE setSelectedBasePen)\par
2162   Q_PROPERTY(QPen selectedTickPen READ selectedTickPen WRITE setSelectedTickPen)\par
2163   Q_PROPERTY(QPen selectedSubTickPen READ selectedSubTickPen WRITE setSelectedSubTickPen)\par
2164   Q_PROPERTY(QCPLineEnding lowerEnding READ lowerEnding WRITE setLowerEnding)\par
2165   Q_PROPERTY(QCPLineEnding upperEnding READ upperEnding WRITE setUpperEnding)\par
2166   Q_PROPERTY(QCPGrid* grid READ grid)\par
2168 {\cf17 public}:\par
2173   {\cf17 enum} AxisType \{ atLeft    = 0x01  \par
2174                   ,atRight  = 0x02  \par
2175                   ,atTop    = 0x04  \par
2176                   ,atBottom = 0x08  \par
2177                 \};\par
2178   Q_ENUMS(AxisType)\par
2179   Q_FLAGS(AxisTypes)\par
2180   Q_DECLARE_FLAGS(AxisTypes, AxisType)\par
2186   enum LabelSide \{ lsInside    \par
2187                    ,lsOutside  \par
2188                  \};\par
2189   Q_ENUMS(LabelSide)\par
2194   enum ScaleType \{ stLinear       \par
2195                    ,stLogarithmic \par
2196                  \};\par
2197   Q_ENUMS(ScaleType)\par
2202   enum SelectablePart \{ spNone        = 0      \par
2203                         ,spAxis       = 0x001  \par
2204                         ,spTickLabels = 0x002  \par
2205                         ,spAxisLabel  = 0x004  \par
2206                       \};\par
2207   Q_ENUMS(SelectablePart)\par
2208   Q_FLAGS(SelectableParts)\par
2209   Q_DECLARE_FLAGS(SelectableParts, SelectablePart)\par
2210   \par
2211   explicit QCPAxis(QCPAxisRect *parent, AxisType type);\par
2212   virtual ~QCPAxis() Q_DECL_OVERRIDE;\par
2213   \par
2214   {\cf20 // getters:}\par
2215   AxisType axisType(){\cf17  const }\{ {\cf19 return} mAxisType; \}\par
2216   QCPAxisRect *axisRect(){\cf17  const }\{ {\cf19 return} mAxisRect; \}\par
2217   ScaleType scaleType(){\cf17  const }\{ {\cf19 return} mScaleType; \}\par
2218   {\cf17 const} QCPRange range(){\cf17  const }\{ {\cf19 return} mRange; \}\par
2219   {\cf18 bool} rangeReversed(){\cf17  const }\{ {\cf19 return} mRangeReversed; \}\par
2220   QSharedPointer<QCPAxisTicker> ticker(){\cf17  const }\{ {\cf19 return} mTicker; \}\par
2221   {\cf18 bool} ticks(){\cf17  const }\{ {\cf19 return} mTicks; \}\par
2222   {\cf18 bool} tickLabels(){\cf17  const }\{ {\cf19 return} mTickLabels; \}\par
2223   {\cf18 int} tickLabelPadding() {\cf17 const};\par
2224   QFont tickLabelFont(){\cf17  const }\{ {\cf19 return} mTickLabelFont; \}\par
2225   QColor tickLabelColor(){\cf17  const }\{ {\cf19 return} mTickLabelColor; \}\par
2226   {\cf18 double} tickLabelRotation() {\cf17 const};\par
2227   LabelSide tickLabelSide() {\cf17 const};\par
2228   QString numberFormat() {\cf17 const};\par
2229   {\cf18 int} numberPrecision(){\cf17  const }\{ {\cf19 return} mNumberPrecision; \}\par
2230   QVector<double> tickVector(){\cf17  const }\{ {\cf19 return} mTickVector; \}\par
2231   QVector<QString> tickVectorLabels(){\cf17  const }\{ {\cf19 return} mTickVectorLabels; \}\par
2232   {\cf18 int} tickLengthIn() {\cf17 const};\par
2233   {\cf18 int} tickLengthOut() {\cf17 const};\par
2234   {\cf18 bool} subTicks(){\cf17  const }\{ {\cf19 return} mSubTicks; \}\par
2235   {\cf18 int} subTickLengthIn() {\cf17 const};\par
2236   {\cf18 int} subTickLengthOut() {\cf17 const};\par
2237   QPen basePen(){\cf17  const }\{ {\cf19 return} mBasePen; \}\par
2238   QPen tickPen(){\cf17  const }\{ {\cf19 return} mTickPen; \}\par
2239   QPen subTickPen(){\cf17  const }\{ {\cf19 return} mSubTickPen; \}\par
2240   QFont labelFont(){\cf17  const }\{ {\cf19 return} mLabelFont; \}\par
2241   QColor labelColor(){\cf17  const }\{ {\cf19 return} mLabelColor; \}\par
2242   QString label(){\cf17  const }\{ {\cf19 return} mLabel; \}\par
2243   {\cf18 int} labelPadding() {\cf17 const};\par
2244   {\cf18 int} padding(){\cf17  const }\{ {\cf19 return} mPadding; \}\par
2245   {\cf18 int} offset() {\cf17 const};\par
2246   SelectableParts selectedParts(){\cf17  const }\{ {\cf19 return} mSelectedParts; \}\par
2247   SelectableParts selectableParts(){\cf17  const }\{ {\cf19 return} mSelectableParts; \}\par
2248   QFont selectedTickLabelFont(){\cf17  const }\{ {\cf19 return} mSelectedTickLabelFont; \}\par
2249   QFont selectedLabelFont(){\cf17  const }\{ {\cf19 return} mSelectedLabelFont; \}\par
2250   QColor selectedTickLabelColor(){\cf17  const }\{ {\cf19 return} mSelectedTickLabelColor; \}\par
2251   QColor selectedLabelColor(){\cf17  const }\{ {\cf19 return} mSelectedLabelColor; \}\par
2252   QPen selectedBasePen(){\cf17  const }\{ {\cf19 return} mSelectedBasePen; \}\par
2253   QPen selectedTickPen(){\cf17  const }\{ {\cf19 return} mSelectedTickPen; \}\par
2254   QPen selectedSubTickPen(){\cf17  const }\{ {\cf19 return} mSelectedSubTickPen; \}\par
2255   QCPLineEnding lowerEnding() {\cf17 const};\par
2256   QCPLineEnding upperEnding() {\cf17 const};\par
2257   QCPGrid *grid(){\cf17  const }\{ {\cf19 return} mGrid; \}\par
2258   \par
2259   {\cf20 // setters:}\par
2260   Q_SLOT {\cf18 void} setScaleType(QCPAxis::ScaleType type);\par
2261   Q_SLOT {\cf18 void} setRange({\cf17 const} QCPRange &range);\par
2262   {\cf18 void} setRange({\cf18 double} lower, {\cf18 double} upper);\par
2263   {\cf18 void} setRange({\cf18 double} position, {\cf18 double} size, Qt::AlignmentFlag alignment);\par
2264   {\cf18 void} setRangeLower({\cf18 double} lower);\par
2265   {\cf18 void} setRangeUpper({\cf18 double} upper);\par
2266   {\cf18 void} setRangeReversed({\cf18 bool} reversed);\par
2267   {\cf18 void} setTicker(QSharedPointer<QCPAxisTicker> ticker);\par
2268   {\cf18 void} setTicks({\cf18 bool} show);\par
2269   {\cf18 void} setTickLabels({\cf18 bool} show);\par
2270   {\cf18 void} setTickLabelPadding({\cf18 int} padding);\par
2271   {\cf18 void} setTickLabelFont({\cf17 const} QFont &font);\par
2272   {\cf18 void} setTickLabelColor({\cf17 const} QColor &color);\par
2273   {\cf18 void} setTickLabelRotation({\cf18 double} degrees);\par
2274   {\cf18 void} setTickLabelSide(LabelSide side);\par
2275   {\cf18 void} setNumberFormat({\cf17 const} QString &formatCode);\par
2276   {\cf18 void} setNumberPrecision({\cf18 int} precision);\par
2277   {\cf18 void} setTickLength({\cf18 int} inside, {\cf18 int} outside=0);\par
2278   {\cf18 void} setTickLengthIn({\cf18 int} inside);\par
2279   {\cf18 void} setTickLengthOut({\cf18 int} outside);\par
2280   {\cf18 void} setSubTicks({\cf18 bool} show);\par
2281   {\cf18 void} setSubTickLength({\cf18 int} inside, {\cf18 int} outside=0);\par
2282   {\cf18 void} setSubTickLengthIn({\cf18 int} inside);\par
2283   {\cf18 void} setSubTickLengthOut({\cf18 int} outside);\par
2284   {\cf18 void} setBasePen({\cf17 const} QPen &pen);\par
2285   {\cf18 void} setTickPen({\cf17 const} QPen &pen);\par
2286   {\cf18 void} setSubTickPen({\cf17 const} QPen &pen);\par
2287   {\cf18 void} setLabelFont({\cf17 const} QFont &font);\par
2288   {\cf18 void} setLabelColor({\cf17 const} QColor &color);\par
2289   {\cf18 void} setLabel({\cf17 const} QString &str);\par
2290   {\cf18 void} setLabelPadding({\cf18 int} padding);\par
2291   {\cf18 void} setPadding({\cf18 int} padding);\par
2292   {\cf18 void} setOffset({\cf18 int} offset);\par
2293   {\cf18 void} setSelectedTickLabelFont({\cf17 const} QFont &font);\par
2294   {\cf18 void} setSelectedLabelFont({\cf17 const} QFont &font);\par
2295   {\cf18 void} setSelectedTickLabelColor({\cf17 const} QColor &color);\par
2296   {\cf18 void} setSelectedLabelColor({\cf17 const} QColor &color);\par
2297   {\cf18 void} setSelectedBasePen({\cf17 const} QPen &pen);\par
2298   {\cf18 void} setSelectedTickPen({\cf17 const} QPen &pen);\par
2299   {\cf18 void} setSelectedSubTickPen({\cf17 const} QPen &pen);\par
2300   Q_SLOT {\cf18 void} setSelectableParts({\cf17 const} QCPAxis::SelectableParts &selectableParts);\par
2301   Q_SLOT {\cf18 void} setSelectedParts({\cf17 const} QCPAxis::SelectableParts &selectedParts);\par
2302   {\cf18 void} setLowerEnding({\cf17 const} QCPLineEnding &ending);\par
2303   {\cf18 void} setUpperEnding({\cf17 const} QCPLineEnding &ending);\par
2304   \par
2305   {\cf20 // reimplemented virtual methods:}\par
2306   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
2307   \par
2308   {\cf20 // non-property methods:}\par
2309   Qt::Orientation orientation(){\cf17  const }\{ {\cf19 return} mOrientation; \}\par
2310   {\cf18 int} pixelOrientation(){\cf17  const }\{ {\cf19 return} rangeReversed() != (orientation()==Qt::Vertical) ? -1 : 1; \}\par
2311   {\cf18 void} moveRange({\cf18 double} diff);\par
2312   {\cf18 void} scaleRange({\cf18 double} factor);\par
2313   {\cf18 void} scaleRange({\cf18 double} factor, {\cf18 double} center);\par
2314   {\cf18 void} setScaleRatio({\cf17 const} QCPAxis *otherAxis, {\cf18 double} ratio=1.0);\par
2315   {\cf18 void} rescale({\cf18 bool} onlyVisiblePlottables={\cf17 false});\par
2316   {\cf18 double} pixelToCoord({\cf18 double} value) {\cf17 const};\par
2317   {\cf18 double} coordToPixel({\cf18 double} value) {\cf17 const};\par
2318   SelectablePart getPartAt({\cf17 const} QPointF &pos) {\cf17 const};\par
2319   QList<QCPAbstractPlottable*> plottables() {\cf17 const};\par
2320   QList<QCPGraph*> graphs() {\cf17 const};\par
2321   QList<QCPAbstractItem*> items() {\cf17 const};\par
2322   \par
2323   {\cf17 static} AxisType marginSideToAxisType(QCP::MarginSide side);\par
2324   {\cf17 static} Qt::Orientation orientation(AxisType type) \{ {\cf19 return} type==atBottom || type==atTop ? Qt::Horizontal : Qt::Vertical; \}\par
2325   {\cf17 static} AxisType opposite(AxisType type);\par
2326   \par
2327 signals:\par
2328   {\cf18 void} rangeChanged({\cf17 const} QCPRange &newRange);\par
2329   {\cf18 void} rangeChanged({\cf17 const} QCPRange &newRange, {\cf17 const} QCPRange &oldRange);\par
2330   {\cf18 void} scaleTypeChanged(QCPAxis::ScaleType scaleType);\par
2331   {\cf18 void} selectionChanged({\cf17 const} QCPAxis::SelectableParts &parts);\par
2332   {\cf18 void} selectableChanged({\cf17 const} QCPAxis::SelectableParts &parts);\par
2333 \par
2334 {\cf17 protected}:\par
2335   {\cf20 // property members:}\par
2336   {\cf20 // axis base:}\par
2337   AxisType mAxisType;\par
2338   QCPAxisRect *mAxisRect;\par
2339   {\cf20 //int mOffset; // in QCPAxisPainter}\par
2340   {\cf18 int} mPadding;\par
2341   Qt::Orientation mOrientation;\par
2342   SelectableParts mSelectableParts, mSelectedParts;\par
2343   QPen mBasePen, mSelectedBasePen;\par
2344   {\cf20 //QCPLineEnding mLowerEnding, mUpperEnding; // in QCPAxisPainter}\par
2345   {\cf20 // axis label:}\par
2346   {\cf20 //int mLabelPadding; // in QCPAxisPainter}\par
2347   QString mLabel;\par
2348   QFont mLabelFont, mSelectedLabelFont;\par
2349   QColor mLabelColor, mSelectedLabelColor;\par
2350   {\cf20 // tick labels:}\par
2351   {\cf20 //int mTickLabelPadding; // in QCPAxisPainter}\par
2352   {\cf18 bool} mTickLabels;\par
2353   {\cf20 //double mTickLabelRotation; // in QCPAxisPainter}\par
2354   QFont mTickLabelFont, mSelectedTickLabelFont;\par
2355   QColor mTickLabelColor, mSelectedTickLabelColor;\par
2356   {\cf18 int} mNumberPrecision;\par
2357   QLatin1Char mNumberFormatChar;\par
2358   {\cf18 bool} mNumberBeautifulPowers;\par
2359   {\cf20 //bool mNumberMultiplyCross; // QCPAxisPainter}\par
2360   {\cf20 // ticks and subticks:}\par
2361   {\cf18 bool} mTicks;\par
2362   {\cf18 bool} mSubTicks;\par
2363   {\cf20 //int mTickLengthIn, mTickLengthOut, mSubTickLengthIn, mSubTickLengthOut; // QCPAxisPainter}\par
2364   QPen mTickPen, mSelectedTickPen;\par
2365   QPen mSubTickPen, mSelectedSubTickPen;\par
2366   {\cf20 // scale and range:}\par
2367   QCPRange mRange;\par
2368   {\cf18 bool} mRangeReversed;\par
2369   ScaleType mScaleType;\par
2370   \par
2371   {\cf20 // non-property members:}\par
2372   QCPGrid *mGrid;\par
2373   QCPAxisPainterPrivate *mAxisPainter;\par
2374   QSharedPointer<QCPAxisTicker> mTicker;\par
2375   QVector<double> mTickVector;\par
2376   QVector<QString> mTickVectorLabels;\par
2377   QVector<double> mSubTickVector;\par
2378   {\cf18 bool} mCachedMarginValid;\par
2379   {\cf18 int} mCachedMargin;\par
2380   {\cf18 bool} mDragging;\par
2381   QCPRange mDragStartRange;\par
2382   QCP::AntialiasedElements mAADragBackup, mNotAADragBackup;\par
2383   \par
2384   {\cf20 // introduced virtual methods:}\par
2385   {\cf17 virtual} {\cf18 int} calculateMargin();\par
2386   \par
2387   {\cf20 // reimplemented virtual methods:}\par
2388   {\cf17 virtual} {\cf18 void} applyDefaultAntialiasingHint(QCPPainter *painter) {\cf17 const} Q_DECL_OVERRIDE;\par
2389   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
2390   {\cf17 virtual} QCP::Interaction selectionCategory() const Q_DECL_OVERRIDE;\par
2391   {\cf20 // events:}\par
2392   virtual {\cf18 void} selectEvent(QMouseEvent *event, {\cf18 bool} additive, const QVariant &details, {\cf18 bool} *selectionStateChanged) Q_DECL_OVERRIDE;\par
2393   virtual {\cf18 void} deselectEvent({\cf18 bool} *selectionStateChanged) Q_DECL_OVERRIDE;\par
2394   {\cf20 // mouse events:}\par
2395   virtual {\cf18 void} mousePressEvent(QMouseEvent *event, const QVariant &details) Q_DECL_OVERRIDE;\par
2396   virtual {\cf18 void} mouseMoveEvent(QMouseEvent *event, const QPointF &startPos) Q_DECL_OVERRIDE;\par
2397   virtual {\cf18 void} mouseReleaseEvent(QMouseEvent *event, const QPointF &startPos) Q_DECL_OVERRIDE;\par
2398   virtual {\cf18 void} wheelEvent(QWheelEvent *event) Q_DECL_OVERRIDE;\par
2399   \par
2400   {\cf20 // non-virtual methods:}\par
2401   {\cf18 void} setupTickVectors();\par
2402   QPen getBasePen() const;\par
2403   QPen getTickPen() const;\par
2404   QPen getSubTickPen() const;\par
2405   QFont getTickLabelFont() const;\par
2406   QFont getLabelFont() const;\par
2407   QColor getTickLabelColor() const;\par
2408   QColor getLabelColor() const;\par
2409   \par
2410 private:\par
2411   Q_DISABLE_COPY(QCPAxis)\par
2412   \par
2413   friend class QCustomPlot;\par
2414   friend class QCPGrid;\par
2415   friend class QCPAxisRect;\par
2416 \};\par
2417 Q_DECLARE_OPERATORS_FOR_FLAGS(QCPAxis::SelectableParts)\par
2418 Q_DECLARE_OPERATORS_FOR_FLAGS(QCPAxis::AxisTypes)\par
2419 Q_DECLARE_METATYPE(QCPAxis::AxisType)\par
2420 Q_DECLARE_METATYPE(QCPAxis::LabelSide)\par
2421 Q_DECLARE_METATYPE(QCPAxis::ScaleType)\par
2422 Q_DECLARE_METATYPE(QCPAxis::SelectablePart)\par
2423 \par
2424 \par
2425 class QCPAxisPainterPrivate\par
2426 \{\par
2427 {\cf17 public}:\par
2428   {\cf17 explicit} QCPAxisPainterPrivate(QCustomPlot *parentPlot);\par
2429   {\cf17 virtual} ~QCPAxisPainterPrivate();\par
2430   \par
2431   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter);\par
2432   {\cf17 virtual} {\cf18 int} size();\par
2433   {\cf18 void} clearCache();\par
2434   \par
2435   QRect axisSelectionBox(){\cf17  const }\{ {\cf19 return} mAxisSelectionBox; \}\par
2436   QRect tickLabelsSelectionBox(){\cf17  const }\{ {\cf19 return} mTickLabelsSelectionBox; \}\par
2437   QRect labelSelectionBox(){\cf17  const }\{ {\cf19 return} mLabelSelectionBox; \}\par
2438   \par
2439   {\cf20 // public property members:}\par
2440   QCPAxis::AxisType type;\par
2441   QPen basePen;\par
2442   QCPLineEnding lowerEnding, upperEnding; {\cf20 // directly accessed by QCPAxis setters/getters}\par
2443   {\cf18 int} labelPadding; {\cf20 // directly accessed by QCPAxis setters/getters}\par
2444   QFont labelFont;\par
2445   QColor labelColor;\par
2446   QString label;\par
2447   {\cf18 int} tickLabelPadding; {\cf20 // directly accessed by QCPAxis setters/getters}\par
2448   {\cf18 double} tickLabelRotation; {\cf20 // directly accessed by QCPAxis setters/getters}\par
2449   QCPAxis::LabelSide tickLabelSide; {\cf20 // directly accessed by QCPAxis setters/getters}\par
2450   {\cf18 bool} substituteExponent;\par
2451   {\cf18 bool} numberMultiplyCross; {\cf20 // directly accessed by QCPAxis setters/getters}\par
2452   {\cf18 int} tickLengthIn, tickLengthOut, subTickLengthIn, subTickLengthOut; {\cf20 // directly accessed by QCPAxis setters/getters}\par
2453   QPen tickPen, subTickPen;\par
2454   QFont tickLabelFont;\par
2455   QColor tickLabelColor;\par
2456   QRect axisRect, viewportRect;\par
2457   {\cf18 int} offset; {\cf20 // directly accessed by QCPAxis setters/getters}\par
2458   {\cf18 bool} abbreviateDecimalPowers;\par
2459   {\cf18 bool} reversedEndings;\par
2460   \par
2461   QVector<double> subTickPositions;\par
2462   QVector<double> tickPositions;\par
2463   QVector<QString> tickLabels;\par
2464   \par
2465 {\cf17 protected}:\par
2466   {\cf17 struct }CachedLabel\par
2467   \{\par
2468     QPointF offset;\par
2469     QPixmap pixmap;\par
2470   \};\par
2471   {\cf17 struct }TickLabelData\par
2472   \{\par
2473     QString basePart, expPart, suffixPart;\par
2474     QRect baseBounds, expBounds, suffixBounds, totalBounds, rotatedTotalBounds;\par
2475     QFont baseFont, expFont;\par
2476   \};\par
2477   QCustomPlot *mParentPlot;\par
2478   QByteArray mLabelParameterHash; {\cf20 // to determine whether mLabelCache needs to be cleared due to changed parameters}\par
2479   QCache<QString, CachedLabel> mLabelCache;\par
2480   QRect mAxisSelectionBox, mTickLabelsSelectionBox, mLabelSelectionBox;\par
2481   \par
2482   {\cf17 virtual} QByteArray generateLabelParameterHash() {\cf17 const};\par
2483   \par
2484   {\cf17 virtual} {\cf18 void} placeTickLabel(QCPPainter *painter, {\cf18 double} position, {\cf18 int} distanceToAxis, {\cf17 const} QString &text, QSize *tickLabelsSize);\par
2485   {\cf17 virtual} {\cf18 void} drawTickLabel(QCPPainter *painter, {\cf18 double} x, {\cf18 double} y, {\cf17 const} TickLabelData &labelData) {\cf17 const};\par
2486   {\cf17 virtual} TickLabelData getTickLabelData({\cf17 const} QFont &font, {\cf17 const} QString &text) {\cf17 const};\par
2487   {\cf17 virtual} QPointF getTickLabelDrawOffset({\cf17 const} TickLabelData &labelData) {\cf17 const};\par
2488   {\cf17 virtual} {\cf18 void} getMaxTickLabelSize({\cf17 const} QFont &font, {\cf17 const} QString &text, QSize *tickLabelsSize) {\cf17 const};\par
2489 \};\par
2490 \par
2491 {\cf20 /* end of 'src/axis/axis.h' */}\par
2492 \par
2493 \par
2494 {\cf20 /* including file 'src/scatterstyle.h'     */}\par
2495 {\cf20 /* modified 2022-11-06T12:45:56, size 7275 */}\par
2496 \par
2497 {\cf17 class }QCP_LIB_DECL QCPScatterStyle\par
2498 \{\par
2499   Q_GADGET\par
2500 {\cf17 public}:\par
2509   {\cf17 enum} ScatterProperty \{ spNone  = 0x00  \par
2510                          ,spPen   = 0x01  \par
2511                          ,spBrush = 0x02  \par
2512                          ,spSize  = 0x04  \par
2513                          ,spShape = 0x08  \par
2514                          ,spAll   = 0xFF  \par
2515                        \};\par
2516   Q_ENUMS(ScatterProperty)\par
2517   Q_FLAGS(ScatterProperties)\par
2518   Q_DECLARE_FLAGS(ScatterProperties, ScatterProperty)\par
2519 \par
2520   \par
2527   enum ScatterShape \{ ssNone       \par
2528                       ,ssDot       \par
2529                       ,ssCross     \par
2530                       ,ssPlus      \par
2531                       ,ssCircle    \par
2532                       ,ssDisc      \par
2533                       ,ssSquare    \par
2534                       ,ssDiamond   \par
2535                       ,ssStar      \par
2536                       ,ssTriangle  \par
2537                       ,ssTriangleInverted \par
2538                       ,ssCrossSquare      \par
2539                       ,ssPlusSquare       \par
2540                       ,ssCrossCircle      \par
2541                       ,ssPlusCircle       \par
2542                       ,ssPeace     \par
2543                       ,ssPixmap    \par
2544                       ,ssCustom    \par
2545                     \};\par
2546   Q_ENUMS(ScatterShape)\par
2547 \par
2548   QCPScatterStyle();\par
2549   QCPScatterStyle(ScatterShape shape, {\cf18 double} size=6);\par
2550   QCPScatterStyle(ScatterShape shape, const QColor &color, {\cf18 double} size);\par
2551   QCPScatterStyle(ScatterShape shape, const QColor &color, const QColor &fill, {\cf18 double} size);\par
2552   QCPScatterStyle(ScatterShape shape, const QPen &pen, const QBrush &brush, {\cf18 double} size);\par
2553   QCPScatterStyle(const QPixmap &pixmap);\par
2554   QCPScatterStyle(const QPainterPath &customPath, const QPen &pen, const QBrush &brush=Qt::NoBrush, {\cf18 double} size=6);\par
2555   \par
2556   {\cf20 // getters:}\par
2557   {\cf18 double} size(){\cf17  const }\{ {\cf19 return} mSize; \}\par
2558   ScatterShape shape(){\cf17  const }\{ {\cf19 return} mShape; \}\par
2559   QPen pen(){\cf17  const }\{ {\cf19 return} mPen; \}\par
2560   QBrush brush(){\cf17  const }\{ {\cf19 return} mBrush; \}\par
2561   QPixmap pixmap(){\cf17  const }\{ {\cf19 return} mPixmap; \}\par
2562   QPainterPath customPath(){\cf17  const }\{ {\cf19 return} mCustomPath; \}\par
2563 \par
2564   {\cf20 // setters:}\par
2565   {\cf18 void} setFromOther({\cf17 const} QCPScatterStyle &other, ScatterProperties properties);\par
2566   {\cf18 void} setSize({\cf18 double} size);\par
2567   {\cf18 void} setShape(ScatterShape shape);\par
2568   {\cf18 void} setPen({\cf17 const} QPen &pen);\par
2569   {\cf18 void} setBrush({\cf17 const} QBrush &brush);\par
2570   {\cf18 void} setPixmap({\cf17 const} QPixmap &pixmap);\par
2571   {\cf18 void} setCustomPath({\cf17 const} QPainterPath &customPath);\par
2572 \par
2573   {\cf20 // non-property methods:}\par
2574   {\cf18 bool} isNone(){\cf17  const }\{ {\cf19 return} mShape == ssNone; \}\par
2575   {\cf18 bool} isPenDefined(){\cf17  const }\{ {\cf19 return} mPenDefined; \}\par
2576   {\cf18 void} undefinePen();\par
2577   {\cf18 void} applyTo(QCPPainter *painter, {\cf17 const} QPen &defaultPen) {\cf17 const};\par
2578   {\cf18 void} drawShape(QCPPainter *painter, {\cf17 const} QPointF &pos) {\cf17 const};\par
2579   {\cf18 void} drawShape(QCPPainter *painter, {\cf18 double} x, {\cf18 double} y) {\cf17 const};\par
2580 \par
2581 {\cf17 protected}:\par
2582   {\cf20 // property members:}\par
2583   {\cf18 double} mSize;\par
2584   ScatterShape mShape;\par
2585   QPen mPen;\par
2586   QBrush mBrush;\par
2587   QPixmap mPixmap;\par
2588   QPainterPath mCustomPath;\par
2589   \par
2590   {\cf20 // non-property members:}\par
2591   {\cf18 bool} mPenDefined;\par
2592 \};\par
2593 Q_DECLARE_TYPEINFO(QCPScatterStyle, Q_MOVABLE_TYPE);\par
2594 Q_DECLARE_OPERATORS_FOR_FLAGS(QCPScatterStyle::ScatterProperties)\par
2595 Q_DECLARE_METATYPE(QCPScatterStyle::ScatterProperty)\par
2596 Q_DECLARE_METATYPE(QCPScatterStyle::ScatterShape)\par
2597 \par
2598 {\cf20 /* end of 'src/scatterstyle.h' */}\par
2599 \par
2600 \par
2601 {\cf20 /* including file 'src/datacontainer.h'     */}\par
2602 {\cf20 /* modified 2022-11-06T12:45:56, size 34305 */}\par
2603 \par
2604 \par
2609 {\cf17 template} <{\cf17 class} DataType>\par
2610 {\cf17 inline} {\cf18 bool} qcpLessThanSortKey({\cf17 const} DataType &a, {\cf17 const} DataType &b) \{ {\cf19 return} a.sortKey() < b.sortKey(); \}\par
2611 \par
2612 {\cf17 template} <{\cf17 class} DataType>\par
2613 {\cf17 class }QCPDataContainer {\cf20 // no QCP_LIB_DECL, template class ends up in header (cpp included below)}\par
2614 \{\par
2615 {\cf17 public}:\par
2616   {\cf17 typedef} {\cf17 typename} QVector<DataType>::const_iterator const_iterator;\par
2617   {\cf17 typedef} {\cf17 typename} QVector<DataType>::iterator iterator;\par
2618   \par
2619   QCPDataContainer();\par
2620   \par
2621   {\cf20 // getters:}\par
2622   {\cf18 int} size(){\cf17  const }\{ {\cf19 return} mData.size()-mPreallocSize; \}\par
2623   {\cf18 bool} isEmpty(){\cf17  const }\{ {\cf19 return} size() == 0; \}\par
2624   {\cf18 bool} autoSqueeze(){\cf17  const }\{ {\cf19 return} mAutoSqueeze; \}\par
2625   \par
2626   {\cf20 // setters:}\par
2627   {\cf18 void} setAutoSqueeze({\cf18 bool} enabled);\par
2628   \par
2629   {\cf20 // non-virtual methods:}\par
2630   {\cf18 void} set({\cf17 const} QCPDataContainer<DataType> &data);\par
2631   {\cf18 void} set({\cf17 const} QVector<DataType> &data, {\cf18 bool} alreadySorted={\cf17 false});\par
2632   {\cf18 void} add({\cf17 const} QCPDataContainer<DataType> &data);\par
2633   {\cf18 void} add({\cf17 const} QVector<DataType> &data, {\cf18 bool} alreadySorted={\cf17 false});\par
2634   {\cf18 void} add({\cf17 const} DataType &data);\par
2635   {\cf18 void} removeBefore({\cf18 double} sortKey);\par
2636   {\cf18 void} removeAfter({\cf18 double} sortKey);\par
2637   {\cf18 void} remove({\cf18 double} sortKeyFrom, {\cf18 double} sortKeyTo);\par
2638   {\cf18 void} remove({\cf18 double} sortKey);\par
2639   {\cf18 void} clear();\par
2640   {\cf18 void} sort();\par
2641   {\cf18 void} squeeze({\cf18 bool} preAllocation={\cf17 true}, {\cf18 bool} postAllocation={\cf17 true});\par
2642   \par
2643   const_iterator constBegin(){\cf17  const }\{ {\cf19 return} mData.constBegin()+mPreallocSize; \}\par
2644   const_iterator constEnd(){\cf17  const }\{ {\cf19 return} mData.constEnd(); \}\par
2645   iterator begin() \{ {\cf19 return} mData.begin()+mPreallocSize; \}\par
2646   iterator end() \{ {\cf19 return} mData.end(); \}\par
2647   const_iterator findBegin({\cf18 double} sortKey, {\cf18 bool} expandedRange={\cf17 true}) {\cf17 const};\par
2648   const_iterator findEnd({\cf18 double} sortKey, {\cf18 bool} expandedRange={\cf17 true}) {\cf17 const};\par
2649   const_iterator at({\cf18 int} index){\cf17  const }\{ {\cf19 return} constBegin()+qBound(0, index, size()); \}\par
2650   QCPRange keyRange({\cf18 bool} &foundRange, QCP::SignDomain signDomain=QCP::sdBoth);\par
2651   QCPRange valueRange({\cf18 bool} &foundRange, QCP::SignDomain signDomain=QCP::sdBoth, {\cf17 const} QCPRange &inKeyRange=QCPRange());\par
2652   QCPDataRange dataRange(){\cf17  const }\{ {\cf19 return} QCPDataRange(0, size()); \}\par
2653   {\cf18 void} limitIteratorsToDataRange(const_iterator &begin, const_iterator &end, {\cf17 const} QCPDataRange &dataRange) {\cf17 const};\par
2654   \par
2655 {\cf17 protected}:\par
2656   {\cf20 // property members:}\par
2657   {\cf18 bool} mAutoSqueeze;\par
2658   \par
2659   {\cf20 // non-property memebers:}\par
2660   QVector<DataType> mData;\par
2661   {\cf18 int} mPreallocSize;\par
2662   {\cf18 int} mPreallocIteration;\par
2663   \par
2664   {\cf20 // non-virtual methods:}\par
2665   {\cf18 void} preallocateGrow({\cf18 int} minimumPreallocSize);\par
2666   {\cf18 void} performAutoSqueeze();\par
2667 \};\par
2668 \par
2669 \par
2670 \par
2671 {\cf20 // include implementation in header since it is a class template:}\par
2675 \par
2743 {\cf20 /* start documentation of inline functions */}\par
2744 \par
2799 {\cf20 /* end documentation of inline functions */}\par
2800 \par
2805 {\cf17 template} <{\cf17 class} DataType>\par
2806 QCPDataContainer<DataType>::QCPDataContainer() :\par
2807   mAutoSqueeze(true),\par
2808   mPreallocSize(0),\par
2809   mPreallocIteration(0)\par
2810 \{\par
2811 \}\par
2812 \par
2821 {\cf17 template} <{\cf17 class} DataType>\par
2822 {\cf18 void} QCPDataContainer<DataType>::setAutoSqueeze({\cf18 bool} enabled)\par
2823 \{\par
2824   {\cf19 if} (mAutoSqueeze != enabled)\par
2825   \{\par
2826     mAutoSqueeze = enabled;\par
2827     {\cf19 if} (mAutoSqueeze)\par
2828       performAutoSqueeze();\par
2829   \}\par
2830 \}\par
2831 \par
2838 {\cf17 template} <{\cf17 class} DataType>\par
2839 {\cf18 void} QCPDataContainer<DataType>::set({\cf17 const} QCPDataContainer<DataType> &data)\par
2840 \{\par
2841   clear();\par
2842   add(data);\par
2843 \}\par
2844 \par
2854 {\cf17 template} <{\cf17 class} DataType>\par
2855 {\cf18 void} QCPDataContainer<DataType>::set({\cf17 const} QVector<DataType> &data, {\cf18 bool} alreadySorted)\par
2856 \{\par
2857   mData = data;\par
2858   mPreallocSize = 0;\par
2859   mPreallocIteration = 0;\par
2860   {\cf19 if} (!alreadySorted)\par
2861     sort();\par
2862 \}\par
2863 \par
2870 {\cf17 template} <{\cf17 class} DataType>\par
2871 {\cf18 void} QCPDataContainer<DataType>::add({\cf17 const} QCPDataContainer<DataType> &data)\par
2872 \{\par
2873   {\cf19 if} (data.isEmpty())\par
2874     {\cf19 return};\par
2875   \par
2876   {\cf17 const} {\cf18 int} n = data.size();\par
2877   {\cf17 const} {\cf18 int} oldSize = size();\par
2878   \par
2879   {\cf19 if} (oldSize > 0 && !qcpLessThanSortKey<DataType>(*constBegin(), *(data.constEnd()-1))) {\cf20 // prepend if new data keys are all smaller than or equal to existing ones}\par
2880   \{\par
2881     {\cf19 if} (mPreallocSize < n)\par
2882       preallocateGrow(n);\par
2883     mPreallocSize -= n;\par
2884     std::copy(data.constBegin(), data.constEnd(), begin());\par
2885   \} {\cf19 else} {\cf20 // don't need to prepend, so append and merge if necessary}\par
2886   \{\par
2887     mData.resize(mData.size()+n);\par
2888     std::copy(data.constBegin(), data.constEnd(), end()-n);\par
2889     {\cf19 if} (oldSize > 0 && !qcpLessThanSortKey<DataType>(*(constEnd()-n-1), *(constEnd()-n))) {\cf20 // if appended range keys aren't all greater than existing ones, merge the two partitions}\par
2890       std::inplace_merge(begin(), end()-n, end(), qcpLessThanSortKey<DataType>);\par
2891   \}\par
2892 \}\par
2893 \par
2902 {\cf17 template} <{\cf17 class} DataType>\par
2903 {\cf18 void} QCPDataContainer<DataType>::add({\cf17 const} QVector<DataType> &data, {\cf18 bool} alreadySorted)\par
2904 \{\par
2905   {\cf19 if} (data.isEmpty())\par
2906     {\cf19 return};\par
2907   {\cf19 if} (isEmpty())\par
2908   \{\par
2909     set(data, alreadySorted);\par
2910     {\cf19 return};\par
2911   \}\par
2912   \par
2913   {\cf17 const} {\cf18 int} n = data.size();\par
2914   {\cf17 const} {\cf18 int} oldSize = size();\par
2915   \par
2916   {\cf19 if} (alreadySorted && oldSize > 0 && !qcpLessThanSortKey<DataType>(*constBegin(), *(data.constEnd()-1))) {\cf20 // prepend if new data is sorted and keys are all smaller than or equal to existing ones}\par
2917   \{\par
2918     {\cf19 if} (mPreallocSize < n)\par
2919       preallocateGrow(n);\par
2920     mPreallocSize -= n;\par
2921     std::copy(data.constBegin(), data.constEnd(), begin());\par
2922   \} {\cf19 else} {\cf20 // don't need to prepend, so append and then sort and merge if necessary}\par
2923   \{\par
2924     mData.resize(mData.size()+n);\par
2925     std::copy(data.constBegin(), data.constEnd(), end()-n);\par
2926     {\cf19 if} (!alreadySorted) {\cf20 // sort appended subrange if it wasn't already sorted}\par
2927       std::sort(end()-n, end(), qcpLessThanSortKey<DataType>);\par
2928     {\cf19 if} (oldSize > 0 && !qcpLessThanSortKey<DataType>(*(constEnd()-n-1), *(constEnd()-n))) {\cf20 // if appended range keys aren't all greater than existing ones, merge the two partitions}\par
2929       std::inplace_merge(begin(), end()-n, end(), qcpLessThanSortKey<DataType>);\par
2930   \}\par
2931 \}\par
2932 \par
2939 {\cf17 template} <{\cf17 class} DataType>\par
2940 {\cf18 void} QCPDataContainer<DataType>::add({\cf17 const} DataType &data)\par
2941 \{\par
2942   {\cf19 if} (isEmpty() || !qcpLessThanSortKey<DataType>(data, *(constEnd()-1))) {\cf20 // quickly handle appends if new data key is greater or equal to existing ones}\par
2943   \{\par
2944     mData.append(data);\par
2945   \} {\cf19 else} {\cf19 if} (qcpLessThanSortKey<DataType>(data, *constBegin()))  {\cf20 // quickly handle prepends using preallocated space}\par
2946   \{\par
2947     {\cf19 if} (mPreallocSize < 1)\par
2948       preallocateGrow(1);\par
2949     --mPreallocSize;\par
2950     *begin() = data;\par
2951   \} {\cf19 else} {\cf20 // handle inserts, maintaining sorted keys}\par
2952   \{\par
2953     QCPDataContainer<DataType>::iterator insertionPoint = std::lower_bound(begin(), end(), data, qcpLessThanSortKey<DataType>);\par
2954     mData.insert(insertionPoint, data);\par
2955   \}\par
2956 \}\par
2957 \par
2963 {\cf17 template} <{\cf17 class} DataType>\par
2964 {\cf18 void} QCPDataContainer<DataType>::removeBefore({\cf18 double} sortKey)\par
2965 \{\par
2966   QCPDataContainer<DataType>::iterator it = begin();\par
2967   QCPDataContainer<DataType>::iterator itEnd = std::lower_bound(begin(), end(), DataType::fromSortKey(sortKey), qcpLessThanSortKey<DataType>);\par
2968   mPreallocSize += int(itEnd-it); {\cf20 // don't actually delete, just add it to the preallocated block (if it gets too large, squeeze will take care of it)}\par
2969   {\cf19 if} (mAutoSqueeze)\par
2970     performAutoSqueeze();\par
2971 \}\par
2972 \par
2978 {\cf17 template} <{\cf17 class} DataType>\par
2979 {\cf18 void} QCPDataContainer<DataType>::removeAfter({\cf18 double} sortKey)\par
2980 \{\par
2981   QCPDataContainer<DataType>::iterator it = std::upper_bound(begin(), end(), DataType::fromSortKey(sortKey), qcpLessThanSortKey<DataType>);\par
2982   QCPDataContainer<DataType>::iterator itEnd = end();\par
2983   mData.erase(it, itEnd); {\cf20 // typically adds it to the postallocated block}\par
2984   {\cf19 if} (mAutoSqueeze)\par
2985     performAutoSqueeze();\par
2986 \}\par
2987 \par
2995 {\cf17 template} <{\cf17 class} DataType>\par
2996 {\cf18 void} QCPDataContainer<DataType>::remove({\cf18 double} sortKeyFrom, {\cf18 double} sortKeyTo)\par
2997 \{\par
2998   {\cf19 if} (sortKeyFrom >= sortKeyTo || isEmpty())\par
2999     {\cf19 return};\par
3000   \par
3001   QCPDataContainer<DataType>::iterator it = std::lower_bound(begin(), end(), DataType::fromSortKey(sortKeyFrom), qcpLessThanSortKey<DataType>);\par
3002   QCPDataContainer<DataType>::iterator itEnd = std::upper_bound(it, end(), DataType::fromSortKey(sortKeyTo), qcpLessThanSortKey<DataType>);\par
3003   mData.erase(it, itEnd);\par
3004   {\cf19 if} (mAutoSqueeze)\par
3005     performAutoSqueeze();\par
3006 \}\par
3007 \par
3017 {\cf17 template} <{\cf17 class} DataType>\par
3018 {\cf18 void} QCPDataContainer<DataType>::remove({\cf18 double} sortKey)\par
3019 \{\par
3020   QCPDataContainer::iterator it = std::lower_bound(begin(), end(), DataType::fromSortKey(sortKey), qcpLessThanSortKey<DataType>);\par
3021   {\cf19 if} (it != end() && it->sortKey() == sortKey)\par
3022   \{\par
3023     {\cf19 if} (it == begin())\par
3024       ++mPreallocSize; {\cf20 // don't actually delete, just add it to the preallocated block (if it gets too large, squeeze will take care of it)}\par
3025     {\cf19 else}\par
3026       mData.erase(it);\par
3027   \}\par
3028   {\cf19 if} (mAutoSqueeze)\par
3029     performAutoSqueeze();\par
3030 \}\par
3031 \par
3037 {\cf17 template} <{\cf17 class} DataType>\par
3038 {\cf18 void} QCPDataContainer<DataType>::clear()\par
3039 \{\par
3040   mData.clear();\par
3041   mPreallocIteration = 0;\par
3042   mPreallocSize = 0;\par
3043 \}\par
3044 \par
3056 {\cf17 template} <{\cf17 class} DataType>\par
3057 {\cf18 void} QCPDataContainer<DataType>::sort()\par
3058 \{\par
3059   std::sort(begin(), end(), qcpLessThanSortKey<DataType>);\par
3060 \}\par
3061 \par
3072 {\cf17 template} <{\cf17 class} DataType>\par
3073 {\cf18 void} QCPDataContainer<DataType>::squeeze({\cf18 bool} preAllocation, {\cf18 bool} postAllocation)\par
3074 \{\par
3075   {\cf19 if} (preAllocation)\par
3076   \{\par
3077     {\cf19 if} (mPreallocSize > 0)\par
3078     \{\par
3079       std::copy(begin(), end(), mData.begin());\par
3080       mData.resize(size());\par
3081       mPreallocSize = 0;\par
3082     \}\par
3083     mPreallocIteration = 0;\par
3084   \}\par
3085   {\cf19 if} (postAllocation)\par
3086     mData.squeeze();\par
3087 \}\par
3088 \par
3104 {\cf17 template} <{\cf17 class} DataType>\par
3105 {\cf17 typename} QCPDataContainer<DataType>::const_iterator QCPDataContainer<DataType>::findBegin({\cf18 double} sortKey, {\cf18 bool} expandedRange){\cf17  const}\par
3106 {\cf17 }\{\par
3107   {\cf19 if} (isEmpty())\par
3108     {\cf19 return} constEnd();\par
3109   \par
3110   QCPDataContainer<DataType>::const_iterator it = std::lower_bound(constBegin(), constEnd(), DataType::fromSortKey(sortKey), qcpLessThanSortKey<DataType>);\par
3111   {\cf19 if} (expandedRange && it != constBegin()) {\cf20 // also covers it == constEnd case, and we know --constEnd is valid because mData isn't empty}\par
3112     --it;\par
3113   {\cf19 return} it;\par
3114 \}\par
3115 \par
3131 {\cf17 template} <{\cf17 class} DataType>\par
3132 {\cf17 typename} QCPDataContainer<DataType>::const_iterator QCPDataContainer<DataType>::findEnd({\cf18 double} sortKey, {\cf18 bool} expandedRange){\cf17  const}\par
3133 {\cf17 }\{\par
3134   {\cf19 if} (isEmpty())\par
3135     {\cf19 return} constEnd();\par
3136   \par
3137   QCPDataContainer<DataType>::const_iterator it = std::upper_bound(constBegin(), constEnd(), DataType::fromSortKey(sortKey), qcpLessThanSortKey<DataType>);\par
3138   {\cf19 if} (expandedRange && it != constEnd())\par
3139     ++it;\par
3140   {\cf19 return} it;\par
3141 \}\par
3142 \par
3158 {\cf17 template} <{\cf17 class} DataType>\par
3159 QCPRange QCPDataContainer<DataType>::keyRange({\cf18 bool} &foundRange, QCP::SignDomain signDomain)\par
3160 \{\par
3161   {\cf19 if} (isEmpty())\par
3162   \{\par
3163     foundRange = {\cf17 false};\par
3164     {\cf19 return} QCPRange();\par
3165   \}\par
3166   QCPRange range;\par
3167   {\cf18 bool} haveLower = {\cf17 false};\par
3168   {\cf18 bool} haveUpper = {\cf17 false};\par
3169   {\cf18 double} current;\par
3170   \par
3171   QCPDataContainer<DataType>::const_iterator it = constBegin();\par
3172   QCPDataContainer<DataType>::const_iterator itEnd = constEnd();\par
3173   {\cf19 if} (signDomain == QCP::sdBoth) {\cf20 // range may be anywhere}\par
3174   \{\par
3175     {\cf19 if} (DataType::sortKeyIsMainKey()) {\cf20 // if DataType is sorted by main key (e.g. QCPGraph, but not QCPCurve), use faster algorithm by finding just first and last key with non-NaN value}\par
3176     \{\par
3177       {\cf19 while} (it != itEnd) {\cf20 // find first non-nan going up from left}\par
3178       \{\par
3179         {\cf19 if} (!qIsNaN(it->mainValue()))\par
3180         \{\par
3181           range.lower = it->mainKey();\par
3182           haveLower = {\cf17 true};\par
3183           {\cf19 break};\par
3184         \}\par
3185         ++it;\par
3186       \}\par
3187       it = itEnd;\par
3188       {\cf19 while} (it != constBegin()) {\cf20 // find first non-nan going down from right}\par
3189       \{\par
3190         --it;\par
3191         {\cf19 if} (!qIsNaN(it->mainValue()))\par
3192         \{\par
3193           range.upper = it->mainKey();\par
3194           haveUpper = {\cf17 true};\par
3195           {\cf19 break};\par
3196         \}\par
3197       \}\par
3198     \} {\cf19 else} {\cf20 // DataType is not sorted by main key, go through all data points and accordingly expand range}\par
3199     \{\par
3200       {\cf19 while} (it != itEnd)\par
3201       \{\par
3202         {\cf19 if} (!qIsNaN(it->mainValue()))\par
3203         \{\par
3204           current = it->mainKey();\par
3205           {\cf19 if} (current < range.lower || !haveLower)\par
3206           \{\par
3207             range.lower = current;\par
3208             haveLower = {\cf17 true};\par
3209           \}\par
3210           {\cf19 if} (current > range.upper || !haveUpper)\par
3211           \{\par
3212             range.upper = current;\par
3213             haveUpper = {\cf17 true};\par
3214           \}\par
3215         \}\par
3216         ++it;\par
3217       \}\par
3218     \}\par
3219   \} {\cf19 else} {\cf19 if} (signDomain == QCP::sdNegative) {\cf20 // range may only be in the negative sign domain}\par
3220   \{\par
3221     {\cf19 while} (it != itEnd)\par
3222     \{\par
3223       {\cf19 if} (!qIsNaN(it->mainValue()))\par
3224       \{\par
3225         current = it->mainKey();\par
3226         {\cf19 if} ((current < range.lower || !haveLower) && current < 0)\par
3227         \{\par
3228           range.lower = current;\par
3229           haveLower = {\cf17 true};\par
3230         \}\par
3231         {\cf19 if} ((current > range.upper || !haveUpper) && current < 0)\par
3232         \{\par
3233           range.upper = current;\par
3234           haveUpper = {\cf17 true};\par
3235         \}\par
3236       \}\par
3237       ++it;\par
3238     \}\par
3239   \} {\cf19 else} {\cf19 if} (signDomain == QCP::sdPositive) {\cf20 // range may only be in the positive sign domain}\par
3240   \{\par
3241     {\cf19 while} (it != itEnd)\par
3242     \{\par
3243       {\cf19 if} (!qIsNaN(it->mainValue()))\par
3244       \{\par
3245         current = it->mainKey();\par
3246         {\cf19 if} ((current < range.lower || !haveLower) && current > 0)\par
3247         \{\par
3248           range.lower = current;\par
3249           haveLower = {\cf17 true};\par
3250         \}\par
3251         {\cf19 if} ((current > range.upper || !haveUpper) && current > 0)\par
3252         \{\par
3253           range.upper = current;\par
3254           haveUpper = {\cf17 true};\par
3255         \}\par
3256       \}\par
3257       ++it;\par
3258     \}\par
3259   \}\par
3260   \par
3261   foundRange = haveLower && haveUpper;\par
3262   {\cf19 return} range;\par
3263 \}\par
3264 \par
3283 {\cf17 template} <{\cf17 class} DataType>\par
3284 QCPRange QCPDataContainer<DataType>::valueRange({\cf18 bool} &foundRange, QCP::SignDomain signDomain, {\cf17 const} QCPRange &inKeyRange)\par
3285 \{\par
3286   {\cf19 if} (isEmpty())\par
3287   \{\par
3288     foundRange = {\cf17 false};\par
3289     {\cf19 return} QCPRange();\par
3290   \}\par
3291   QCPRange range;\par
3292   {\cf17 const} {\cf18 bool} restrictKeyRange = inKeyRange != QCPRange();\par
3293   {\cf18 bool} haveLower = {\cf17 false};\par
3294   {\cf18 bool} haveUpper = {\cf17 false};\par
3295   QCPRange current;\par
3296   QCPDataContainer<DataType>::const_iterator itBegin = constBegin();\par
3297   QCPDataContainer<DataType>::const_iterator itEnd = constEnd();\par
3298   {\cf19 if} (DataType::sortKeyIsMainKey() && restrictKeyRange)\par
3299   \{\par
3300     itBegin = findBegin(inKeyRange.lower, {\cf17 false});\par
3301     itEnd = findEnd(inKeyRange.upper, {\cf17 false});\par
3302   \}\par
3303   {\cf19 if} (signDomain == QCP::sdBoth) {\cf20 // range may be anywhere}\par
3304   \{\par
3305     {\cf19 for} (QCPDataContainer<DataType>::const_iterator it = itBegin; it != itEnd; ++it)\par
3306     \{\par
3307       {\cf19 if} (restrictKeyRange && (it->mainKey() < inKeyRange.lower || it->mainKey() > inKeyRange.upper))\par
3308         {\cf19 continue};\par
3309       current = it->valueRange();\par
3310       {\cf19 if} ((current.lower < range.lower || !haveLower) && !qIsNaN(current.lower) && std::isfinite(current.lower))\par
3311       \{\par
3312         range.lower = current.lower;\par
3313         haveLower = {\cf17 true};\par
3314       \}\par
3315       {\cf19 if} ((current.upper > range.upper || !haveUpper) && !qIsNaN(current.upper) && std::isfinite(current.upper))\par
3316       \{\par
3317         range.upper = current.upper;\par
3318         haveUpper = {\cf17 true};\par
3319       \}\par
3320     \}\par
3321   \} {\cf19 else} {\cf19 if} (signDomain == QCP::sdNegative) {\cf20 // range may only be in the negative sign domain}\par
3322   \{\par
3323     {\cf19 for} (QCPDataContainer<DataType>::const_iterator it = itBegin; it != itEnd; ++it)\par
3324     \{\par
3325       {\cf19 if} (restrictKeyRange && (it->mainKey() < inKeyRange.lower || it->mainKey() > inKeyRange.upper))\par
3326         {\cf19 continue};\par
3327       current = it->valueRange();\par
3328       {\cf19 if} ((current.lower < range.lower || !haveLower) && current.lower < 0 && !qIsNaN(current.lower) && std::isfinite(current.lower))\par
3329       \{\par
3330         range.lower = current.lower;\par
3331         haveLower = {\cf17 true};\par
3332       \}\par
3333       {\cf19 if} ((current.upper > range.upper || !haveUpper) && current.upper < 0 && !qIsNaN(current.upper) && std::isfinite(current.upper))\par
3334       \{\par
3335         range.upper = current.upper;\par
3336         haveUpper = {\cf17 true};\par
3337       \}\par
3338     \}\par
3339   \} {\cf19 else} {\cf19 if} (signDomain == QCP::sdPositive) {\cf20 // range may only be in the positive sign domain}\par
3340   \{\par
3341     {\cf19 for} (QCPDataContainer<DataType>::const_iterator it = itBegin; it != itEnd; ++it)\par
3342     \{\par
3343       {\cf19 if} (restrictKeyRange && (it->mainKey() < inKeyRange.lower || it->mainKey() > inKeyRange.upper))\par
3344         {\cf19 continue};\par
3345       current = it->valueRange();\par
3346       {\cf19 if} ((current.lower < range.lower || !haveLower) && current.lower > 0 && !qIsNaN(current.lower) && std::isfinite(current.lower))\par
3347       \{\par
3348         range.lower = current.lower;\par
3349         haveLower = {\cf17 true};\par
3350       \}\par
3351       {\cf19 if} ((current.upper > range.upper || !haveUpper) && current.upper > 0 && !qIsNaN(current.upper) && std::isfinite(current.upper))\par
3352       \{\par
3353         range.upper = current.upper;\par
3354         haveUpper = {\cf17 true};\par
3355       \}\par
3356     \}\par
3357   \}\par
3358   \par
3359   foundRange = haveLower && haveUpper;\par
3360   {\cf19 return} range;\par
3361 \}\par
3362 \par
3371 {\cf17 template} <{\cf17 class} DataType>\par
3372 {\cf18 void} QCPDataContainer<DataType>::limitIteratorsToDataRange(const_iterator &begin, const_iterator &end, {\cf17 const} QCPDataRange &dataRange){\cf17  const}\par
3373 {\cf17 }\{\par
3374   QCPDataRange iteratorRange({\cf18 int}(begin-constBegin()), {\cf18 int}(end-constBegin()));\par
3375   iteratorRange = iteratorRange.bounded(dataRange.bounded(this->dataRange()));\par
3376   begin = constBegin()+iteratorRange.begin();\par
3377   end = constBegin()+iteratorRange.end();\par
3378 \}\par
3379 \par
3389 {\cf17 template} <{\cf17 class} DataType>\par
3390 {\cf18 void} QCPDataContainer<DataType>::preallocateGrow({\cf18 int} minimumPreallocSize)\par
3391 \{\par
3392   {\cf19 if} (minimumPreallocSize <= mPreallocSize)\par
3393     {\cf19 return};\par
3394   \par
3395   {\cf18 int} newPreallocSize = minimumPreallocSize;\par
3396   newPreallocSize += (1u<<qBound(4, mPreallocIteration+4, 15)) - 12; {\cf20 // do 4 up to 32768-12 preallocation, doubling in each intermediate iteration}\par
3397   ++mPreallocIteration;\par
3398   \par
3399   {\cf18 int} sizeDifference = newPreallocSize-mPreallocSize;\par
3400   mData.resize(mData.size()+sizeDifference);\par
3401   std::copy_backward(mData.begin()+mPreallocSize, mData.end()-sizeDifference, mData.end());\par
3402   mPreallocSize = newPreallocSize;\par
3403 \}\par
3404 \par
3419 {\cf17 template} <{\cf17 class} DataType>\par
3420 {\cf18 void} QCPDataContainer<DataType>::performAutoSqueeze()\par
3421 \{\par
3422   {\cf17 const} {\cf18 int} totalAlloc = mData.capacity();\par
3423   {\cf17 const} {\cf18 int} postAllocSize = totalAlloc-mData.size();\par
3424   {\cf17 const} {\cf18 int} usedSize = size();\par
3425   {\cf18 bool} shrinkPostAllocation = {\cf17 false};\par
3426   {\cf18 bool} shrinkPreAllocation = {\cf17 false};\par
3427   {\cf19 if} (totalAlloc > 650000) {\cf20 // if allocation is larger, shrink earlier with respect to total used size}\par
3428   \{\par
3429     shrinkPostAllocation = postAllocSize > usedSize*1.5; {\cf20 // QVector grow strategy is 2^n for static data. Watch out not to oscillate!}\par
3430     shrinkPreAllocation = mPreallocSize*10 > usedSize;\par
3431   \} {\cf19 else} {\cf19 if} (totalAlloc > 1000) {\cf20 // below 10 MiB raw data be generous with preallocated memory, below 1k points don't even bother}\par
3432   \{\par
3433     shrinkPostAllocation = postAllocSize > usedSize*5;\par
3434     shrinkPreAllocation = mPreallocSize > usedSize*1.5; {\cf20 // preallocation can grow into postallocation, so can be smaller}\par
3435   \}\par
3436   \par
3437   {\cf19 if} (shrinkPreAllocation || shrinkPostAllocation)\par
3438     squeeze(shrinkPreAllocation, shrinkPostAllocation);\par
3439 \}\par
3440 \par
3441 \par
3442 {\cf20 /* end of 'src/datacontainer.h' */}\par
3443 \par
3444 \par
3445 {\cf20 /* including file 'src/plottable.h'        */}\par
3446 {\cf20 /* modified 2022-11-06T12:45:56, size 8461 */}\par
3447 \par
3448 {\cf17 class }QCP_LIB_DECL QCPSelectionDecorator\par
3449 \{\par
3450   Q_GADGET\par
3451 {\cf17 public}:\par
3452   QCPSelectionDecorator();\par
3453   {\cf17 virtual} ~QCPSelectionDecorator();\par
3454   \par
3455   {\cf20 // getters:}\par
3456   QPen pen(){\cf17  const }\{ {\cf19 return} mPen; \}\par
3457   QBrush brush(){\cf17  const }\{ {\cf19 return} mBrush; \}\par
3458   QCPScatterStyle scatterStyle(){\cf17  const }\{ {\cf19 return} mScatterStyle; \}\par
3459   QCPScatterStyle::ScatterProperties usedScatterProperties(){\cf17  const }\{ {\cf19 return} mUsedScatterProperties; \}\par
3460   \par
3461   {\cf20 // setters:}\par
3462   {\cf18 void} setPen({\cf17 const} QPen &pen);\par
3463   {\cf18 void} setBrush({\cf17 const} QBrush &brush);\par
3464   {\cf18 void} setScatterStyle({\cf17 const} QCPScatterStyle &scatterStyle, QCPScatterStyle::ScatterProperties usedProperties=QCPScatterStyle::spPen);\par
3465   {\cf18 void} setUsedScatterProperties({\cf17 const} QCPScatterStyle::ScatterProperties &properties);\par
3466   \par
3467   {\cf20 // non-virtual methods:}\par
3468   {\cf18 void} applyPen(QCPPainter *painter) {\cf17 const};\par
3469   {\cf18 void} applyBrush(QCPPainter *painter) {\cf17 const};\par
3470   QCPScatterStyle getFinalScatterStyle({\cf17 const} QCPScatterStyle &unselectedStyle) {\cf17 const};\par
3471   \par
3472   {\cf20 // introduced virtual methods:}\par
3473   {\cf17 virtual} {\cf18 void} copyFrom({\cf17 const} QCPSelectionDecorator *other);\par
3474   {\cf17 virtual} {\cf18 void} drawDecoration(QCPPainter *painter, QCPDataSelection selection);\par
3475   \par
3476 {\cf17 protected}:\par
3477   {\cf20 // property members:}\par
3478   QPen mPen;\par
3479   QBrush mBrush;\par
3480   QCPScatterStyle mScatterStyle;\par
3481   QCPScatterStyle::ScatterProperties mUsedScatterProperties;\par
3482   {\cf20 // non-property members:}\par
3483   QCPAbstractPlottable *mPlottable;\par
3484   \par
3485   {\cf20 // introduced virtual methods:}\par
3486   {\cf17 virtual} {\cf18 bool} registerWithPlottable(QCPAbstractPlottable *plottable);\par
3487   \par
3488 {\cf17 private}:\par
3489   Q_DISABLE_COPY(QCPSelectionDecorator)\par
3490   friend class QCPAbstractPlottable;\par
3491 \};\par
3492 Q_DECLARE_METATYPE(QCPSelectionDecorator*)\par
3493 \par
3494 \par
3495 class QCP_LIB_DECL QCPAbstractPlottable : public QCPLayerable\par
3496 \{\par
3497   Q_OBJECT\par
3499   Q_PROPERTY(QString name READ name WRITE setName)\par
3500   Q_PROPERTY({\cf18 bool} antialiasedFill READ antialiasedFill WRITE setAntialiasedFill)\par
3501   Q_PROPERTY({\cf18 bool} antialiasedScatters READ antialiasedScatters WRITE setAntialiasedScatters)\par
3502   Q_PROPERTY(QPen pen READ pen WRITE setPen)\par
3503   Q_PROPERTY(QBrush brush READ brush WRITE setBrush)\par
3504   Q_PROPERTY(QCPAxis* keyAxis READ keyAxis WRITE setKeyAxis)\par
3505   Q_PROPERTY(QCPAxis* valueAxis READ valueAxis WRITE setValueAxis)\par
3506   Q_PROPERTY(QCP::SelectionType selectable READ selectable WRITE setSelectable NOTIFY selectableChanged)\par
3507   Q_PROPERTY(QCPDataSelection selection READ selection WRITE setSelection NOTIFY selectionChanged)\par
3508   Q_PROPERTY(QCPSelectionDecorator* selectionDecorator READ selectionDecorator WRITE setSelectionDecorator)\par
3510 {\cf17 public}:\par
3511   QCPAbstractPlottable(QCPAxis *keyAxis, QCPAxis *valueAxis);\par
3512   {\cf17 virtual} ~QCPAbstractPlottable() Q_DECL_OVERRIDE;\par
3513   \par
3514   {\cf20 // getters:}\par
3515   QString name(){\cf17  const }\{ {\cf19 return} mName; \}\par
3516   {\cf18 bool} antialiasedFill(){\cf17  const }\{ {\cf19 return} mAntialiasedFill; \}\par
3517   {\cf18 bool} antialiasedScatters(){\cf17  const }\{ {\cf19 return} mAntialiasedScatters; \}\par
3518   QPen pen(){\cf17  const }\{ {\cf19 return} mPen; \}\par
3519   QBrush brush(){\cf17  const }\{ {\cf19 return} mBrush; \}\par
3520   QCPAxis *keyAxis(){\cf17  const }\{ {\cf19 return} mKeyAxis.data(); \}\par
3521   QCPAxis *valueAxis(){\cf17  const }\{ {\cf19 return} mValueAxis.data(); \}\par
3522   QCP::SelectionType selectable(){\cf17  const }\{ {\cf19 return} mSelectable; \}\par
3523   {\cf18 bool} selected(){\cf17  const }\{ {\cf19 return} !mSelection.isEmpty(); \}\par
3524   QCPDataSelection selection(){\cf17  const }\{ {\cf19 return} mSelection; \}\par
3525   QCPSelectionDecorator *selectionDecorator(){\cf17  const }\{ {\cf19 return} mSelectionDecorator; \}\par
3526   \par
3527   {\cf20 // setters:}\par
3528   {\cf18 void} setName({\cf17 const} QString &name);\par
3529   {\cf18 void} setAntialiasedFill({\cf18 bool} enabled);\par
3530   {\cf18 void} setAntialiasedScatters({\cf18 bool} enabled);\par
3531   {\cf18 void} setPen({\cf17 const} QPen &pen);\par
3532   {\cf18 void} setBrush({\cf17 const} QBrush &brush);\par
3533   {\cf18 void} setKeyAxis(QCPAxis *axis);\par
3534   {\cf18 void} setValueAxis(QCPAxis *axis);\par
3535   Q_SLOT {\cf18 void} setSelectable(QCP::SelectionType selectable);\par
3536   Q_SLOT {\cf18 void} setSelection(QCPDataSelection selection);\par
3537   {\cf18 void} setSelectionDecorator(QCPSelectionDecorator *decorator);\par
3538 \par
3539   {\cf20 // introduced virtual methods:}\par
3540   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE = 0; {\cf20 // actually introduced in QCPLayerable as non-pure, but we want to force reimplementation for plottables}\par
3541   virtual QCPPlottableInterface1D *interface1D() \{ {\cf19 return} {\cf17 nullptr}; \}\par
3542   {\cf17 virtual} QCPRange getKeyRange({\cf18 bool} &foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth) {\cf17 const} = 0;\par
3543   {\cf17 virtual} QCPRange getValueRange({\cf18 bool} &foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth, {\cf17 const} QCPRange &inKeyRange=QCPRange()) {\cf17 const} = 0;\par
3544   \par
3545   {\cf20 // non-property methods:}\par
3546   {\cf18 void} coordsToPixels({\cf18 double} key, {\cf18 double} value, {\cf18 double} &x, {\cf18 double} &y) {\cf17 const};\par
3547   {\cf17 const} QPointF coordsToPixels({\cf18 double} key, {\cf18 double} value) {\cf17 const};\par
3548   {\cf18 void} pixelsToCoords({\cf18 double} x, {\cf18 double} y, {\cf18 double} &key, {\cf18 double} &value) {\cf17 const};\par
3549   {\cf18 void} pixelsToCoords({\cf17 const} QPointF &pixelPos, {\cf18 double} &key, {\cf18 double} &value) {\cf17 const};\par
3550   {\cf18 void} rescaleAxes({\cf18 bool} onlyEnlarge={\cf17 false}) {\cf17 const};\par
3551   {\cf18 void} rescaleKeyAxis({\cf18 bool} onlyEnlarge={\cf17 false}) {\cf17 const};\par
3552   {\cf18 void} rescaleValueAxis({\cf18 bool} onlyEnlarge={\cf17 false}, {\cf18 bool} inKeyRange={\cf17 false}) {\cf17 const};\par
3553   {\cf18 bool} addToLegend(QCPLegend *legend);\par
3554   {\cf18 bool} addToLegend();\par
3555   {\cf18 bool} removeFromLegend(QCPLegend *legend) {\cf17 const};\par
3556   {\cf18 bool} removeFromLegend() {\cf17 const};\par
3557   \par
3558 signals:\par
3559   {\cf18 void} selectionChanged({\cf18 bool} selected);\par
3560   {\cf18 void} selectionChanged({\cf17 const} QCPDataSelection &selection);\par
3561   {\cf18 void} selectableChanged(QCP::SelectionType selectable);\par
3562   \par
3563 {\cf17 protected}:\par
3564   {\cf20 // property members:}\par
3565   QString mName;\par
3566   {\cf18 bool} mAntialiasedFill, mAntialiasedScatters;\par
3567   QPen mPen;\par
3568   QBrush mBrush;\par
3569   QPointer<QCPAxis> mKeyAxis, mValueAxis;\par
3570   QCP::SelectionType mSelectable;\par
3571   QCPDataSelection mSelection;\par
3572   QCPSelectionDecorator *mSelectionDecorator;\par
3573   \par
3574   {\cf20 // reimplemented virtual methods:}\par
3575   {\cf17 virtual} QRect clipRect() const Q_DECL_OVERRIDE;\par
3576   virtual {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE = 0;\par
3577   virtual QCP::Interaction selectionCategory() const Q_DECL_OVERRIDE;\par
3578   {\cf18 void} applyDefaultAntialiasingHint(QCPPainter *painter) const Q_DECL_OVERRIDE;\par
3579   {\cf20 // events:}\par
3580   virtual {\cf18 void} selectEvent(QMouseEvent *event, {\cf18 bool} additive, const QVariant &details, {\cf18 bool} *selectionStateChanged) Q_DECL_OVERRIDE;\par
3581   virtual {\cf18 void} deselectEvent({\cf18 bool} *selectionStateChanged) Q_DECL_OVERRIDE;\par
3582   \par
3583   {\cf20 // introduced virtual methods:}\par
3584   virtual {\cf18 void} drawLegendIcon(QCPPainter *painter, const QRectF &rect) const = 0;\par
3585   \par
3586   {\cf20 // non-virtual methods:}\par
3587   {\cf18 void} applyFillAntialiasingHint(QCPPainter *painter) const;\par
3588   {\cf18 void} applyScattersAntialiasingHint(QCPPainter *painter) const;\par
3589 \par
3590 private:\par
3591   Q_DISABLE_COPY(QCPAbstractPlottable)\par
3592   \par
3593   friend class QCustomPlot;\par
3594   friend class QCPAxis;\par
3595   friend class QCPPlottableLegendItem;\par
3596 \};\par
3597 \par
3598 \par
3599 {\cf20 /* end of 'src/plottable.h' */}\par
3600 \par
3601 \par
3602 {\cf20 /* including file 'src/item.h'             */}\par
3603 {\cf20 /* modified 2022-11-06T12:45:56, size 9425 */}\par
3604 \par
3605 class QCP_LIB_DECL QCPItemAnchor\par
3606 \{\par
3607   Q_GADGET\par
3608 {\cf17 public}:\par
3609   QCPItemAnchor(QCustomPlot *parentPlot, QCPAbstractItem *parentItem, {\cf17 const} QString &name, {\cf18 int} anchorId=-1);\par
3610   {\cf17 virtual} ~QCPItemAnchor();\par
3611   \par
3612   {\cf20 // getters:}\par
3613   QString name(){\cf17  const }\{ {\cf19 return} mName; \}\par
3614   {\cf17 virtual} QPointF pixelPosition() {\cf17 const};\par
3615   \par
3616 {\cf17 protected}:\par
3617   {\cf20 // property members:}\par
3618   QString mName;\par
3619   \par
3620   {\cf20 // non-property members:}\par
3621   QCustomPlot *mParentPlot;\par
3622   QCPAbstractItem *mParentItem;\par
3623   {\cf18 int} mAnchorId;\par
3624   QSet<QCPItemPosition*> mChildrenX, mChildrenY;\par
3625   \par
3626   {\cf20 // introduced virtual methods:}\par
3627   {\cf17 virtual} QCPItemPosition *toQCPItemPosition() \{ {\cf19 return} {\cf17 nullptr}; \}\par
3628   \par
3629   {\cf20 // non-virtual methods:}\par
3630   {\cf18 void} addChildX(QCPItemPosition* pos); {\cf20 // called from pos when this anchor is set as parent}\par
3631   {\cf18 void} removeChildX(QCPItemPosition *pos); {\cf20 // called from pos when its parent anchor is reset or pos deleted}\par
3632   {\cf18 void} addChildY(QCPItemPosition* pos); {\cf20 // called from pos when this anchor is set as parent}\par
3633   {\cf18 void} removeChildY(QCPItemPosition *pos); {\cf20 // called from pos when its parent anchor is reset or pos deleted}\par
3634   \par
3635 {\cf17 private}:\par
3636   Q_DISABLE_COPY(QCPItemAnchor)\par
3637   \par
3638   friend class QCPItemPosition;\par
3639 \};\par
3640 \par
3641 \par
3642 \par
3643 class QCP_LIB_DECL QCPItemPosition : public QCPItemAnchor\par
3644 \{\par
3645   Q_GADGET\par
3646 {\cf17 public}:\par
3653   {\cf17 enum} PositionType \{ ptAbsolute        \par
3654                       ,ptViewportRatio  \par
3657                       ,ptAxisRectRatio  \par
3660                       ,ptPlotCoords     \par
3661                     \};\par
3662   Q_ENUMS(PositionType)\par
3663   \par
3664   QCPItemPosition(QCustomPlot *parentPlot, QCPAbstractItem *parentItem, const QString &name);\par
3665   virtual ~QCPItemPosition() Q_DECL_OVERRIDE;\par
3666   \par
3667   {\cf20 // getters:}\par
3668   PositionType type(){\cf17  const }\{ {\cf19 return} typeX(); \}\par
3669   PositionType typeX(){\cf17  const }\{ {\cf19 return} mPositionTypeX; \}\par
3670   PositionType typeY(){\cf17  const }\{ {\cf19 return} mPositionTypeY; \}\par
3671   QCPItemAnchor *parentAnchor(){\cf17  const }\{ {\cf19 return} parentAnchorX(); \}\par
3672   QCPItemAnchor *parentAnchorX(){\cf17  const }\{ {\cf19 return} mParentAnchorX; \}\par
3673   QCPItemAnchor *parentAnchorY(){\cf17  const }\{ {\cf19 return} mParentAnchorY; \}\par
3674   {\cf18 double} key(){\cf17  const }\{ {\cf19 return} mKey; \}\par
3675   {\cf18 double} value(){\cf17  const }\{ {\cf19 return} mValue; \}\par
3676   QPointF coords(){\cf17  const }\{ {\cf19 return} QPointF(mKey, mValue); \}\par
3677   QCPAxis *keyAxis(){\cf17  const }\{ {\cf19 return} mKeyAxis.data(); \}\par
3678   QCPAxis *valueAxis(){\cf17  const }\{ {\cf19 return} mValueAxis.data(); \}\par
3679   QCPAxisRect *axisRect() {\cf17 const};\par
3680   {\cf17 virtual} QPointF pixelPosition() const Q_DECL_OVERRIDE;\par
3681   \par
3682   {\cf20 // setters:}\par
3683   {\cf18 void} setType(PositionType type);\par
3684   {\cf18 void} setTypeX(PositionType type);\par
3685   {\cf18 void} setTypeY(PositionType type);\par
3686   {\cf18 bool} setParentAnchor(QCPItemAnchor *parentAnchor, {\cf18 bool} keepPixelPosition=false);\par
3687   {\cf18 bool} setParentAnchorX(QCPItemAnchor *parentAnchor, {\cf18 bool} keepPixelPosition=false);\par
3688   {\cf18 bool} setParentAnchorY(QCPItemAnchor *parentAnchor, {\cf18 bool} keepPixelPosition=false);\par
3689   {\cf18 void} setCoords({\cf18 double} key, {\cf18 double} value);\par
3690   {\cf18 void} setCoords(const QPointF &pos);\par
3691   {\cf18 void} setAxes(QCPAxis* keyAxis, QCPAxis* valueAxis);\par
3692   {\cf18 void} setAxisRect(QCPAxisRect *axisRect);\par
3693   {\cf18 void} setPixelPosition(const QPointF &pixelPosition);\par
3694   \par
3695 protected:\par
3696   {\cf20 // property members:}\par
3697   PositionType mPositionTypeX, mPositionTypeY;\par
3698   QPointer<QCPAxis> mKeyAxis, mValueAxis;\par
3699   QPointer<QCPAxisRect> mAxisRect;\par
3700   {\cf18 double} mKey, mValue;\par
3701   QCPItemAnchor *mParentAnchorX, *mParentAnchorY;\par
3702   \par
3703   {\cf20 // reimplemented virtual methods:}\par
3704   virtual QCPItemPosition *toQCPItemPosition() Q_DECL_OVERRIDE \{ {\cf19 return} {\cf17 this}; \}\par
3705   \par
3706 {\cf17 private}:\par
3707   Q_DISABLE_COPY(QCPItemPosition)\par
3708   \par
3709 \};\par
3710 Q_DECLARE_METATYPE(QCPItemPosition::PositionType)\par
3711 \par
3712 \par
3713 class QCP_LIB_DECL QCPAbstractItem : public QCPLayerable\par
3714 \{\par
3715   Q_OBJECT\par
3717   Q_PROPERTY({\cf18 bool} clipToAxisRect READ clipToAxisRect WRITE setClipToAxisRect)\par
3718   Q_PROPERTY(QCPAxisRect* clipAxisRect READ clipAxisRect WRITE setClipAxisRect)\par
3719   Q_PROPERTY({\cf18 bool} selectable READ selectable WRITE setSelectable NOTIFY selectableChanged)\par
3720   Q_PROPERTY({\cf18 bool} selected READ selected WRITE setSelected NOTIFY selectionChanged)\par
3722 {\cf17 public}:\par
3723   {\cf17 explicit} QCPAbstractItem(QCustomPlot *parentPlot);\par
3724   {\cf17 virtual} ~QCPAbstractItem() Q_DECL_OVERRIDE;\par
3725   \par
3726   {\cf20 // getters:}\par
3727   {\cf18 bool} clipToAxisRect(){\cf17  const }\{ {\cf19 return} mClipToAxisRect; \}\par
3728   QCPAxisRect *clipAxisRect() {\cf17 const};\par
3729   {\cf18 bool} selectable(){\cf17  const }\{ {\cf19 return} mSelectable; \}\par
3730   {\cf18 bool} selected(){\cf17  const }\{ {\cf19 return} mSelected; \}\par
3731   \par
3732   {\cf20 // setters:}\par
3733   {\cf18 void} setClipToAxisRect({\cf18 bool} clip);\par
3734   {\cf18 void} setClipAxisRect(QCPAxisRect *rect);\par
3735   Q_SLOT {\cf18 void} setSelectable({\cf18 bool} selectable);\par
3736   Q_SLOT {\cf18 void} setSelected({\cf18 bool} selected);\par
3737   \par
3738   {\cf20 // reimplemented virtual methods:}\par
3739   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE = 0;\par
3740   \par
3741   {\cf20 // non-virtual methods:}\par
3742   QList<QCPItemPosition*> positions(){\cf17  const }\{ {\cf19 return} mPositions; \}\par
3743   QList<QCPItemAnchor*> anchors(){\cf17  const }\{ {\cf19 return} mAnchors; \}\par
3744   QCPItemPosition *position({\cf17 const} QString &name) {\cf17 const};\par
3745   QCPItemAnchor *anchor({\cf17 const} QString &name) {\cf17 const};\par
3746   {\cf18 bool} hasAnchor({\cf17 const} QString &name) {\cf17 const};\par
3747   \par
3748 signals:\par
3749   {\cf18 void} selectionChanged({\cf18 bool} selected);\par
3750   {\cf18 void} selectableChanged({\cf18 bool} selectable);\par
3751   \par
3752 {\cf17 protected}:\par
3753   {\cf20 // property members:}\par
3754   {\cf18 bool} mClipToAxisRect;\par
3755   QPointer<QCPAxisRect> mClipAxisRect;\par
3756   QList<QCPItemPosition*> mPositions;\par
3757   QList<QCPItemAnchor*> mAnchors;\par
3758   {\cf18 bool} mSelectable, mSelected;\par
3759   \par
3760   {\cf20 // reimplemented virtual methods:}\par
3761   {\cf17 virtual} QCP::Interaction selectionCategory() const Q_DECL_OVERRIDE;\par
3762   virtual QRect clipRect() const Q_DECL_OVERRIDE;\par
3763   virtual {\cf18 void} applyDefaultAntialiasingHint(QCPPainter *painter) const Q_DECL_OVERRIDE;\par
3764   virtual {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE = 0;\par
3765   {\cf20 // events:}\par
3766   virtual {\cf18 void} selectEvent(QMouseEvent *event, {\cf18 bool} additive, const QVariant &details, {\cf18 bool} *selectionStateChanged) Q_DECL_OVERRIDE;\par
3767   virtual {\cf18 void} deselectEvent({\cf18 bool} *selectionStateChanged) Q_DECL_OVERRIDE;\par
3768   \par
3769   {\cf20 // introduced virtual methods:}\par
3770   virtual QPointF anchorPixelPosition({\cf18 int} anchorId) const;\par
3771   \par
3772   {\cf20 // non-virtual methods:}\par
3773   {\cf18 double} rectDistance(const QRectF &rect, const QPointF &pos, {\cf18 bool} filledRect) const;\par
3774   QCPItemPosition *createPosition(const QString &name);\par
3775   QCPItemAnchor *createAnchor(const QString &name, {\cf18 int} anchorId);\par
3776   \par
3777 private:\par
3778   Q_DISABLE_COPY(QCPAbstractItem)\par
3779   \par
3780   friend class QCustomPlot;\par
3781   friend class QCPItemAnchor;\par
3782 \};\par
3783 \par
3784 {\cf20 /* end of 'src/item.h' */}\par
3785 \par
3786 \par
3787 {\cf20 /* including file 'src/core.h'              */}\par
3788 {\cf20 /* modified 2022-11-06T12:45:56, size 19304 */}\par
3789 \par
3790 class QCP_LIB_DECL QCustomPlot : public QWidget\par
3791 \{\par
3792   Q_OBJECT\par
3794   Q_PROPERTY(QRect viewport READ viewport WRITE setViewport)\par
3795   Q_PROPERTY(QPixmap background READ background WRITE setBackground)\par
3796   Q_PROPERTY({\cf18 bool} backgroundScaled READ backgroundScaled WRITE setBackgroundScaled)\par
3797   Q_PROPERTY(Qt::AspectRatioMode backgroundScaledMode READ backgroundScaledMode WRITE setBackgroundScaledMode)\par
3798   Q_PROPERTY(QCPLayoutGrid* plotLayout READ plotLayout)\par
3799   Q_PROPERTY({\cf18 bool} autoAddPlottableToLegend READ autoAddPlottableToLegend WRITE setAutoAddPlottableToLegend)\par
3800   Q_PROPERTY({\cf18 int} selectionTolerance READ selectionTolerance WRITE setSelectionTolerance)\par
3801   Q_PROPERTY({\cf18 bool} noAntialiasingOnDrag READ noAntialiasingOnDrag WRITE setNoAntialiasingOnDrag)\par
3802   Q_PROPERTY(Qt::KeyboardModifier multiSelectModifier READ multiSelectModifier WRITE setMultiSelectModifier)\par
3803   Q_PROPERTY({\cf18 bool} openGl READ openGl WRITE setOpenGl)\par
3805 {\cf17 public}:\par
3811   {\cf17 enum} LayerInsertMode \{ limBelow  \par
3812                          ,limAbove \par
3813                        \};\par
3814   Q_ENUMS(LayerInsertMode)\par
3815   \par
3816   \par
3821   enum RefreshPriority \{ rpImmediateRefresh \par
3822                          ,rpQueuedRefresh   \par
3823                          ,rpRefreshHint     \par
3824                          ,rpQueuedReplot    \par
3825                        \};\par
3826   Q_ENUMS(RefreshPriority)\par
3827   \par
3828   explicit QCustomPlot(QWidget *parent = {\cf18 nullptr});\par
3829   virtual ~QCustomPlot() Q_DECL_OVERRIDE;\par
3830   \par
3831   {\cf20 // getters:}\par
3832   QRect viewport(){\cf17  const }\{ {\cf19 return} mViewport; \}\par
3833   {\cf18 double} bufferDevicePixelRatio(){\cf17  const }\{ {\cf19 return} mBufferDevicePixelRatio; \}\par
3834   QPixmap background(){\cf17  const }\{ {\cf19 return} mBackgroundPixmap; \}\par
3835   {\cf18 bool} backgroundScaled(){\cf17  const }\{ {\cf19 return} mBackgroundScaled; \}\par
3836   Qt::AspectRatioMode backgroundScaledMode(){\cf17  const }\{ {\cf19 return} mBackgroundScaledMode; \}\par
3837   QCPLayoutGrid *plotLayout(){\cf17  const }\{ {\cf19 return} mPlotLayout; \}\par
3838   QCP::AntialiasedElements antialiasedElements(){\cf17  const }\{ {\cf19 return} mAntialiasedElements; \}\par
3839   QCP::AntialiasedElements notAntialiasedElements(){\cf17  const }\{ {\cf19 return} mNotAntialiasedElements; \}\par
3840   {\cf18 bool} autoAddPlottableToLegend(){\cf17  const }\{ {\cf19 return} mAutoAddPlottableToLegend; \}\par
3841   {\cf17 const} QCP::Interactions interactions(){\cf17  const }\{ {\cf19 return} mInteractions; \}\par
3842   {\cf18 int} selectionTolerance(){\cf17  const }\{ {\cf19 return} mSelectionTolerance; \}\par
3843   {\cf18 bool} noAntialiasingOnDrag(){\cf17  const }\{ {\cf19 return} mNoAntialiasingOnDrag; \}\par
3844   QCP::PlottingHints plottingHints(){\cf17  const }\{ {\cf19 return} mPlottingHints; \}\par
3845   Qt::KeyboardModifier multiSelectModifier(){\cf17  const }\{ {\cf19 return} mMultiSelectModifier; \}\par
3846   QCP::SelectionRectMode selectionRectMode(){\cf17  const }\{ {\cf19 return} mSelectionRectMode; \}\par
3847   QCPSelectionRect *selectionRect(){\cf17  const }\{ {\cf19 return} mSelectionRect; \}\par
3848   {\cf18 bool} openGl(){\cf17  const }\{ {\cf19 return} mOpenGl; \}\par
3849   \par
3850   {\cf20 // setters:}\par
3851   {\cf18 void} setViewport({\cf17 const} QRect &rect);\par
3852   {\cf18 void} setBufferDevicePixelRatio({\cf18 double} ratio);\par
3853   {\cf18 void} setBackground({\cf17 const} QPixmap &pm);\par
3854   {\cf18 void} setBackground({\cf17 const} QPixmap &pm, {\cf18 bool} scaled, Qt::AspectRatioMode mode=Qt::KeepAspectRatioByExpanding);\par
3855   {\cf18 void} setBackground({\cf17 const} QBrush &brush);\par
3856   {\cf18 void} setBackgroundScaled({\cf18 bool} scaled);\par
3857   {\cf18 void} setBackgroundScaledMode(Qt::AspectRatioMode mode);\par
3858   {\cf18 void} setAntialiasedElements({\cf17 const} QCP::AntialiasedElements &antialiasedElements);\par
3859   {\cf18 void} setAntialiasedElement(QCP::AntialiasedElement antialiasedElement, {\cf18 bool} enabled={\cf17 true});\par
3860   {\cf18 void} setNotAntialiasedElements({\cf17 const} QCP::AntialiasedElements &notAntialiasedElements);\par
3861   {\cf18 void} setNotAntialiasedElement(QCP::AntialiasedElement notAntialiasedElement, {\cf18 bool} enabled={\cf17 true});\par
3862   {\cf18 void} setAutoAddPlottableToLegend({\cf18 bool} on);\par
3863   {\cf18 void} setInteractions({\cf17 const} QCP::Interactions &interactions);\par
3864   {\cf18 void} setInteraction({\cf17 const} QCP::Interaction &interaction, {\cf18 bool} enabled={\cf17 true});\par
3865   {\cf18 void} setSelectionTolerance({\cf18 int} pixels);\par
3866   {\cf18 void} setNoAntialiasingOnDrag({\cf18 bool} enabled);\par
3867   {\cf18 void} setPlottingHints({\cf17 const} QCP::PlottingHints &hints);\par
3868   {\cf18 void} setPlottingHint(QCP::PlottingHint hint, {\cf18 bool} enabled={\cf17 true});\par
3869   {\cf18 void} setMultiSelectModifier(Qt::KeyboardModifier modifier);\par
3870   {\cf18 void} setSelectionRectMode(QCP::SelectionRectMode mode);\par
3871   {\cf18 void} setSelectionRect(QCPSelectionRect *selectionRect);\par
3872   {\cf18 void} setOpenGl({\cf18 bool} enabled, {\cf18 int} multisampling=16);\par
3873   \par
3874   {\cf20 // non-property methods:}\par
3875   {\cf20 // plottable interface:}\par
3876   QCPAbstractPlottable *plottable({\cf18 int} index);\par
3877   QCPAbstractPlottable *plottable();\par
3878   {\cf18 bool} removePlottable(QCPAbstractPlottable *plottable);\par
3879   {\cf18 bool} removePlottable({\cf18 int} index);\par
3880   {\cf18 int} clearPlottables();\par
3881   {\cf18 int} plottableCount() {\cf17 const};\par
3882   QList<QCPAbstractPlottable*> selectedPlottables() {\cf17 const};\par
3883   {\cf17 template}<{\cf17 class} PlottableType>\par
3884   PlottableType *plottableAt({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable={\cf17 false}, {\cf18 int} *dataIndex={\cf17 nullptr}) {\cf17 const};\par
3885   QCPAbstractPlottable *plottableAt({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable={\cf17 false}, {\cf18 int} *dataIndex={\cf17 nullptr}) {\cf17 const};\par
3886   {\cf18 bool} hasPlottable(QCPAbstractPlottable *plottable) {\cf17 const};\par
3887  \par
3888   {\cf20 // specialized interface for QCPGraph:}\par
3889   QCPGraph *graph({\cf18 int} index) {\cf17 const};\par
3890   QCPGraph *graph() {\cf17 const};\par
3891   QCPGraph *addGraph(QCPAxis *keyAxis={\cf17 nullptr}, QCPAxis *valueAxis={\cf17 nullptr});\par
3892   {\cf18 bool} removeGraph(QCPGraph *graph);\par
3893   {\cf18 bool} removeGraph({\cf18 int} index);\par
3894   {\cf18 int} clearGraphs();\par
3895   {\cf18 int} graphCount() {\cf17 const};\par
3896   QList<QCPGraph*> selectedGraphs() {\cf17 const};\par
3897 \par
3898   {\cf20 // item interface:}\par
3899   QCPAbstractItem *item({\cf18 int} index) {\cf17 const};\par
3900   QCPAbstractItem *item() {\cf17 const};\par
3901   {\cf18 bool} removeItem(QCPAbstractItem *item);\par
3902   {\cf18 bool} removeItem({\cf18 int} index);\par
3903   {\cf18 int} clearItems();\par
3904   {\cf18 int} itemCount() {\cf17 const};\par
3905   QList<QCPAbstractItem*> selectedItems() {\cf17 const};\par
3906   {\cf17 template}<{\cf17 class} ItemType>\par
3907   ItemType *itemAt({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable={\cf17 false}) {\cf17 const};\par
3908   QCPAbstractItem *itemAt({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable={\cf17 false}) {\cf17 const};\par
3909   {\cf18 bool} hasItem(QCPAbstractItem *item) {\cf17 const};\par
3910   \par
3911   {\cf20 // layer interface:}\par
3912   QCPLayer *layer({\cf17 const} QString &name) {\cf17 const};\par
3913   QCPLayer *layer({\cf18 int} index) {\cf17 const};\par
3914   QCPLayer *currentLayer() {\cf17 const};\par
3915   {\cf18 bool} setCurrentLayer({\cf17 const} QString &name);\par
3916   {\cf18 bool} setCurrentLayer(QCPLayer *layer);\par
3917   {\cf18 int} layerCount() {\cf17 const};\par
3918   {\cf18 bool} addLayer({\cf17 const} QString &name, QCPLayer *otherLayer={\cf17 nullptr}, LayerInsertMode insertMode=limAbove);\par
3919   {\cf18 bool} removeLayer(QCPLayer *layer);\par
3920   {\cf18 bool} moveLayer(QCPLayer *layer, QCPLayer *otherLayer, LayerInsertMode insertMode=limAbove);\par
3921   \par
3922   {\cf20 // axis rect/layout interface:}\par
3923   {\cf18 int} axisRectCount() {\cf17 const};\par
3924   QCPAxisRect* axisRect({\cf18 int} index=0) {\cf17 const};\par
3925   QList<QCPAxisRect*> axisRects() {\cf17 const};\par
3926   QCPLayoutElement* layoutElementAt({\cf17 const} QPointF &pos) {\cf17 const};\par
3927   QCPAxisRect* axisRectAt({\cf17 const} QPointF &pos) {\cf17 const};\par
3928   Q_SLOT {\cf18 void} rescaleAxes({\cf18 bool} onlyVisiblePlottables={\cf17 false});\par
3929   \par
3930   QList<QCPAxis*> selectedAxes() {\cf17 const};\par
3931   QList<QCPLegend*> selectedLegends() {\cf17 const};\par
3932   Q_SLOT {\cf18 void} deselectAll();\par
3933   \par
3934   {\cf18 bool} savePdf({\cf17 const} QString &fileName, {\cf18 int} width=0, {\cf18 int} height=0, QCP::ExportPen exportPen=QCP::epAllowCosmetic, {\cf17 const} QString &pdfCreator=QString(), {\cf17 const} QString &pdfTitle=QString());\par
3935   {\cf18 bool} savePng({\cf17 const} QString &fileName, {\cf18 int} width=0, {\cf18 int} height=0, {\cf18 double} scale=1.0, {\cf18 int} quality=-1, {\cf18 int} resolution=96, QCP::ResolutionUnit resolutionUnit=QCP::ruDotsPerInch);\par
3936   {\cf18 bool} saveJpg({\cf17 const} QString &fileName, {\cf18 int} width=0, {\cf18 int} height=0, {\cf18 double} scale=1.0, {\cf18 int} quality=-1, {\cf18 int} resolution=96, QCP::ResolutionUnit resolutionUnit=QCP::ruDotsPerInch);\par
3937   {\cf18 bool} saveBmp({\cf17 const} QString &fileName, {\cf18 int} width=0, {\cf18 int} height=0, {\cf18 double} scale=1.0, {\cf18 int} resolution=96, QCP::ResolutionUnit resolutionUnit=QCP::ruDotsPerInch);\par
3938   {\cf18 bool} saveRastered({\cf17 const} QString &fileName, {\cf18 int} width, {\cf18 int} height, {\cf18 double} scale, {\cf17 const} {\cf18 char} *format, {\cf18 int} quality=-1, {\cf18 int} resolution=96, QCP::ResolutionUnit resolutionUnit=QCP::ruDotsPerInch);\par
3939   QPixmap toPixmap({\cf18 int} width=0, {\cf18 int} height=0, {\cf18 double} scale=1.0);\par
3940   {\cf18 void} toPainter(QCPPainter *painter, {\cf18 int} width=0, {\cf18 int} height=0);\par
3941   Q_SLOT {\cf18 void} replot(QCustomPlot::RefreshPriority refreshPriority=QCustomPlot::rpRefreshHint);\par
3942   {\cf18 double} replotTime({\cf18 bool} average={\cf17 false}) {\cf17 const};\par
3943   \par
3944   QCPAxis *xAxis, *yAxis, *xAxis2, *yAxis2;\par
3945   QCPLegend *legend;\par
3946   \par
3947 signals:\par
3948   {\cf18 void} mouseDoubleClick(QMouseEvent *event);\par
3949   {\cf18 void} mousePress(QMouseEvent *event);\par
3950   {\cf18 void} mouseMove(QMouseEvent *event);\par
3951   {\cf18 void} mouseRelease(QMouseEvent *event);\par
3952   {\cf18 void} mouseWheel(QWheelEvent *event);\par
3953   \par
3954   {\cf18 void} plottableClick(QCPAbstractPlottable *plottable, {\cf18 int} dataIndex, QMouseEvent *event);\par
3955   {\cf18 void} plottableDoubleClick(QCPAbstractPlottable *plottable, {\cf18 int} dataIndex, QMouseEvent *event);\par
3956   {\cf18 void} itemClick(QCPAbstractItem *item, QMouseEvent *event);\par
3957   {\cf18 void} itemDoubleClick(QCPAbstractItem *item, QMouseEvent *event);\par
3958   {\cf18 void} axisClick(QCPAxis *axis, QCPAxis::SelectablePart part, QMouseEvent *event);\par
3959   {\cf18 void} axisDoubleClick(QCPAxis *axis, QCPAxis::SelectablePart part, QMouseEvent *event);\par
3960   {\cf18 void} legendClick(QCPLegend *legend, QCPAbstractLegendItem *item, QMouseEvent *event);\par
3961   {\cf18 void} legendDoubleClick(QCPLegend *legend,  QCPAbstractLegendItem *item, QMouseEvent *event);\par
3962   \par
3963   {\cf18 void} selectionChangedByUser();\par
3964   {\cf18 void} beforeReplot();\par
3965   {\cf18 void} afterLayout();\par
3966   {\cf18 void} afterReplot();\par
3967   \par
3968 {\cf17 protected}:\par
3969   {\cf20 // property members:}\par
3970   QRect mViewport;\par
3971   {\cf18 double} mBufferDevicePixelRatio;\par
3972   QCPLayoutGrid *mPlotLayout;\par
3973   {\cf18 bool} mAutoAddPlottableToLegend;\par
3974   QList<QCPAbstractPlottable*> mPlottables;\par
3975   QList<QCPGraph*> mGraphs; {\cf20 // extra list of plottables also in mPlottables that are of type QCPGraph}\par
3976   QList<QCPAbstractItem*> mItems;\par
3977   QList<QCPLayer*> mLayers;\par
3978   QCP::AntialiasedElements mAntialiasedElements, mNotAntialiasedElements;\par
3979   QCP::Interactions mInteractions;\par
3980   {\cf18 int} mSelectionTolerance;\par
3981   {\cf18 bool} mNoAntialiasingOnDrag;\par
3982   QBrush mBackgroundBrush;\par
3983   QPixmap mBackgroundPixmap;\par
3984   QPixmap mScaledBackgroundPixmap;\par
3985   {\cf18 bool} mBackgroundScaled;\par
3986   Qt::AspectRatioMode mBackgroundScaledMode;\par
3987   QCPLayer *mCurrentLayer;\par
3988   QCP::PlottingHints mPlottingHints;\par
3989   Qt::KeyboardModifier mMultiSelectModifier;\par
3990   QCP::SelectionRectMode mSelectionRectMode;\par
3991   QCPSelectionRect *mSelectionRect;\par
3992   {\cf18 bool} mOpenGl;\par
3993   \par
3994   {\cf20 // non-property members:}\par
3995   QList<QSharedPointer<QCPAbstractPaintBuffer> > mPaintBuffers;\par
3996   QPoint mMousePressPos;\par
3997   {\cf18 bool} mMouseHasMoved;\par
3998   QPointer<QCPLayerable> mMouseEventLayerable;\par
3999   QPointer<QCPLayerable> mMouseSignalLayerable;\par
4000   QVariant mMouseEventLayerableDetails;\par
4001   QVariant mMouseSignalLayerableDetails;\par
4002   {\cf18 bool} mReplotting;\par
4003   {\cf18 bool} mReplotQueued;\par
4004   {\cf18 double} mReplotTime, mReplotTimeAverage;\par
4005   {\cf18 int} mOpenGlMultisamples;\par
4006   QCP::AntialiasedElements mOpenGlAntialiasedElementsBackup;\par
4007   {\cf18 bool} mOpenGlCacheLabelsBackup;\par
4008 {\cf21 #ifdef QCP_OPENGL_FBO}\par
4009   QSharedPointer<QOpenGLContext> mGlContext;\par
4010   QSharedPointer<QSurface> mGlSurface;\par
4011   QSharedPointer<QOpenGLPaintDevice> mGlPaintDevice;\par
4012 {\cf21 #endif}\par
4013   \par
4014   {\cf20 // reimplemented virtual methods:}\par
4015   {\cf17 virtual} QSize minimumSizeHint() const Q_DECL_OVERRIDE;\par
4016   virtual QSize sizeHint() const Q_DECL_OVERRIDE;\par
4017   virtual {\cf18 void} paintEvent(QPaintEvent *event) Q_DECL_OVERRIDE;\par
4018   virtual {\cf18 void} resizeEvent(QResizeEvent *event) Q_DECL_OVERRIDE;\par
4019   virtual {\cf18 void} mouseDoubleClickEvent(QMouseEvent *event) Q_DECL_OVERRIDE;\par
4020   virtual {\cf18 void} mousePressEvent(QMouseEvent *event) Q_DECL_OVERRIDE;\par
4021   virtual {\cf18 void} mouseMoveEvent(QMouseEvent *event) Q_DECL_OVERRIDE;\par
4022   virtual {\cf18 void} mouseReleaseEvent(QMouseEvent *event) Q_DECL_OVERRIDE;\par
4023   virtual {\cf18 void} wheelEvent(QWheelEvent *event) Q_DECL_OVERRIDE;\par
4024   \par
4025   {\cf20 // introduced virtual methods:}\par
4026   virtual {\cf18 void} draw(QCPPainter *painter);\par
4027   virtual {\cf18 void} updateLayout();\par
4028   virtual {\cf18 void} axisRemoved(QCPAxis *axis);\par
4029   virtual {\cf18 void} legendRemoved(QCPLegend *legend);\par
4030   Q_SLOT virtual {\cf18 void} processRectSelection(QRect rect, QMouseEvent *event);\par
4031   Q_SLOT virtual {\cf18 void} processRectZoom(QRect rect, QMouseEvent *event);\par
4032   Q_SLOT virtual {\cf18 void} processPointSelection(QMouseEvent *event);\par
4033   \par
4034   {\cf20 // non-virtual methods:}\par
4035   {\cf18 bool} registerPlottable(QCPAbstractPlottable *plottable);\par
4036   {\cf18 bool} registerGraph(QCPGraph *graph);\par
4037   {\cf18 bool} registerItem(QCPAbstractItem* item);\par
4038   {\cf18 void} updateLayerIndices() const;\par
4039   QCPLayerable *layerableAt(const QPointF &pos, {\cf18 bool} onlySelectable, QVariant *selectionDetails={\cf18 nullptr}) const;\par
4040   QList<QCPLayerable*> layerableListAt(const QPointF &pos, {\cf18 bool} onlySelectable, QList<QVariant> *selectionDetails={\cf18 nullptr}) const;\par
4041   {\cf18 void} drawBackground(QCPPainter *painter);\par
4042   {\cf18 void} setupPaintBuffers();\par
4043   QCPAbstractPaintBuffer *createPaintBuffer();\par
4044   {\cf18 bool} hasInvalidatedPaintBuffers();\par
4045   {\cf18 bool} setupOpenGl();\par
4046   {\cf18 void} freeOpenGl();\par
4047   \par
4048   friend class QCPLegend;\par
4049   friend class QCPAxis;\par
4050   friend class QCPLayer;\par
4051   friend class QCPAxisRect;\par
4052   friend class QCPAbstractPlottable;\par
4053   friend class QCPGraph;\par
4054   friend class QCPAbstractItem;\par
4055 \};\par
4056 Q_DECLARE_METATYPE(QCustomPlot::LayerInsertMode)\par
4057 Q_DECLARE_METATYPE(QCustomPlot::RefreshPriority)\par
4058 \par
4059 \par
4060 {\cf20 // implementation of template functions:}\par
4061 \par
4080 template<class PlottableType>\par
4081 PlottableType *QCustomPlot::plottableAt(const QPointF &pos, {\cf18 bool} onlySelectable, {\cf18 int} *dataIndex){\cf17  const}\par
4082 {\cf17 }\{\par
4083   PlottableType *resultPlottable = 0;\par
4084   QVariant resultDetails;\par
4085   {\cf18 double} resultDistance = mSelectionTolerance; {\cf20 // only regard clicks with distances smaller than mSelectionTolerance as selections, so initialize with that value}\par
4086   \par
4087   {\cf19 foreach} (QCPAbstractPlottable *plottable, mPlottables)\par
4088   \{\par
4089     PlottableType *currentPlottable = qobject_cast<PlottableType*>(plottable);\par
4090     {\cf19 if} (!currentPlottable || (onlySelectable && !currentPlottable->selectable())) {\cf20 // we could have also passed onlySelectable to the selectTest function, but checking here is faster, because we have access to QCPAbstractPlottable::selectable}\par
4091       {\cf19 continue};\par
4092     {\cf19 if} (currentPlottable->clipRect().contains(pos.toPoint())) {\cf20 // only consider clicks where the plottable is actually visible}\par
4093     \{\par
4094       QVariant details;\par
4095       {\cf18 double} currentDistance = currentPlottable->selectTest(pos, {\cf17 false}, dataIndex ? &details : {\cf17 nullptr});\par
4096       {\cf19 if} (currentDistance >= 0 && currentDistance < resultDistance)\par
4097       \{\par
4098         resultPlottable = currentPlottable;\par
4099         resultDetails = details;\par
4100         resultDistance = currentDistance;\par
4101       \}\par
4102     \}\par
4103   \}\par
4104   \par
4105   {\cf19 if} (resultPlottable && dataIndex)\par
4106   \{\par
4107     QCPDataSelection sel = resultDetails.value<QCPDataSelection>();\par
4108     {\cf19 if} (!sel.isEmpty())\par
4109       *dataIndex = sel.dataRange(0).begin();\par
4110   \}\par
4111   {\cf19 return} resultPlottable;\par
4112 \}\par
4113 \par
4127 {\cf17 template}<{\cf17 class} ItemType>\par
4128 ItemType *QCustomPlot::itemAt({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable){\cf17  const}\par
4129 {\cf17 }\{\par
4130   ItemType *resultItem = 0;\par
4131   {\cf18 double} resultDistance = mSelectionTolerance; {\cf20 // only regard clicks with distances smaller than mSelectionTolerance as selections, so initialize with that value}\par
4132   \par
4133   {\cf19 foreach} (QCPAbstractItem *item, mItems)\par
4134   \{\par
4135     ItemType *currentItem = qobject_cast<ItemType*>(item);\par
4136     {\cf19 if} (!currentItem || (onlySelectable && !currentItem->selectable())) {\cf20 // we could have also passed onlySelectable to the selectTest function, but checking here is faster, because we have access to QCPAbstractItem::selectable}\par
4137       {\cf19 continue};\par
4138     {\cf19 if} (!currentItem->clipToAxisRect() || currentItem->clipRect().contains(pos.toPoint())) {\cf20 // only consider clicks inside axis cliprect of the item if actually clipped to it}\par
4139     \{\par
4140       {\cf18 double} currentDistance = currentItem->selectTest(pos, {\cf17 false});\par
4141       {\cf19 if} (currentDistance >= 0 && currentDistance < resultDistance)\par
4142       \{\par
4143         resultItem = currentItem;\par
4144         resultDistance = currentDistance;\par
4145       \}\par
4146     \}\par
4147   \}\par
4148   \par
4149   {\cf19 return} resultItem;\par
4150 \}\par
4151 \par
4152 \par
4153 \par
4154 {\cf20 /* end of 'src/core.h' */}\par
4155 \par
4156 \par
4157 {\cf20 /* including file 'src/plottable1d.h'       */}\par
4158 {\cf20 /* modified 2022-11-06T12:45:56, size 25638 */}\par
4159 \par
4160 {\cf17 class }QCPPlottableInterface1D\par
4161 \{\par
4162 {\cf17 public}:\par
4163   {\cf17 virtual} ~QCPPlottableInterface1D() = {\cf19 default};\par
4164   {\cf20 // introduced pure virtual methods:}\par
4165   {\cf17 virtual} {\cf18 int} dataCount() {\cf17 const} = 0;\par
4166   {\cf17 virtual} {\cf18 double} dataMainKey({\cf18 int} index) {\cf17 const} = 0;\par
4167   {\cf17 virtual} {\cf18 double} dataSortKey({\cf18 int} index) {\cf17 const} = 0;\par
4168   {\cf17 virtual} {\cf18 double} dataMainValue({\cf18 int} index) {\cf17 const} = 0;\par
4169   {\cf17 virtual} QCPRange dataValueRange({\cf18 int} index) {\cf17 const} = 0;\par
4170   {\cf17 virtual} QPointF dataPixelPosition({\cf18 int} index) {\cf17 const} = 0;\par
4171   {\cf17 virtual} {\cf18 bool} sortKeyIsMainKey() {\cf17 const} = 0;\par
4172   {\cf17 virtual} QCPDataSelection selectTestRect({\cf17 const} QRectF &rect, {\cf18 bool} onlySelectable) {\cf17 const} = 0;\par
4173   {\cf17 virtual} {\cf18 int} findBegin({\cf18 double} sortKey, {\cf18 bool} expandedRange={\cf17 true}) {\cf17 const} = 0;\par
4174   {\cf17 virtual} {\cf18 int} findEnd({\cf18 double} sortKey, {\cf18 bool} expandedRange={\cf17 true}) {\cf17 const} = 0;\par
4175 \};\par
4176 \par
4177 {\cf17 template} <{\cf17 class} DataType>\par
4178 {\cf17 class }QCPAbstractPlottable1D : {\cf17 public} QCPAbstractPlottable, {\cf17 public} QCPPlottableInterface1D {\cf20 // no QCP_LIB_DECL, template class ends up in header (cpp included below)}\par
4179 \{\par
4180   {\cf20 // No Q_OBJECT macro due to template class}\par
4181   \par
4182 {\cf17 public}:\par
4183   QCPAbstractPlottable1D(QCPAxis *keyAxis, QCPAxis *valueAxis);\par
4184   {\cf17 virtual} ~QCPAbstractPlottable1D() Q_DECL_OVERRIDE;\par
4185   \par
4186   {\cf20 // virtual methods of 1d plottable interface:}\par
4187   virtual {\cf18 int} dataCount() const Q_DECL_OVERRIDE;\par
4188   virtual {\cf18 double} dataMainKey({\cf18 int} index) const Q_DECL_OVERRIDE;\par
4189   virtual {\cf18 double} dataSortKey({\cf18 int} index) const Q_DECL_OVERRIDE;\par
4190   virtual {\cf18 double} dataMainValue({\cf18 int} index) const Q_DECL_OVERRIDE;\par
4191   virtual QCPRange dataValueRange({\cf18 int} index) const Q_DECL_OVERRIDE;\par
4192   virtual QPointF dataPixelPosition({\cf18 int} index) const Q_DECL_OVERRIDE;\par
4193   virtual {\cf18 bool} sortKeyIsMainKey() const Q_DECL_OVERRIDE;\par
4194   virtual QCPDataSelection selectTestRect(const QRectF &rect, {\cf18 bool} onlySelectable) const Q_DECL_OVERRIDE;\par
4195   virtual {\cf18 int} findBegin({\cf18 double} sortKey, {\cf18 bool} expandedRange=true) const Q_DECL_OVERRIDE;\par
4196   virtual {\cf18 int} findEnd({\cf18 double} sortKey, {\cf18 bool} expandedRange=true) const Q_DECL_OVERRIDE;\par
4197   \par
4198   {\cf20 // reimplemented virtual methods:}\par
4199   virtual {\cf18 double} selectTest(const QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf18 nullptr}) const Q_DECL_OVERRIDE;\par
4200   virtual QCPPlottableInterface1D *interface1D() Q_DECL_OVERRIDE \{ {\cf19 return} {\cf17 this}; \}\par
4201   \par
4202 {\cf17 protected}:\par
4203   {\cf20 // property members:}\par
4204   QSharedPointer<QCPDataContainer<DataType> > mDataContainer;\par
4205   \par
4206   {\cf20 // helpers for subclasses:}\par
4207   {\cf18 void} getDataSegments(QList<QCPDataRange> &selectedSegments, QList<QCPDataRange> &unselectedSegments) {\cf17 const};\par
4208   {\cf18 void} drawPolyline(QCPPainter *painter, {\cf17 const} QVector<QPointF> &lineData) {\cf17 const};\par
4209 \par
4210 {\cf17 private}:\par
4211   Q_DISABLE_COPY(QCPAbstractPlottable1D)\par
4212   \par
4213 \};\par
4214 \par
4215 \par
4216 \par
4217 {\cf20 // include implementation in header since it is a class template:}\par
4221 \par
4245 {\cf20 /* start documentation of pure virtual functions */}\par
4246 \par
4356 {\cf20 /* end documentation of pure virtual functions */}\par
4357 \par
4358 \par
4362 \par
4387 {\cf20 /* start documentation of inline functions */}\par
4388 \par
4397 {\cf20 /* end documentation of inline functions */}\par
4398 \par
4403 {\cf17 template} <{\cf17 class} DataType>\par
4404 QCPAbstractPlottable1D<DataType>::QCPAbstractPlottable1D(QCPAxis *keyAxis, QCPAxis *valueAxis) :\par
4405   QCPAbstractPlottable(keyAxis, valueAxis),\par
4406   mDataContainer(new QCPDataContainer<DataType>)\par
4407 \{\par
4408 \}\par
4409 \par
4410 {\cf17 template} <{\cf17 class} DataType>\par
4411 QCPAbstractPlottable1D<DataType>::~QCPAbstractPlottable1D()\par
4412 \{\par
4413 \}\par
4414 \par
4418 {\cf17 template} <{\cf17 class} DataType>\par
4419 {\cf18 int} QCPAbstractPlottable1D<DataType>::dataCount(){\cf17  const}\par
4420 {\cf17 }\{\par
4421   {\cf19 return} mDataContainer->size();\par
4422 \}\par
4423 \par
4427 {\cf17 template} <{\cf17 class} DataType>\par
4428 {\cf18 double} QCPAbstractPlottable1D<DataType>::dataMainKey({\cf18 int} index){\cf17  const}\par
4429 {\cf17 }\{\par
4430   {\cf19 if} (index >= 0 && index < mDataContainer->size())\par
4431   \{\par
4432     {\cf19 return} (mDataContainer->constBegin()+index)->mainKey();\par
4433   \} {\cf19 else}\par
4434   \{\par
4435     qDebug() << Q_FUNC_INFO << {\cf22 "Index out of bounds"} << index;\par
4436     {\cf19 return} 0;\par
4437   \}\par
4438 \}\par
4439 \par
4443 {\cf17 template} <{\cf17 class} DataType>\par
4444 {\cf18 double} QCPAbstractPlottable1D<DataType>::dataSortKey({\cf18 int} index){\cf17  const}\par
4445 {\cf17 }\{\par
4446   {\cf19 if} (index >= 0 && index < mDataContainer->size())\par
4447   \{\par
4448     {\cf19 return} (mDataContainer->constBegin()+index)->sortKey();\par
4449   \} {\cf19 else}\par
4450   \{\par
4451     qDebug() << Q_FUNC_INFO << {\cf22 "Index out of bounds"} << index;\par
4452     {\cf19 return} 0;\par
4453   \}\par
4454 \}\par
4455 \par
4459 {\cf17 template} <{\cf17 class} DataType>\par
4460 {\cf18 double} QCPAbstractPlottable1D<DataType>::dataMainValue({\cf18 int} index){\cf17  const}\par
4461 {\cf17 }\{\par
4462   {\cf19 if} (index >= 0 && index < mDataContainer->size())\par
4463   \{\par
4464     {\cf19 return} (mDataContainer->constBegin()+index)->mainValue();\par
4465   \} {\cf19 else}\par
4466   \{\par
4467     qDebug() << Q_FUNC_INFO << {\cf22 "Index out of bounds"} << index;\par
4468     {\cf19 return} 0;\par
4469   \}\par
4470 \}\par
4471 \par
4475 {\cf17 template} <{\cf17 class} DataType>\par
4476 QCPRange QCPAbstractPlottable1D<DataType>::dataValueRange({\cf18 int} index){\cf17  const}\par
4477 {\cf17 }\{\par
4478   {\cf19 if} (index >= 0 && index < mDataContainer->size())\par
4479   \{\par
4480     {\cf19 return} (mDataContainer->constBegin()+index)->valueRange();\par
4481   \} {\cf19 else}\par
4482   \{\par
4483     qDebug() << Q_FUNC_INFO << {\cf22 "Index out of bounds"} << index;\par
4484     {\cf19 return} QCPRange(0, 0);\par
4485   \}\par
4486 \}\par
4487 \par
4491 {\cf17 template} <{\cf17 class} DataType>\par
4492 QPointF QCPAbstractPlottable1D<DataType>::dataPixelPosition({\cf18 int} index){\cf17  const}\par
4493 {\cf17 }\{\par
4494   {\cf19 if} (index >= 0 && index < mDataContainer->size())\par
4495   \{\par
4496     {\cf17 const} {\cf17 typename} QCPDataContainer<DataType>::const_iterator it = mDataContainer->constBegin()+index;\par
4497     {\cf19 return} coordsToPixels(it->mainKey(), it->mainValue());\par
4498   \} {\cf19 else}\par
4499   \{\par
4500     qDebug() << Q_FUNC_INFO << {\cf22 "Index out of bounds"} << index;\par
4501     {\cf19 return} QPointF();\par
4502   \}\par
4503 \}\par
4504 \par
4508 {\cf17 template} <{\cf17 class} DataType>\par
4509 {\cf18 bool} QCPAbstractPlottable1D<DataType>::sortKeyIsMainKey(){\cf17  const}\par
4510 {\cf17 }\{\par
4511   {\cf19 return} DataType::sortKeyIsMainKey();\par
4512 \}\par
4513 \par
4521 {\cf17 template} <{\cf17 class} DataType>\par
4522 QCPDataSelection QCPAbstractPlottable1D<DataType>::selectTestRect({\cf17 const} QRectF &rect, {\cf18 bool} onlySelectable){\cf17  const}\par
4523 {\cf17 }\{\par
4524   QCPDataSelection result;\par
4525   {\cf19 if} ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())\par
4526     {\cf19 return} result;\par
4527   {\cf19 if} (!mKeyAxis || !mValueAxis)\par
4528     {\cf19 return} result;\par
4529   \par
4530   {\cf20 // convert rect given in pixels to ranges given in plot coordinates:}\par
4531   {\cf18 double} key1, value1, key2, value2;\par
4532   pixelsToCoords(rect.topLeft(), key1, value1);\par
4533   pixelsToCoords(rect.bottomRight(), key2, value2);\par
4534   QCPRange keyRange(key1, key2); {\cf20 // QCPRange normalizes internally so we don't have to care about whether key1 < key2}\par
4535   QCPRange valueRange(value1, value2);\par
4536   {\cf17 typename} QCPDataContainer<DataType>::const_iterator begin = mDataContainer->constBegin();\par
4537   {\cf17 typename} QCPDataContainer<DataType>::const_iterator end = mDataContainer->constEnd();\par
4538   {\cf19 if} (DataType::sortKeyIsMainKey()) {\cf20 // we can assume that data is sorted by main key, so can reduce the searched key interval:}\par
4539   \{\par
4540     begin = mDataContainer->findBegin(keyRange.lower, {\cf17 false});\par
4541     end = mDataContainer->findEnd(keyRange.upper, {\cf17 false});\par
4542   \}\par
4543   {\cf19 if} (begin == end)\par
4544     {\cf19 return} result;\par
4545   \par
4546   {\cf18 int} currentSegmentBegin = -1; {\cf20 // -1 means we're currently not in a segment that's contained in rect}\par
4547   {\cf19 for} ({\cf17 typename} QCPDataContainer<DataType>::const_iterator it=begin; it!=end; ++it)\par
4548   \{\par
4549     {\cf19 if} (currentSegmentBegin == -1)\par
4550     \{\par
4551       {\cf19 if} (valueRange.contains(it->mainValue()) && keyRange.contains(it->mainKey())) {\cf20 // start segment}\par
4552         currentSegmentBegin = int(it-mDataContainer->constBegin());\par
4553     \} {\cf19 else} {\cf19 if} (!valueRange.contains(it->mainValue()) || !keyRange.contains(it->mainKey())) {\cf20 // segment just ended}\par
4554     \{\par
4555       result.addDataRange(QCPDataRange(currentSegmentBegin, {\cf18 int}(it-mDataContainer->constBegin())), {\cf17 false});\par
4556       currentSegmentBegin = -1;\par
4557     \}\par
4558   \}\par
4559   {\cf20 // process potential last segment:}\par
4560   {\cf19 if} (currentSegmentBegin != -1)\par
4561     result.addDataRange(QCPDataRange(currentSegmentBegin, {\cf18 int}(end-mDataContainer->constBegin())), {\cf17 false});\par
4562   \par
4563   result.simplify();\par
4564   {\cf19 return} result;\par
4565 \}\par
4566 \par
4570 {\cf17 template} <{\cf17 class} DataType>\par
4571 {\cf18 int} QCPAbstractPlottable1D<DataType>::findBegin({\cf18 double} sortKey, {\cf18 bool} expandedRange){\cf17  const}\par
4572 {\cf17 }\{\par
4573   {\cf19 return} int(mDataContainer->findBegin(sortKey, expandedRange)-mDataContainer->constBegin());\par
4574 \}\par
4575 \par
4579 {\cf17 template} <{\cf17 class} DataType>\par
4580 {\cf18 int} QCPAbstractPlottable1D<DataType>::findEnd({\cf18 double} sortKey, {\cf18 bool} expandedRange){\cf17  const}\par
4581 {\cf17 }\{\par
4582   {\cf19 return} int(mDataContainer->findEnd(sortKey, expandedRange)-mDataContainer->constBegin());\par
4583 \}\par
4584 \par
4595 {\cf17 template} <{\cf17 class} DataType>\par
4596 {\cf18 double} QCPAbstractPlottable1D<DataType>::selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details){\cf17  const}\par
4597 {\cf17 }\{\par
4598   {\cf19 if} ((onlySelectable && mSelectable == QCP::stNone) || mDataContainer->isEmpty())\par
4599     {\cf19 return} -1;\par
4600   {\cf19 if} (!mKeyAxis || !mValueAxis)\par
4601     {\cf19 return} -1;\par
4602   \par
4603   QCPDataSelection selectionResult;\par
4604   {\cf18 double} minDistSqr = (std::numeric_limits<double>::max)();\par
4605   {\cf18 int} minDistIndex = mDataContainer->size();\par
4606   \par
4607   {\cf17 typename} QCPDataContainer<DataType>::const_iterator begin = mDataContainer->constBegin();\par
4608   {\cf17 typename} QCPDataContainer<DataType>::const_iterator end = mDataContainer->constEnd();\par
4609   {\cf19 if} (DataType::sortKeyIsMainKey()) {\cf20 // we can assume that data is sorted by main key, so can reduce the searched key interval:}\par
4610   \{\par
4611     {\cf20 // determine which key range comes into question, taking selection tolerance around pos into account:}\par
4612     {\cf18 double} posKeyMin, posKeyMax, dummy;\par
4613     pixelsToCoords(pos-QPointF(mParentPlot->selectionTolerance(), mParentPlot->selectionTolerance()), posKeyMin, dummy);\par
4614     pixelsToCoords(pos+QPointF(mParentPlot->selectionTolerance(), mParentPlot->selectionTolerance()), posKeyMax, dummy);\par
4615     {\cf19 if} (posKeyMin > posKeyMax)\par
4616       qSwap(posKeyMin, posKeyMax);\par
4617     begin = mDataContainer->findBegin(posKeyMin, {\cf17 true});\par
4618     end = mDataContainer->findEnd(posKeyMax, {\cf17 true});\par
4619   \}\par
4620   {\cf19 if} (begin == end)\par
4621     {\cf19 return} -1;\par
4622   QCPRange keyRange(mKeyAxis->range());\par
4623   QCPRange valueRange(mValueAxis->range());\par
4624   {\cf19 for} ({\cf17 typename} QCPDataContainer<DataType>::const_iterator it=begin; it!=end; ++it)\par
4625   \{\par
4626     {\cf17 const} {\cf18 double} mainKey = it->mainKey();\par
4627     {\cf17 const} {\cf18 double} mainValue = it->mainValue();\par
4628     {\cf19 if} (keyRange.contains(mainKey) && valueRange.contains(mainValue)) {\cf20 // make sure data point is inside visible range, for speedup in cases where sort key isn't main key and we iterate over all points}\par
4629     \{\par
4630       {\cf17 const} {\cf18 double} currentDistSqr = QCPVector2D(coordsToPixels(mainKey, mainValue)-pos).lengthSquared();\par
4631       {\cf19 if} (currentDistSqr < minDistSqr)\par
4632       \{\par
4633         minDistSqr = currentDistSqr;\par
4634         minDistIndex = int(it-mDataContainer->constBegin());\par
4635       \}\par
4636     \}\par
4637   \}\par
4638   {\cf19 if} (minDistIndex != mDataContainer->size())\par
4639     selectionResult.addDataRange(QCPDataRange(minDistIndex, minDistIndex+1), {\cf17 false});\par
4640   \par
4641   selectionResult.simplify();\par
4642   {\cf19 if} (details)\par
4643     details->setValue(selectionResult);\par
4644   {\cf19 return} qSqrt(minDistSqr);\par
4645 \}\par
4646 \par
4657 {\cf17 template} <{\cf17 class} DataType>\par
4658 {\cf18 void} QCPAbstractPlottable1D<DataType>::getDataSegments(QList<QCPDataRange> &selectedSegments, QList<QCPDataRange> &unselectedSegments){\cf17  const}\par
4659 {\cf17 }\{\par
4660   selectedSegments.clear();\par
4661   unselectedSegments.clear();\par
4662   {\cf19 if} (mSelectable == QCP::stWhole) {\cf20 // stWhole selection type draws the entire plottable with selected style if mSelection isn't empty}\par
4663   \{\par
4664     {\cf19 if} (selected())\par
4665       selectedSegments << QCPDataRange(0, dataCount());\par
4666     {\cf19 else}\par
4667       unselectedSegments << QCPDataRange(0, dataCount());\par
4668   \} {\cf19 else}\par
4669   \{\par
4670     QCPDataSelection sel(selection());\par
4671     sel.simplify();\par
4672     selectedSegments = sel.dataRanges();\par
4673     unselectedSegments = sel.inverse(QCPDataRange(0, dataCount())).dataRanges();\par
4674   \}\par
4675 \}\par
4676 \par
4687 {\cf17 template} <{\cf17 class} DataType>\par
4688 {\cf18 void} QCPAbstractPlottable1D<DataType>::drawPolyline(QCPPainter *painter, {\cf17 const} QVector<QPointF> &lineData){\cf17  const}\par
4689 {\cf17 }\{\par
4690   {\cf20 // if drawing lines in plot (instead of PDF), reduce 1px lines to cosmetic, because at least in}\par
4691   {\cf20 // Qt6 drawing of "1px" width lines is much slower even though it has same appearance apart from}\par
4692   {\cf20 // High-DPI. In High-DPI cases people must set a pen width slightly larger than 1.0 to get}\par
4693   {\cf20 // correct DPI scaling of width, but of course with performance penalty.}\par
4694   {\cf19 if} (!painter->modes().testFlag(QCPPainter::pmVectorized) &&\par
4695       qFuzzyCompare(painter->pen().widthF(), 1.0))\par
4696   \{\par
4697     QPen newPen = painter->pen();\par
4698     newPen.setWidth(0);\par
4699     painter->setPen(newPen);\par
4700   \}\par
4701 \par
4702   {\cf20 // if drawing solid line and not in PDF, use much faster line drawing instead of polyline:}\par
4703   {\cf19 if} (mParentPlot->plottingHints().testFlag(QCP::phFastPolylines) &&\par
4704       painter->pen().style() == Qt::SolidLine &&\par
4705       !painter->modes().testFlag(QCPPainter::pmVectorized) &&\par
4706       !painter->modes().testFlag(QCPPainter::pmNoCaching))\par
4707   \{\par
4708     {\cf18 int} i = 0;\par
4709     {\cf18 bool} lastIsNan = {\cf17 false};\par
4710     {\cf17 const} {\cf18 int} lineDataSize = lineData.size();\par
4711     {\cf19 while} (i < lineDataSize && (qIsNaN(lineData.at(i).y()) || qIsNaN(lineData.at(i).x()))) {\cf20 // make sure first point is not NaN}\par
4712       ++i;\par
4713     ++i; {\cf20 // because drawing works in 1 point retrospect}\par
4714     {\cf19 while} (i < lineDataSize)\par
4715     \{\par
4716       {\cf19 if} (!qIsNaN(lineData.at(i).y()) && !qIsNaN(lineData.at(i).x())) {\cf20 // NaNs create a gap in the line}\par
4717       \{\par
4718         {\cf19 if} (!lastIsNan)\par
4719           painter->drawLine(lineData.at(i-1), lineData.at(i));\par
4720         {\cf19 else}\par
4721           lastIsNan = {\cf17 false};\par
4722       \} {\cf19 else}\par
4723         lastIsNan = {\cf17 true};\par
4724       ++i;\par
4725     \}\par
4726   \} {\cf19 else}\par
4727   \{\par
4728     {\cf18 int} segmentStart = 0;\par
4729     {\cf18 int} i = 0;\par
4730     {\cf17 const} {\cf18 int} lineDataSize = lineData.size();\par
4731     {\cf19 while} (i < lineDataSize)\par
4732     \{\par
4733       {\cf19 if} (qIsNaN(lineData.at(i).y()) || qIsNaN(lineData.at(i).x()) || qIsInf(lineData.at(i).y())) {\cf20 // NaNs create a gap in the line. Also filter Infs which make drawPolyline block}\par
4734       \{\par
4735         painter->drawPolyline(lineData.constData()+segmentStart, i-segmentStart); {\cf20 // i, because we don't want to include the current NaN point}\par
4736         segmentStart = i+1;\par
4737       \}\par
4738       ++i;\par
4739     \}\par
4740     {\cf20 // draw last segment:}\par
4741     painter->drawPolyline(lineData.constData()+segmentStart, lineDataSize-segmentStart);\par
4742   \}\par
4743 \}\par
4744 \par
4745 \par
4746 {\cf20 /* end of 'src/plottable1d.h' */}\par
4747 \par
4748 \par
4749 {\cf20 /* including file 'src/colorgradient.h'    */}\par
4750 {\cf20 /* modified 2022-11-06T12:45:56, size 7262 */}\par
4751 \par
4752 {\cf17 class }QCP_LIB_DECL QCPColorGradient\par
4753 \{\par
4754   Q_GADGET\par
4755 {\cf17 public}:\par
4761   {\cf17 enum} ColorInterpolation \{ ciRGB  \par
4762                             ,ciHSV \par
4763                           \};\par
4764   Q_ENUMS(ColorInterpolation)\par
4765   \par
4766   \par
4771   enum NanHandling \{ nhNone \par
4772                      ,nhLowestColor  \par
4773                      ,nhHighestColor \par
4774                      ,nhTransparent \par
4775                      ,nhNanColor \par
4776                    \};\par
4777   Q_ENUMS(NanHandling)\par
4778   \par
4779   \par
4783   enum GradientPreset \{ gpGrayscale  \par
4784                         ,gpHot       \par
4785                         ,gpCold      \par
4786                         ,gpNight     \par
4787                         ,gpCandy     \par
4788                         ,gpGeography \par
4789                         ,gpIon       \par
4790                         ,gpThermal   \par
4791                         ,gpPolar     \par
4792                         ,gpSpectrum  \par
4793                         ,gpJet       \par
4794                         ,gpHues      \par
4795                       \};\par
4796   Q_ENUMS(GradientPreset)\par
4797   \par
4798   QCPColorGradient();\par
4799   QCPColorGradient(GradientPreset preset);\par
4800   {\cf18 bool} operator==(const QCPColorGradient &other) const;\par
4801   {\cf18 bool} operator!=(const QCPColorGradient &other){\cf17  const }\{ {\cf19 return} !(*{\cf17 this} == other); \}\par
4802   \par
4803   {\cf20 // getters:}\par
4804   {\cf18 int} levelCount(){\cf17  const }\{ {\cf19 return} mLevelCount; \}\par
4805   QMap<double, QColor> colorStops(){\cf17  const }\{ {\cf19 return} mColorStops; \}\par
4806   ColorInterpolation colorInterpolation(){\cf17  const }\{ {\cf19 return} mColorInterpolation; \}\par
4807   NanHandling nanHandling(){\cf17  const }\{ {\cf19 return} mNanHandling; \}\par
4808   QColor nanColor(){\cf17  const }\{ {\cf19 return} mNanColor; \}\par
4809   {\cf18 bool} periodic(){\cf17  const }\{ {\cf19 return} mPeriodic; \}\par
4810   \par
4811   {\cf20 // setters:}\par
4812   {\cf18 void} setLevelCount({\cf18 int} n);\par
4813   {\cf18 void} setColorStops({\cf17 const} QMap<double, QColor> &colorStops);\par
4814   {\cf18 void} setColorStopAt({\cf18 double} position, {\cf17 const} QColor &color);\par
4815   {\cf18 void} setColorInterpolation(ColorInterpolation interpolation);\par
4816   {\cf18 void} setNanHandling(NanHandling handling);\par
4817   {\cf18 void} setNanColor({\cf17 const} QColor &color);\par
4818   {\cf18 void} setPeriodic({\cf18 bool} enabled);\par
4819   \par
4820   {\cf20 // non-property methods:}\par
4821   {\cf18 void} colorize({\cf17 const} {\cf18 double} *data, {\cf17 const} QCPRange &range, QRgb *scanLine, {\cf18 int} n, {\cf18 int} dataIndexFactor=1, {\cf18 bool} logarithmic={\cf17 false});\par
4822   {\cf18 void} colorize({\cf17 const} {\cf18 double} *data, {\cf17 const} {\cf18 unsigned} {\cf18 char} *alpha, {\cf17 const} QCPRange &range, QRgb *scanLine, {\cf18 int} n, {\cf18 int} dataIndexFactor=1, {\cf18 bool} logarithmic={\cf17 false});\par
4823   QRgb color({\cf18 double} position, {\cf17 const} QCPRange &range, {\cf18 bool} logarithmic={\cf17 false});\par
4824   {\cf18 void} loadPreset(GradientPreset preset);\par
4825   {\cf18 void} clearColorStops();\par
4826   QCPColorGradient inverted() {\cf17 const};\par
4827   \par
4828 {\cf17 protected}:\par
4829   {\cf20 // property members:}\par
4830   {\cf18 int} mLevelCount;\par
4831   QMap<double, QColor> mColorStops;\par
4832   ColorInterpolation mColorInterpolation;\par
4833   NanHandling mNanHandling;\par
4834   QColor mNanColor;\par
4835   {\cf18 bool} mPeriodic;\par
4836   \par
4837   {\cf20 // non-property members:}\par
4838   QVector<QRgb> mColorBuffer; {\cf20 // have colors premultiplied with alpha (for usage with QImage::Format_ARGB32_Premultiplied)}\par
4839   {\cf18 bool} mColorBufferInvalidated;\par
4840   \par
4841   {\cf20 // non-virtual methods:}\par
4842   {\cf18 bool} stopsUseAlpha() {\cf17 const};\par
4843   {\cf18 void} updateColorBuffer();\par
4844 \};\par
4845 Q_DECLARE_METATYPE(QCPColorGradient::ColorInterpolation)\par
4846 Q_DECLARE_METATYPE(QCPColorGradient::NanHandling)\par
4847 Q_DECLARE_METATYPE(QCPColorGradient::GradientPreset)\par
4848 \par
4849 {\cf20 /* end of 'src/colorgradient.h' */}\par
4850 \par
4851 \par
4852 {\cf20 /* including file 'src/selectiondecorator-bracket.h' */}\par
4853 {\cf20 /* modified 2022-11-06T12:45:56, size 4458           */}\par
4854 \par
4855 class QCP_LIB_DECL QCPSelectionDecoratorBracket : public QCPSelectionDecorator\par
4856 \{\par
4857   Q_GADGET\par
4858 {\cf17 public}:\par
4859   \par
4866   {\cf17 enum} BracketStyle \{ bsSquareBracket \par
4867                       ,bsHalfEllipse   \par
4868                       ,bsEllipse       \par
4869                       ,bsPlus         \par
4870                       ,bsUserStyle    \par
4871   \};\par
4872   Q_ENUMS(BracketStyle)\par
4873   \par
4874   QCPSelectionDecoratorBracket();\par
4875   virtual ~QCPSelectionDecoratorBracket() Q_DECL_OVERRIDE;\par
4876   \par
4877   {\cf20 // getters:}\par
4878   QPen bracketPen(){\cf17  const }\{ {\cf19 return} mBracketPen; \}\par
4879   QBrush bracketBrush(){\cf17  const }\{ {\cf19 return} mBracketBrush; \}\par
4880   {\cf18 int} bracketWidth(){\cf17  const }\{ {\cf19 return} mBracketWidth; \}\par
4881   {\cf18 int} bracketHeight(){\cf17  const }\{ {\cf19 return} mBracketHeight; \}\par
4882   BracketStyle bracketStyle(){\cf17  const }\{ {\cf19 return} mBracketStyle; \}\par
4883   {\cf18 bool} tangentToData(){\cf17  const }\{ {\cf19 return} mTangentToData; \}\par
4884   {\cf18 int} tangentAverage(){\cf17  const }\{ {\cf19 return} mTangentAverage; \}\par
4885   \par
4886   {\cf20 // setters:}\par
4887   {\cf18 void} setBracketPen({\cf17 const} QPen &pen);\par
4888   {\cf18 void} setBracketBrush({\cf17 const} QBrush &brush);\par
4889   {\cf18 void} setBracketWidth({\cf18 int} width);\par
4890   {\cf18 void} setBracketHeight({\cf18 int} height);\par
4891   {\cf18 void} setBracketStyle(BracketStyle style);\par
4892   {\cf18 void} setTangentToData({\cf18 bool} enabled);\par
4893   {\cf18 void} setTangentAverage({\cf18 int} pointCount);\par
4894   \par
4895   {\cf20 // introduced virtual methods:}\par
4896   {\cf17 virtual} {\cf18 void} drawBracket(QCPPainter *painter, {\cf18 int} direction) {\cf17 const};\par
4897   \par
4898   {\cf20 // virtual methods:}\par
4899   {\cf17 virtual} {\cf18 void} drawDecoration(QCPPainter *painter, QCPDataSelection selection) Q_DECL_OVERRIDE;\par
4900   \par
4901 {\cf17 protected}:\par
4902   {\cf20 // property members:}\par
4903   QPen mBracketPen;\par
4904   QBrush mBracketBrush;\par
4905   {\cf18 int} mBracketWidth;\par
4906   {\cf18 int} mBracketHeight;\par
4907   BracketStyle mBracketStyle;\par
4908   {\cf18 bool} mTangentToData;\par
4909   {\cf18 int} mTangentAverage;\par
4910   \par
4911   {\cf20 // non-virtual methods:}\par
4912   {\cf18 double} getTangentAngle({\cf17 const} QCPPlottableInterface1D *interface1d, {\cf18 int} dataIndex, {\cf18 int} direction) {\cf17 const};\par
4913   QPointF getPixelCoordinates({\cf17 const} QCPPlottableInterface1D *interface1d, {\cf18 int} dataIndex) {\cf17 const};\par
4914   \par
4915 \};\par
4916 Q_DECLARE_METATYPE(QCPSelectionDecoratorBracket::BracketStyle)\par
4917 \par
4918 {\cf20 /* end of 'src/selectiondecorator-bracket.h' */}\par
4919 \par
4920 \par
4921 {\cf20 /* including file 'src/layoutelements/layoutelement-axisrect.h' */}\par
4922 {\cf20 /* modified 2022-11-06T12:45:56, size 7529                      */}\par
4923 \par
4924 class QCP_LIB_DECL QCPAxisRect : public QCPLayoutElement\par
4925 \{\par
4926   Q_OBJECT\par
4928   Q_PROPERTY(QPixmap background READ background WRITE setBackground)\par
4929   Q_PROPERTY({\cf18 bool} backgroundScaled READ backgroundScaled WRITE setBackgroundScaled)\par
4930   Q_PROPERTY(Qt::AspectRatioMode backgroundScaledMode READ backgroundScaledMode WRITE setBackgroundScaledMode)\par
4931   Q_PROPERTY(Qt::Orientations rangeDrag READ rangeDrag WRITE setRangeDrag)\par
4932   Q_PROPERTY(Qt::Orientations rangeZoom READ rangeZoom WRITE setRangeZoom)\par
4934 {\cf17 public}:\par
4935   {\cf17 explicit} QCPAxisRect(QCustomPlot *parentPlot, {\cf18 bool} setupDefaultAxes={\cf17 true});\par
4936   {\cf17 virtual} ~QCPAxisRect() Q_DECL_OVERRIDE;\par
4937   \par
4938   {\cf20 // getters:}\par
4939   QPixmap background(){\cf17  const }\{ {\cf19 return} mBackgroundPixmap; \}\par
4940   QBrush backgroundBrush(){\cf17  const }\{ {\cf19 return} mBackgroundBrush; \}\par
4941   {\cf18 bool} backgroundScaled(){\cf17  const }\{ {\cf19 return} mBackgroundScaled; \}\par
4942   Qt::AspectRatioMode backgroundScaledMode(){\cf17  const }\{ {\cf19 return} mBackgroundScaledMode; \}\par
4943   Qt::Orientations rangeDrag(){\cf17  const }\{ {\cf19 return} mRangeDrag; \}\par
4944   Qt::Orientations rangeZoom(){\cf17  const }\{ {\cf19 return} mRangeZoom; \}\par
4945   QCPAxis *rangeDragAxis(Qt::Orientation orientation);\par
4946   QCPAxis *rangeZoomAxis(Qt::Orientation orientation);\par
4947   QList<QCPAxis*> rangeDragAxes(Qt::Orientation orientation);\par
4948   QList<QCPAxis*> rangeZoomAxes(Qt::Orientation orientation);\par
4949   {\cf18 double} rangeZoomFactor(Qt::Orientation orientation);\par
4950   \par
4951   {\cf20 // setters:}\par
4952   {\cf18 void} setBackground({\cf17 const} QPixmap &pm);\par
4953   {\cf18 void} setBackground({\cf17 const} QPixmap &pm, {\cf18 bool} scaled, Qt::AspectRatioMode mode=Qt::KeepAspectRatioByExpanding);\par
4954   {\cf18 void} setBackground({\cf17 const} QBrush &brush);\par
4955   {\cf18 void} setBackgroundScaled({\cf18 bool} scaled);\par
4956   {\cf18 void} setBackgroundScaledMode(Qt::AspectRatioMode mode);\par
4957   {\cf18 void} setRangeDrag(Qt::Orientations orientations);\par
4958   {\cf18 void} setRangeZoom(Qt::Orientations orientations);\par
4959   {\cf18 void} setRangeDragAxes(QCPAxis *horizontal, QCPAxis *vertical);\par
4960   {\cf18 void} setRangeDragAxes(QList<QCPAxis*> axes);\par
4961   {\cf18 void} setRangeDragAxes(QList<QCPAxis*> horizontal, QList<QCPAxis*> vertical);\par
4962   {\cf18 void} setRangeZoomAxes(QCPAxis *horizontal, QCPAxis *vertical);\par
4963   {\cf18 void} setRangeZoomAxes(QList<QCPAxis*> axes);\par
4964   {\cf18 void} setRangeZoomAxes(QList<QCPAxis*> horizontal, QList<QCPAxis*> vertical);\par
4965   {\cf18 void} setRangeZoomFactor({\cf18 double} horizontalFactor, {\cf18 double} verticalFactor);\par
4966   {\cf18 void} setRangeZoomFactor({\cf18 double} factor);\par
4967   \par
4968   {\cf20 // non-property methods:}\par
4969   {\cf18 int} axisCount(QCPAxis::AxisType type) {\cf17 const};\par
4970   QCPAxis *axis(QCPAxis::AxisType type, {\cf18 int} index=0) {\cf17 const};\par
4971   QList<QCPAxis*> axes(QCPAxis::AxisTypes types) {\cf17 const};\par
4972   QList<QCPAxis*> axes() {\cf17 const};\par
4973   QCPAxis *addAxis(QCPAxis::AxisType type, QCPAxis *axis={\cf17 nullptr});\par
4974   QList<QCPAxis*> addAxes(QCPAxis::AxisTypes types);\par
4975   {\cf18 bool} removeAxis(QCPAxis *axis);\par
4976   QCPLayoutInset *insetLayout(){\cf17  const }\{ {\cf19 return} mInsetLayout; \}\par
4977   \par
4978   {\cf18 void} zoom({\cf17 const} QRectF &pixelRect);\par
4979   {\cf18 void} zoom({\cf17 const} QRectF &pixelRect, {\cf17 const} QList<QCPAxis*> &affectedAxes);\par
4980   {\cf18 void} setupFullAxesBox({\cf18 bool} connectRanges={\cf17 false});\par
4981   QList<QCPAbstractPlottable*> plottables() {\cf17 const};\par
4982   QList<QCPGraph*> graphs() {\cf17 const};\par
4983   QList<QCPAbstractItem*> items() {\cf17 const};\par
4984   \par
4985   {\cf20 // read-only interface imitating a QRect:}\par
4986   {\cf18 int} left(){\cf17  const }\{ {\cf19 return} mRect.left(); \}\par
4987   {\cf18 int} right(){\cf17  const }\{ {\cf19 return} mRect.right(); \}\par
4988   {\cf18 int} top(){\cf17  const }\{ {\cf19 return} mRect.top(); \}\par
4989   {\cf18 int} bottom(){\cf17  const }\{ {\cf19 return} mRect.bottom(); \}\par
4990   {\cf18 int} width(){\cf17  const }\{ {\cf19 return} mRect.width(); \}\par
4991   {\cf18 int} height(){\cf17  const }\{ {\cf19 return} mRect.height(); \}\par
4992   QSize size(){\cf17  const }\{ {\cf19 return} mRect.size(); \}\par
4993   QPoint topLeft(){\cf17  const }\{ {\cf19 return} mRect.topLeft(); \}\par
4994   QPoint topRight(){\cf17  const }\{ {\cf19 return} mRect.topRight(); \}\par
4995   QPoint bottomLeft(){\cf17  const }\{ {\cf19 return} mRect.bottomLeft(); \}\par
4996   QPoint bottomRight(){\cf17  const }\{ {\cf19 return} mRect.bottomRight(); \}\par
4997   QPoint center(){\cf17  const }\{ {\cf19 return} mRect.center(); \}\par
4998   \par
4999   {\cf20 // reimplemented virtual methods:}\par
5000   {\cf17 virtual} {\cf18 void} update(UpdatePhase phase) Q_DECL_OVERRIDE;\par
5001   {\cf17 virtual} QList<QCPLayoutElement*> elements({\cf18 bool} recursive) {\cf17 const} Q_DECL_OVERRIDE;\par
5002 \par
5003 {\cf17 protected}:\par
5004   {\cf20 // property members:}\par
5005   QBrush mBackgroundBrush;\par
5006   QPixmap mBackgroundPixmap;\par
5007   QPixmap mScaledBackgroundPixmap;\par
5008   {\cf18 bool} mBackgroundScaled;\par
5009   Qt::AspectRatioMode mBackgroundScaledMode;\par
5010   QCPLayoutInset *mInsetLayout;\par
5011   Qt::Orientations mRangeDrag, mRangeZoom;\par
5012   QList<QPointer<QCPAxis> > mRangeDragHorzAxis, mRangeDragVertAxis;\par
5013   QList<QPointer<QCPAxis> > mRangeZoomHorzAxis, mRangeZoomVertAxis;\par
5014   {\cf18 double} mRangeZoomFactorHorz, mRangeZoomFactorVert;\par
5015   \par
5016   {\cf20 // non-property members:}\par
5017   QList<QCPRange> mDragStartHorzRange, mDragStartVertRange;\par
5018   QCP::AntialiasedElements mAADragBackup, mNotAADragBackup;\par
5019   {\cf18 bool} mDragging;\par
5020   QHash<QCPAxis::AxisType, QList<QCPAxis*> > mAxes;\par
5021   \par
5022   {\cf20 // reimplemented virtual methods:}\par
5023   {\cf17 virtual} {\cf18 void} applyDefaultAntialiasingHint(QCPPainter *painter) {\cf17 const} Q_DECL_OVERRIDE;\par
5024   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
5025   {\cf17 virtual} {\cf18 int} calculateAutoMargin(QCP::MarginSide side) Q_DECL_OVERRIDE;\par
5026   {\cf17 virtual} {\cf18 void} layoutChanged() Q_DECL_OVERRIDE;\par
5027   {\cf20 // events:}\par
5028   virtual {\cf18 void} mousePressEvent(QMouseEvent *event, const QVariant &details) Q_DECL_OVERRIDE;\par
5029   virtual {\cf18 void} mouseMoveEvent(QMouseEvent *event, const QPointF &startPos) Q_DECL_OVERRIDE;\par
5030   virtual {\cf18 void} mouseReleaseEvent(QMouseEvent *event, const QPointF &startPos) Q_DECL_OVERRIDE;\par
5031   virtual {\cf18 void} wheelEvent(QWheelEvent *event) Q_DECL_OVERRIDE;\par
5032   \par
5033   {\cf20 // non-property methods:}\par
5034   {\cf18 void} drawBackground(QCPPainter *painter);\par
5035   {\cf18 void} updateAxesOffset(QCPAxis::AxisType type);\par
5036   \par
5037 private:\par
5038   Q_DISABLE_COPY(QCPAxisRect)\par
5039   \par
5040   friend class QCustomPlot;\par
5041 \};\par
5042 \par
5043 \par
5044 {\cf20 /* end of 'src/layoutelements/layoutelement-axisrect.h' */}\par
5045 \par
5046 \par
5047 {\cf20 /* including file 'src/layoutelements/layoutelement-legend.h' */}\par
5048 {\cf20 /* modified 2022-11-06T12:45:56, size 10425                   */}\par
5049 \par
5050 class QCP_LIB_DECL QCPAbstractLegendItem : public QCPLayoutElement\par
5051 \{\par
5052   Q_OBJECT\par
5054   Q_PROPERTY(QCPLegend* parentLegend READ parentLegend)\par
5055   Q_PROPERTY(QFont font READ font WRITE setFont)\par
5056   Q_PROPERTY(QColor textColor READ textColor WRITE setTextColor)\par
5057   Q_PROPERTY(QFont selectedFont READ selectedFont WRITE setSelectedFont)\par
5058   Q_PROPERTY(QColor selectedTextColor READ selectedTextColor WRITE setSelectedTextColor)\par
5059   Q_PROPERTY({\cf18 bool} selectable READ selectable WRITE setSelectable NOTIFY selectionChanged)\par
5060   Q_PROPERTY({\cf18 bool} selected READ selected WRITE setSelected NOTIFY selectableChanged)\par
5062 {\cf17 public}:\par
5063   {\cf17 explicit} QCPAbstractLegendItem(QCPLegend *parent);\par
5064   \par
5065   {\cf20 // getters:}\par
5066   QCPLegend *parentLegend(){\cf17  const }\{ {\cf19 return} mParentLegend; \}\par
5067   QFont font(){\cf17  const }\{ {\cf19 return} mFont; \}\par
5068   QColor textColor(){\cf17  const }\{ {\cf19 return} mTextColor; \}\par
5069   QFont selectedFont(){\cf17  const }\{ {\cf19 return} mSelectedFont; \}\par
5070   QColor selectedTextColor(){\cf17  const }\{ {\cf19 return} mSelectedTextColor; \}\par
5071   {\cf18 bool} selectable(){\cf17  const }\{ {\cf19 return} mSelectable; \}\par
5072   {\cf18 bool} selected(){\cf17  const }\{ {\cf19 return} mSelected; \}\par
5073   \par
5074   {\cf20 // setters:}\par
5075   {\cf18 void} setFont({\cf17 const} QFont &font);\par
5076   {\cf18 void} setTextColor({\cf17 const} QColor &color);\par
5077   {\cf18 void} setSelectedFont({\cf17 const} QFont &font);\par
5078   {\cf18 void} setSelectedTextColor({\cf17 const} QColor &color);\par
5079   Q_SLOT {\cf18 void} setSelectable({\cf18 bool} selectable);\par
5080   Q_SLOT {\cf18 void} setSelected({\cf18 bool} selected);\par
5081   \par
5082   {\cf20 // reimplemented virtual methods:}\par
5083   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
5084   \par
5085 signals:\par
5086   {\cf18 void} selectionChanged({\cf18 bool} selected);\par
5087   {\cf18 void} selectableChanged({\cf18 bool} selectable);\par
5088   \par
5089 protected:\par
5090   {\cf20 // property members:}\par
5091   QCPLegend *mParentLegend;\par
5092   QFont mFont;\par
5093   QColor mTextColor;\par
5094   QFont mSelectedFont;\par
5095   QColor mSelectedTextColor;\par
5096   {\cf18 bool} mSelectable, mSelected;\par
5097   \par
5098   {\cf20 // reimplemented virtual methods:}\par
5099   virtual QCP::Interaction selectionCategory() const Q_DECL_OVERRIDE;\par
5100   virtual {\cf18 void} applyDefaultAntialiasingHint(QCPPainter *painter) const Q_DECL_OVERRIDE;\par
5101   virtual QRect clipRect() const Q_DECL_OVERRIDE;\par
5102   virtual {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE = 0;\par
5103   {\cf20 // events:}\par
5104   virtual {\cf18 void} selectEvent(QMouseEvent *event, {\cf18 bool} additive, const QVariant &details, {\cf18 bool} *selectionStateChanged) Q_DECL_OVERRIDE;\par
5105   virtual {\cf18 void} deselectEvent({\cf18 bool} *selectionStateChanged) Q_DECL_OVERRIDE;\par
5106   \par
5107 private:\par
5108   Q_DISABLE_COPY(QCPAbstractLegendItem)\par
5109   \par
5110   friend class QCPLegend;\par
5111 \};\par
5112 \par
5113 \par
5114 class QCP_LIB_DECL QCPPlottableLegendItem : public QCPAbstractLegendItem\par
5115 \{\par
5116   Q_OBJECT\par
5117 {\cf17 public}:\par
5118   QCPPlottableLegendItem(QCPLegend *parent, QCPAbstractPlottable *plottable);\par
5119   \par
5120   {\cf20 // getters:}\par
5121   QCPAbstractPlottable *plottable() \{ {\cf19 return} mPlottable; \}\par
5122   \par
5123 {\cf17 protected}:\par
5124   {\cf20 // property members:}\par
5125   QCPAbstractPlottable *mPlottable;\par
5126   \par
5127   {\cf20 // reimplemented virtual methods:}\par
5128   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
5129   {\cf17 virtual} QSize minimumOuterSizeHint() const Q_DECL_OVERRIDE;\par
5130   \par
5131   {\cf20 // non-virtual methods:}\par
5132   QPen getIconBorderPen() const;\par
5133   QColor getTextColor() const;\par
5134   QFont getFont() const;\par
5135 \};\par
5136 \par
5137 \par
5138 class QCP_LIB_DECL QCPLegend : public QCPLayoutGrid\par
5139 \{\par
5140   Q_OBJECT\par
5142   Q_PROPERTY(QPen borderPen READ borderPen WRITE setBorderPen)\par
5143   Q_PROPERTY(QBrush brush READ brush WRITE setBrush)\par
5144   Q_PROPERTY(QFont font READ font WRITE setFont)\par
5145   Q_PROPERTY(QColor textColor READ textColor WRITE setTextColor)\par
5146   Q_PROPERTY(QSize iconSize READ iconSize WRITE setIconSize)\par
5147   Q_PROPERTY({\cf18 int} iconTextPadding READ iconTextPadding WRITE setIconTextPadding)\par
5148   Q_PROPERTY(QPen iconBorderPen READ iconBorderPen WRITE setIconBorderPen)\par
5149   Q_PROPERTY(SelectableParts selectableParts READ selectableParts WRITE setSelectableParts NOTIFY selectionChanged)\par
5150   Q_PROPERTY(SelectableParts selectedParts READ selectedParts WRITE setSelectedParts NOTIFY selectableChanged)\par
5151   Q_PROPERTY(QPen selectedBorderPen READ selectedBorderPen WRITE setSelectedBorderPen)\par
5152   Q_PROPERTY(QPen selectedIconBorderPen READ selectedIconBorderPen WRITE setSelectedIconBorderPen)\par
5153   Q_PROPERTY(QBrush selectedBrush READ selectedBrush WRITE setSelectedBrush)\par
5154   Q_PROPERTY(QFont selectedFont READ selectedFont WRITE setSelectedFont)\par
5155   Q_PROPERTY(QColor selectedTextColor READ selectedTextColor WRITE setSelectedTextColor)\par
5157 {\cf17 public}:\par
5163   {\cf17 enum} SelectablePart \{ spNone        = 0x000 \par
5164                         ,spLegendBox  = 0x001 \par
5165                         ,spItems      = 0x002 \par
5166                       \};\par
5167   Q_ENUMS(SelectablePart)\par
5168   Q_FLAGS(SelectableParts)\par
5169   Q_DECLARE_FLAGS(SelectableParts, SelectablePart)\par
5170   \par
5171   explicit QCPLegend();\par
5172   virtual ~QCPLegend() Q_DECL_OVERRIDE;\par
5173   \par
5174   {\cf20 // getters:}\par
5175   QPen borderPen(){\cf17  const }\{ {\cf19 return} mBorderPen; \}\par
5176   QBrush brush(){\cf17  const }\{ {\cf19 return} mBrush; \}\par
5177   QFont font(){\cf17  const }\{ {\cf19 return} mFont; \}\par
5178   QColor textColor(){\cf17  const }\{ {\cf19 return} mTextColor; \}\par
5179   QSize iconSize(){\cf17  const }\{ {\cf19 return} mIconSize; \}\par
5180   {\cf18 int} iconTextPadding(){\cf17  const }\{ {\cf19 return} mIconTextPadding; \}\par
5181   QPen iconBorderPen(){\cf17  const }\{ {\cf19 return} mIconBorderPen; \}\par
5182   SelectableParts selectableParts(){\cf17  const }\{ {\cf19 return} mSelectableParts; \}\par
5183   SelectableParts selectedParts() {\cf17 const};\par
5184   QPen selectedBorderPen(){\cf17  const }\{ {\cf19 return} mSelectedBorderPen; \}\par
5185   QPen selectedIconBorderPen(){\cf17  const }\{ {\cf19 return} mSelectedIconBorderPen; \}\par
5186   QBrush selectedBrush(){\cf17  const }\{ {\cf19 return} mSelectedBrush; \}\par
5187   QFont selectedFont(){\cf17  const }\{ {\cf19 return} mSelectedFont; \}\par
5188   QColor selectedTextColor(){\cf17  const }\{ {\cf19 return} mSelectedTextColor; \}\par
5189   \par
5190   {\cf20 // setters:}\par
5191   {\cf18 void} setBorderPen({\cf17 const} QPen &pen);\par
5192   {\cf18 void} setBrush({\cf17 const} QBrush &brush);\par
5193   {\cf18 void} setFont({\cf17 const} QFont &font);\par
5194   {\cf18 void} setTextColor({\cf17 const} QColor &color);\par
5195   {\cf18 void} setIconSize({\cf17 const} QSize &size);\par
5196   {\cf18 void} setIconSize({\cf18 int} width, {\cf18 int} height);\par
5197   {\cf18 void} setIconTextPadding({\cf18 int} padding);\par
5198   {\cf18 void} setIconBorderPen({\cf17 const} QPen &pen);\par
5199   Q_SLOT {\cf18 void} setSelectableParts({\cf17 const} SelectableParts &selectableParts);\par
5200   Q_SLOT {\cf18 void} setSelectedParts({\cf17 const} SelectableParts &selectedParts);\par
5201   {\cf18 void} setSelectedBorderPen({\cf17 const} QPen &pen);\par
5202   {\cf18 void} setSelectedIconBorderPen({\cf17 const} QPen &pen);\par
5203   {\cf18 void} setSelectedBrush({\cf17 const} QBrush &brush);\par
5204   {\cf18 void} setSelectedFont({\cf17 const} QFont &font);\par
5205   {\cf18 void} setSelectedTextColor({\cf17 const} QColor &color);\par
5206   \par
5207   {\cf20 // reimplemented virtual methods:}\par
5208   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
5209   \par
5210   {\cf20 // non-virtual methods:}\par
5211   QCPAbstractLegendItem *item({\cf18 int} index) const;\par
5212   QCPPlottableLegendItem *itemWithPlottable(const QCPAbstractPlottable *plottable) const;\par
5213   {\cf18 int} itemCount() const;\par
5214   {\cf18 bool} hasItem(QCPAbstractLegendItem *item) const;\par
5215   {\cf18 bool} hasItemWithPlottable(const QCPAbstractPlottable *plottable) const;\par
5216   {\cf18 bool} addItem(QCPAbstractLegendItem *item);\par
5217   {\cf18 bool} removeItem({\cf18 int} index);\par
5218   {\cf18 bool} removeItem(QCPAbstractLegendItem *item);\par
5219   {\cf18 void} clearItems();\par
5220   QList<QCPAbstractLegendItem*> selectedItems() const;\par
5221   \par
5222 signals:\par
5223   {\cf18 void} selectionChanged(QCPLegend::SelectableParts parts);\par
5224   {\cf18 void} selectableChanged(QCPLegend::SelectableParts parts);\par
5225   \par
5226 protected:\par
5227   {\cf20 // property members:}\par
5228   QPen mBorderPen, mIconBorderPen;\par
5229   QBrush mBrush;\par
5230   QFont mFont;\par
5231   QColor mTextColor;\par
5232   QSize mIconSize;\par
5233   {\cf18 int} mIconTextPadding;\par
5234   SelectableParts mSelectedParts, mSelectableParts;\par
5235   QPen mSelectedBorderPen, mSelectedIconBorderPen;\par
5236   QBrush mSelectedBrush;\par
5237   QFont mSelectedFont;\par
5238   QColor mSelectedTextColor;\par
5239   \par
5240   {\cf20 // reimplemented virtual methods:}\par
5241   virtual {\cf18 void} parentPlotInitialized(QCustomPlot *parentPlot) Q_DECL_OVERRIDE;\par
5242   virtual QCP::Interaction selectionCategory() const Q_DECL_OVERRIDE;\par
5243   virtual {\cf18 void} applyDefaultAntialiasingHint(QCPPainter *painter) const Q_DECL_OVERRIDE;\par
5244   virtual {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
5245   {\cf20 // events:}\par
5246   virtual {\cf18 void} selectEvent(QMouseEvent *event, {\cf18 bool} additive, const QVariant &details, {\cf18 bool} *selectionStateChanged) Q_DECL_OVERRIDE;\par
5247   virtual {\cf18 void} deselectEvent({\cf18 bool} *selectionStateChanged) Q_DECL_OVERRIDE;\par
5248   \par
5249   {\cf20 // non-virtual methods:}\par
5250   QPen getBorderPen() const;\par
5251   QBrush getBrush() const;\par
5252   \par
5253 private:\par
5254   Q_DISABLE_COPY(QCPLegend)\par
5255   \par
5256   friend class QCustomPlot;\par
5257   friend class QCPAbstractLegendItem;\par
5258 \};\par
5259 Q_DECLARE_OPERATORS_FOR_FLAGS(QCPLegend::SelectableParts)\par
5260 Q_DECLARE_METATYPE(QCPLegend::SelectablePart)\par
5261 \par
5262 {\cf20 /* end of 'src/layoutelements/layoutelement-legend.h' */}\par
5263 \par
5264 \par
5265 {\cf20 /* including file 'src/layoutelements/layoutelement-textelement.h' */}\par
5266 {\cf20 /* modified 2022-11-06T12:45:56, size 5359                         */}\par
5267 \par
5268 class QCP_LIB_DECL QCPTextElement : public QCPLayoutElement\par
5269 \{\par
5270   Q_OBJECT\par
5272   Q_PROPERTY(QString text READ text WRITE setText)\par
5273   Q_PROPERTY(QFont font READ font WRITE setFont)\par
5274   Q_PROPERTY(QColor textColor READ textColor WRITE setTextColor)\par
5275   Q_PROPERTY(QFont selectedFont READ selectedFont WRITE setSelectedFont)\par
5276   Q_PROPERTY(QColor selectedTextColor READ selectedTextColor WRITE setSelectedTextColor)\par
5277   Q_PROPERTY({\cf18 bool} selectable READ selectable WRITE setSelectable NOTIFY selectableChanged)\par
5278   Q_PROPERTY({\cf18 bool} selected READ selected WRITE setSelected NOTIFY selectionChanged)\par
5280 {\cf17 public}:\par
5281   {\cf17 explicit} QCPTextElement(QCustomPlot *parentPlot);\par
5282   QCPTextElement(QCustomPlot *parentPlot, {\cf17 const} QString &text);\par
5283   QCPTextElement(QCustomPlot *parentPlot, {\cf17 const} QString &text, {\cf18 double} pointSize);\par
5284   QCPTextElement(QCustomPlot *parentPlot, {\cf17 const} QString &text, {\cf17 const} QString &fontFamily, {\cf18 double} pointSize);\par
5285   QCPTextElement(QCustomPlot *parentPlot, {\cf17 const} QString &text, {\cf17 const} QFont &font);\par
5286   \par
5287   {\cf20 // getters:}\par
5288   QString text(){\cf17  const }\{ {\cf19 return} mText; \}\par
5289   {\cf18 int} textFlags(){\cf17  const }\{ {\cf19 return} mTextFlags; \}\par
5290   QFont font(){\cf17  const }\{ {\cf19 return} mFont; \}\par
5291   QColor textColor(){\cf17  const }\{ {\cf19 return} mTextColor; \}\par
5292   QFont selectedFont(){\cf17  const }\{ {\cf19 return} mSelectedFont; \}\par
5293   QColor selectedTextColor(){\cf17  const }\{ {\cf19 return} mSelectedTextColor; \}\par
5294   {\cf18 bool} selectable(){\cf17  const }\{ {\cf19 return} mSelectable; \}\par
5295   {\cf18 bool} selected(){\cf17  const }\{ {\cf19 return} mSelected; \}\par
5296   \par
5297   {\cf20 // setters:}\par
5298   {\cf18 void} setText({\cf17 const} QString &text);\par
5299   {\cf18 void} setTextFlags({\cf18 int} flags);\par
5300   {\cf18 void} setFont({\cf17 const} QFont &font);\par
5301   {\cf18 void} setTextColor({\cf17 const} QColor &color);\par
5302   {\cf18 void} setSelectedFont({\cf17 const} QFont &font);\par
5303   {\cf18 void} setSelectedTextColor({\cf17 const} QColor &color);\par
5304   Q_SLOT {\cf18 void} setSelectable({\cf18 bool} selectable);\par
5305   Q_SLOT {\cf18 void} setSelected({\cf18 bool} selected);\par
5306   \par
5307   {\cf20 // reimplemented virtual methods:}\par
5308   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
5309   virtual {\cf18 void} mousePressEvent(QMouseEvent *event, const QVariant &details) Q_DECL_OVERRIDE;\par
5310   virtual {\cf18 void} mouseReleaseEvent(QMouseEvent *event, const QPointF &startPos) Q_DECL_OVERRIDE;\par
5311   virtual {\cf18 void} mouseDoubleClickEvent(QMouseEvent *event, const QVariant &details) Q_DECL_OVERRIDE;\par
5312   \par
5313 signals:\par
5314   {\cf18 void} selectionChanged({\cf18 bool} selected);\par
5315   {\cf18 void} selectableChanged({\cf18 bool} selectable);\par
5316   {\cf18 void} clicked(QMouseEvent *event);\par
5317   {\cf18 void} doubleClicked(QMouseEvent *event);\par
5318   \par
5319 protected:\par
5320   {\cf20 // property members:}\par
5321   QString mText;\par
5322   {\cf18 int} mTextFlags;\par
5323   QFont mFont;\par
5324   QColor mTextColor;\par
5325   QFont mSelectedFont;\par
5326   QColor mSelectedTextColor;\par
5327   QRect mTextBoundingRect;\par
5328   {\cf18 bool} mSelectable, mSelected;\par
5329   \par
5330   {\cf20 // reimplemented virtual methods:}\par
5331   virtual {\cf18 void} applyDefaultAntialiasingHint(QCPPainter *painter) const Q_DECL_OVERRIDE;\par
5332   virtual {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
5333   virtual QSize minimumOuterSizeHint() const Q_DECL_OVERRIDE;\par
5334   virtual QSize maximumOuterSizeHint() const Q_DECL_OVERRIDE;\par
5335   {\cf20 // events:}\par
5336   virtual {\cf18 void} selectEvent(QMouseEvent *event, {\cf18 bool} additive, const QVariant &details, {\cf18 bool} *selectionStateChanged) Q_DECL_OVERRIDE;\par
5337   virtual {\cf18 void} deselectEvent({\cf18 bool} *selectionStateChanged) Q_DECL_OVERRIDE;\par
5338   \par
5339   {\cf20 // non-virtual methods:}\par
5340   QFont mainFont() const;\par
5341   QColor mainTextColor() const;\par
5342   \par
5343 private:\par
5344   Q_DISABLE_COPY(QCPTextElement)\par
5345 \};\par
5346 \par
5347 \par
5348 \par
5349 {\cf20 /* end of 'src/layoutelements/layoutelement-textelement.h' */}\par
5350 \par
5351 \par
5352 {\cf20 /* including file 'src/layoutelements/layoutelement-colorscale.h' */}\par
5353 {\cf20 /* modified 2022-11-06T12:45:56, size 5939                        */}\par
5354 \par
5355 \par
5356 class QCPColorScaleAxisRectPrivate : public QCPAxisRect\par
5357 \{\par
5358   Q_OBJECT\par
5359 {\cf17 public}:\par
5360   {\cf17 explicit} QCPColorScaleAxisRectPrivate(QCPColorScale *parentColorScale);\par
5361 {\cf17 protected}:\par
5362   QCPColorScale *mParentColorScale;\par
5363   QImage mGradientImage;\par
5364   {\cf18 bool} mGradientImageInvalidated;\par
5365   {\cf20 // re-using some methods of QCPAxisRect to make them available to friend class QCPColorScale}\par
5366   {\cf17 using }QCPAxisRect::calculateAutoMargin;\par
5367   {\cf17 using }QCPAxisRect::mousePressEvent;\par
5368   {\cf17 using }QCPAxisRect::mouseMoveEvent;\par
5369   {\cf17 using }QCPAxisRect::mouseReleaseEvent;\par
5370   {\cf17 using }QCPAxisRect::wheelEvent;\par
5371   {\cf17 using }QCPAxisRect::update;\par
5372   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
5373   {\cf18 void} updateGradientImage();\par
5374   Q_SLOT {\cf18 void} axisSelectionChanged(QCPAxis::SelectableParts selectedParts);\par
5375   Q_SLOT {\cf18 void} axisSelectableChanged(QCPAxis::SelectableParts selectableParts);\par
5376   {\cf17 friend} {\cf17 class }QCPColorScale;\par
5377 \};\par
5378 \par
5379 \par
5380 {\cf17 class }QCP_LIB_DECL QCPColorScale : {\cf17 public} QCPLayoutElement\par
5381 \{\par
5382   Q_OBJECT\par
5384   Q_PROPERTY(QCPAxis::AxisType type READ type WRITE setType)\par
5385   Q_PROPERTY(QCPRange dataRange READ dataRange WRITE setDataRange NOTIFY dataRangeChanged)\par
5386   Q_PROPERTY(QCPAxis::ScaleType dataScaleType READ dataScaleType WRITE setDataScaleType NOTIFY dataScaleTypeChanged)\par
5387   Q_PROPERTY(QCPColorGradient gradient READ gradient WRITE setGradient NOTIFY gradientChanged)\par
5388   Q_PROPERTY(QString label READ label WRITE setLabel)\par
5389   Q_PROPERTY({\cf18 int} barWidth READ barWidth WRITE setBarWidth)\par
5390   Q_PROPERTY({\cf18 bool} rangeDrag READ rangeDrag WRITE setRangeDrag)\par
5391   Q_PROPERTY({\cf18 bool} rangeZoom READ rangeZoom WRITE setRangeZoom)\par
5393 {\cf17 public}:\par
5394   {\cf17 explicit} QCPColorScale(QCustomPlot *parentPlot);\par
5395   {\cf17 virtual} ~QCPColorScale() Q_DECL_OVERRIDE;\par
5396   \par
5397   {\cf20 // getters:}\par
5398   QCPAxis *axis(){\cf17  const }\{ {\cf19 return} mColorAxis.data(); \}\par
5399   QCPAxis::AxisType type(){\cf17  const }\{ {\cf19 return} mType; \}\par
5400   QCPRange dataRange(){\cf17  const }\{ {\cf19 return} mDataRange; \}\par
5401   QCPAxis::ScaleType dataScaleType(){\cf17  const }\{ {\cf19 return} mDataScaleType; \}\par
5402   QCPColorGradient gradient(){\cf17  const }\{ {\cf19 return} mGradient; \}\par
5403   QString label() {\cf17 const};\par
5404   {\cf18 int} barWidth (){\cf17  const }\{ {\cf19 return} mBarWidth; \}\par
5405   {\cf18 bool} rangeDrag() {\cf17 const};\par
5406   {\cf18 bool} rangeZoom() {\cf17 const};\par
5407   \par
5408   {\cf20 // setters:}\par
5409   {\cf18 void} setType(QCPAxis::AxisType type);\par
5410   Q_SLOT {\cf18 void} setDataRange({\cf17 const} QCPRange &dataRange);\par
5411   Q_SLOT {\cf18 void} setDataScaleType(QCPAxis::ScaleType scaleType);\par
5412   Q_SLOT {\cf18 void} setGradient({\cf17 const} QCPColorGradient &gradient);\par
5413   {\cf18 void} setLabel({\cf17 const} QString &str);\par
5414   {\cf18 void} setBarWidth({\cf18 int} width);\par
5415   {\cf18 void} setRangeDrag({\cf18 bool} enabled);\par
5416   {\cf18 void} setRangeZoom({\cf18 bool} enabled);\par
5417   \par
5418   {\cf20 // non-property methods:}\par
5419   QList<QCPColorMap*> colorMaps() {\cf17 const};\par
5420   {\cf18 void} rescaleDataRange({\cf18 bool} onlyVisibleMaps);\par
5421   \par
5422   {\cf20 // reimplemented virtual methods:}\par
5423   {\cf17 virtual} {\cf18 void} update(UpdatePhase phase) Q_DECL_OVERRIDE;\par
5424   \par
5425 signals:\par
5426   {\cf18 void} dataRangeChanged({\cf17 const} QCPRange &newRange);\par
5427   {\cf18 void} dataScaleTypeChanged(QCPAxis::ScaleType scaleType);\par
5428   {\cf18 void} gradientChanged({\cf17 const} QCPColorGradient &newGradient);\par
5429 \par
5430 {\cf17 protected}:\par
5431   {\cf20 // property members:}\par
5432   QCPAxis::AxisType mType;\par
5433   QCPRange mDataRange;\par
5434   QCPAxis::ScaleType mDataScaleType;\par
5435   QCPColorGradient mGradient;\par
5436   {\cf18 int} mBarWidth;\par
5437   \par
5438   {\cf20 // non-property members:}\par
5439   QPointer<QCPColorScaleAxisRectPrivate> mAxisRect;\par
5440   QPointer<QCPAxis> mColorAxis;\par
5441   \par
5442   {\cf20 // reimplemented virtual methods:}\par
5443   {\cf17 virtual} {\cf18 void} applyDefaultAntialiasingHint(QCPPainter *painter) {\cf17 const} Q_DECL_OVERRIDE;\par
5444   {\cf20 // events:}\par
5445   {\cf17 virtual} {\cf18 void} mousePressEvent(QMouseEvent *event, {\cf17 const} QVariant &details) Q_DECL_OVERRIDE;\par
5446   {\cf17 virtual} {\cf18 void} mouseMoveEvent(QMouseEvent *event, {\cf17 const} QPointF &startPos) Q_DECL_OVERRIDE;\par
5447   {\cf17 virtual} {\cf18 void} mouseReleaseEvent(QMouseEvent *event, {\cf17 const} QPointF &startPos) Q_DECL_OVERRIDE;\par
5448   {\cf17 virtual} {\cf18 void} wheelEvent(QWheelEvent *event) Q_DECL_OVERRIDE;\par
5449   \par
5450 {\cf17 private}:\par
5451   Q_DISABLE_COPY(QCPColorScale)\par
5452   \par
5453   friend class QCPColorScaleAxisRectPrivate;\par
5454 \};\par
5455 \par
5456 \par
5457 {\cf20 /* end of 'src/layoutelements/layoutelement-colorscale.h' */}\par
5458 \par
5459 \par
5460 {\cf20 /* including file 'src/plottables/plottable-graph.h' */}\par
5461 {\cf20 /* modified 2022-11-06T12:45:56, size 9316           */}\par
5462 \par
5463 class QCP_LIB_DECL QCPGraphData\par
5464 \{\par
5465 {\cf17 public}:\par
5466   QCPGraphData();\par
5467   QCPGraphData({\cf18 double} key, {\cf18 double} value);\par
5468   \par
5469   {\cf17 inline} {\cf18 double} sortKey(){\cf17  const }\{ {\cf19 return} key; \}\par
5470   {\cf17 inline} {\cf17 static} QCPGraphData fromSortKey({\cf18 double} sortKey) \{ {\cf19 return} QCPGraphData(sortKey, 0); \}\par
5471   {\cf17 inline} {\cf17 static} {\cf18 bool} sortKeyIsMainKey() \{ {\cf19 return} {\cf17 true}; \}\par
5472   \par
5473   {\cf17 inline} {\cf18 double} mainKey(){\cf17  const }\{ {\cf19 return} key; \}\par
5474   {\cf17 inline} {\cf18 double} mainValue(){\cf17  const }\{ {\cf19 return} value; \}\par
5475   \par
5476   {\cf17 inline} QCPRange valueRange(){\cf17  const }\{ {\cf19 return} QCPRange(value, value); \}\par
5477   \par
5478   {\cf18 double} key, value;\par
5479 \};\par
5480 Q_DECLARE_TYPEINFO(QCPGraphData, Q_PRIMITIVE_TYPE);\par
5481 \par
5482 \par
5492 {\cf17 typedef} QCPDataContainer<QCPGraphData> QCPGraphDataContainer;\par
5493 \par
5494 {\cf17 class }QCP_LIB_DECL QCPGraph : {\cf17 public} QCPAbstractPlottable1D<QCPGraphData>\par
5495 \{\par
5496   Q_OBJECT\par
5498   Q_PROPERTY(LineStyle lineStyle READ lineStyle WRITE setLineStyle)\par
5499   Q_PROPERTY(QCPScatterStyle scatterStyle READ scatterStyle WRITE setScatterStyle)\par
5500   Q_PROPERTY({\cf18 int} scatterSkip READ scatterSkip WRITE setScatterSkip)\par
5501   Q_PROPERTY(QCPGraph* channelFillGraph READ channelFillGraph WRITE setChannelFillGraph)\par
5502   Q_PROPERTY({\cf18 bool} adaptiveSampling READ adaptiveSampling WRITE setAdaptiveSampling)\par
5504 {\cf17 public}:\par
5510   {\cf17 enum} LineStyle \{ lsNone        \par
5512                    ,lsLine       \par
5513                    ,lsStepLeft   \par
5514                    ,lsStepRight  \par
5515                    ,lsStepCenter \par
5516                    ,lsImpulse    \par
5517                  \};\par
5518   Q_ENUMS(LineStyle)\par
5519   \par
5520   explicit QCPGraph(QCPAxis *keyAxis, QCPAxis *valueAxis);\par
5521   virtual ~QCPGraph() Q_DECL_OVERRIDE;\par
5522   \par
5523   {\cf20 // getters:}\par
5524   QSharedPointer<QCPGraphDataContainer> data(){\cf17  const }\{ {\cf19 return} mDataContainer; \}\par
5525   LineStyle lineStyle(){\cf17  const }\{ {\cf19 return} mLineStyle; \}\par
5526   QCPScatterStyle scatterStyle(){\cf17  const }\{ {\cf19 return} mScatterStyle; \}\par
5527   {\cf18 int} scatterSkip(){\cf17  const }\{ {\cf19 return} mScatterSkip; \}\par
5528   QCPGraph *channelFillGraph(){\cf17  const }\{ {\cf19 return} mChannelFillGraph.data(); \}\par
5529   {\cf18 bool} adaptiveSampling(){\cf17  const }\{ {\cf19 return} mAdaptiveSampling; \}\par
5530   \par
5531   {\cf20 // setters:}\par
5532   {\cf18 void} setData(QSharedPointer<QCPGraphDataContainer> data);\par
5533   {\cf18 void} setData({\cf17 const} QVector<double> &keys, {\cf17 const} QVector<double> &values, {\cf18 bool} alreadySorted={\cf17 false});\par
5534   {\cf18 void} setLineStyle(LineStyle ls);\par
5535   {\cf18 void} setScatterStyle({\cf17 const} QCPScatterStyle &style);\par
5536   {\cf18 void} setScatterSkip({\cf18 int} skip);\par
5537   {\cf18 void} setChannelFillGraph(QCPGraph *targetGraph);\par
5538   {\cf18 void} setAdaptiveSampling({\cf18 bool} enabled);\par
5539   \par
5540   {\cf20 // non-property methods:}\par
5541   {\cf18 void} addData({\cf17 const} QVector<double> &keys, {\cf17 const} QVector<double> &values, {\cf18 bool} alreadySorted={\cf17 false});\par
5542   {\cf18 void} addData({\cf18 double} key, {\cf18 double} value);\par
5543   \par
5544   {\cf20 // reimplemented virtual methods:}\par
5545   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
5546   virtual QCPRange getKeyRange({\cf18 bool} &foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth) const Q_DECL_OVERRIDE;\par
5547   virtual QCPRange getValueRange({\cf18 bool} &foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth, const QCPRange &inKeyRange=QCPRange()) const Q_DECL_OVERRIDE;\par
5548   \par
5549 protected:\par
5550   {\cf20 // property members:}\par
5551   LineStyle mLineStyle;\par
5552   QCPScatterStyle mScatterStyle;\par
5553   {\cf18 int} mScatterSkip;\par
5554   QPointer<QCPGraph> mChannelFillGraph;\par
5555   {\cf18 bool} mAdaptiveSampling;\par
5556   \par
5557   {\cf20 // reimplemented virtual methods:}\par
5558   virtual {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
5559   virtual {\cf18 void} drawLegendIcon(QCPPainter *painter, const QRectF &rect) const Q_DECL_OVERRIDE;\par
5560   \par
5561   {\cf20 // introduced virtual methods:}\par
5562   virtual {\cf18 void} drawFill(QCPPainter *painter, QVector<QPointF> *lines) const;\par
5563   virtual {\cf18 void} drawScatterPlot(QCPPainter *painter, const QVector<QPointF> &scatters, const QCPScatterStyle &style) const;\par
5564   virtual {\cf18 void} drawLinePlot(QCPPainter *painter, const QVector<QPointF> &lines) const;\par
5565   virtual {\cf18 void} drawImpulsePlot(QCPPainter *painter, const QVector<QPointF> &lines) const;\par
5566   \par
5567   virtual {\cf18 void} getOptimizedLineData(QVector<QCPGraphData> *lineData, const QCPGraphDataContainer::const_iterator &begin, const QCPGraphDataContainer::const_iterator &end) const;\par
5568   virtual {\cf18 void} getOptimizedScatterData(QVector<QCPGraphData> *scatterData, QCPGraphDataContainer::const_iterator begin, QCPGraphDataContainer::const_iterator end) const;\par
5569   \par
5570   {\cf20 // non-virtual methods:}\par
5571   {\cf18 void} getVisibleDataBounds(QCPGraphDataContainer::const_iterator &begin, QCPGraphDataContainer::const_iterator &end, const QCPDataRange &rangeRestriction) const;\par
5572   {\cf18 void} getLines(QVector<QPointF> *lines, const QCPDataRange &dataRange) const;\par
5573   {\cf18 void} getScatters(QVector<QPointF> *scatters, const QCPDataRange &dataRange) const;\par
5574   QVector<QPointF> dataToLines(const QVector<QCPGraphData> &data) const;\par
5575   QVector<QPointF> dataToStepLeftLines(const QVector<QCPGraphData> &data) const;\par
5576   QVector<QPointF> dataToStepRightLines(const QVector<QCPGraphData> &data) const;\par
5577   QVector<QPointF> dataToStepCenterLines(const QVector<QCPGraphData> &data) const;\par
5578   QVector<QPointF> dataToImpulseLines(const QVector<QCPGraphData> &data) const;\par
5579   QVector<QCPDataRange> getNonNanSegments(const QVector<QPointF> *lineData, Qt::Orientation keyOrientation) const;\par
5580   QVector<QPair<QCPDataRange, QCPDataRange> > getOverlappingSegments(QVector<QCPDataRange> thisSegments, const QVector<QPointF> *thisData, QVector<QCPDataRange> otherSegments, const QVector<QPointF> *otherData) const;\par
5581   {\cf18 bool} segmentsIntersect({\cf18 double} aLower, {\cf18 double} aUpper, {\cf18 double} bLower, {\cf18 double} bUpper, {\cf18 int} &bPrecedence) const;\par
5582   QPointF getFillBasePoint(QPointF matchingDataPoint) const;\par
5583   const QPolygonF getFillPolygon(const QVector<QPointF> *lineData, QCPDataRange segment) const;\par
5584   const QPolygonF getChannelFillPolygon(const QVector<QPointF> *thisData, QCPDataRange thisSegment, const QVector<QPointF> *otherData, QCPDataRange otherSegment) const;\par
5585   {\cf18 int} findIndexBelowX(const QVector<QPointF> *data, {\cf18 double} x) const;\par
5586   {\cf18 int} findIndexAboveX(const QVector<QPointF> *data, {\cf18 double} x) const;\par
5587   {\cf18 int} findIndexBelowY(const QVector<QPointF> *data, {\cf18 double} y) const;\par
5588   {\cf18 int} findIndexAboveY(const QVector<QPointF> *data, {\cf18 double} y) const;\par
5589   {\cf18 double} pointDistance(const QPointF &pixelPoint, QCPGraphDataContainer::const_iterator &closestData) const;\par
5590   \par
5591   friend class QCustomPlot;\par
5592   friend class QCPLegend;\par
5593 \};\par
5594 Q_DECLARE_METATYPE(QCPGraph::LineStyle)\par
5595 \par
5596 {\cf20 /* end of 'src/plottables/plottable-graph.h' */}\par
5597 \par
5598 \par
5599 {\cf20 /* including file 'src/plottables/plottable-curve.h' */}\par
5600 {\cf20 /* modified 2022-11-06T12:45:56, size 7434           */}\par
5601 \par
5602 class QCP_LIB_DECL QCPCurveData\par
5603 \{\par
5604 {\cf17 public}:\par
5605   QCPCurveData();\par
5606   QCPCurveData({\cf18 double} t, {\cf18 double} key, {\cf18 double} value);\par
5607   \par
5608   {\cf17 inline} {\cf18 double} sortKey(){\cf17  const }\{ {\cf19 return} t; \}\par
5609   {\cf17 inline} {\cf17 static} QCPCurveData fromSortKey({\cf18 double} sortKey) \{ {\cf19 return} QCPCurveData(sortKey, 0, 0); \}\par
5610   {\cf17 inline} {\cf17 static} {\cf18 bool} sortKeyIsMainKey() \{ {\cf19 return} {\cf17 false}; \}\par
5611   \par
5612   {\cf17 inline} {\cf18 double} mainKey(){\cf17  const }\{ {\cf19 return} key; \}\par
5613   {\cf17 inline} {\cf18 double} mainValue(){\cf17  const }\{ {\cf19 return} value; \}\par
5614   \par
5615   {\cf17 inline} QCPRange valueRange(){\cf17  const }\{ {\cf19 return} QCPRange(value, value); \}\par
5616   \par
5617   {\cf18 double} t, key, value;\par
5618 \};\par
5619 Q_DECLARE_TYPEINFO(QCPCurveData, Q_PRIMITIVE_TYPE);\par
5620 \par
5621 \par
5632 {\cf17 typedef} QCPDataContainer<QCPCurveData> QCPCurveDataContainer;\par
5633 \par
5634 {\cf17 class }QCP_LIB_DECL QCPCurve : {\cf17 public} QCPAbstractPlottable1D<QCPCurveData>\par
5635 \{\par
5636   Q_OBJECT\par
5638   Q_PROPERTY(QCPScatterStyle scatterStyle READ scatterStyle WRITE setScatterStyle)\par
5639   Q_PROPERTY({\cf18 int} scatterSkip READ scatterSkip WRITE setScatterSkip)\par
5640   Q_PROPERTY(LineStyle lineStyle READ lineStyle WRITE setLineStyle)\par
5642 {\cf17 public}:\par
5648   {\cf17 enum} LineStyle \{ lsNone  \par
5649                    ,lsLine \par
5650                  \};\par
5651   Q_ENUMS(LineStyle)\par
5652   \par
5653   explicit QCPCurve(QCPAxis *keyAxis, QCPAxis *valueAxis);\par
5654   virtual ~QCPCurve() Q_DECL_OVERRIDE;\par
5655   \par
5656   {\cf20 // getters:}\par
5657   QSharedPointer<QCPCurveDataContainer> data(){\cf17  const }\{ {\cf19 return} mDataContainer; \}\par
5658   QCPScatterStyle scatterStyle(){\cf17  const }\{ {\cf19 return} mScatterStyle; \}\par
5659   {\cf18 int} scatterSkip(){\cf17  const }\{ {\cf19 return} mScatterSkip; \}\par
5660   LineStyle lineStyle(){\cf17  const }\{ {\cf19 return} mLineStyle; \}\par
5661   \par
5662   {\cf20 // setters:}\par
5663   {\cf18 void} setData(QSharedPointer<QCPCurveDataContainer> data);\par
5664   {\cf18 void} setData({\cf17 const} QVector<double> &t, {\cf17 const} QVector<double> &keys, {\cf17 const} QVector<double> &values, {\cf18 bool} alreadySorted={\cf17 false});\par
5665   {\cf18 void} setData({\cf17 const} QVector<double> &keys, {\cf17 const} QVector<double> &values);\par
5666   {\cf18 void} setScatterStyle({\cf17 const} QCPScatterStyle &style);\par
5667   {\cf18 void} setScatterSkip({\cf18 int} skip);\par
5668   {\cf18 void} setLineStyle(LineStyle style);\par
5669   \par
5670   {\cf20 // non-property methods:}\par
5671   {\cf18 void} addData({\cf17 const} QVector<double> &t, {\cf17 const} QVector<double> &keys, {\cf17 const} QVector<double> &values, {\cf18 bool} alreadySorted={\cf17 false});\par
5672   {\cf18 void} addData({\cf17 const} QVector<double> &keys, {\cf17 const} QVector<double> &values);\par
5673   {\cf18 void} addData({\cf18 double} t, {\cf18 double} key, {\cf18 double} value);\par
5674   {\cf18 void} addData({\cf18 double} key, {\cf18 double} value);\par
5675   \par
5676   {\cf20 // reimplemented virtual methods:}\par
5677   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
5678   virtual QCPRange getKeyRange({\cf18 bool} &foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth) const Q_DECL_OVERRIDE;\par
5679   virtual QCPRange getValueRange({\cf18 bool} &foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth, const QCPRange &inKeyRange=QCPRange()) const Q_DECL_OVERRIDE;\par
5680   \par
5681 protected:\par
5682   {\cf20 // property members:}\par
5683   QCPScatterStyle mScatterStyle;\par
5684   {\cf18 int} mScatterSkip;\par
5685   LineStyle mLineStyle;\par
5686   \par
5687   {\cf20 // reimplemented virtual methods:}\par
5688   virtual {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
5689   virtual {\cf18 void} drawLegendIcon(QCPPainter *painter, const QRectF &rect) const Q_DECL_OVERRIDE;\par
5690   \par
5691   {\cf20 // introduced virtual methods:}\par
5692   virtual {\cf18 void} drawCurveLine(QCPPainter *painter, const QVector<QPointF> &lines) const;\par
5693   virtual {\cf18 void} drawScatterPlot(QCPPainter *painter, const QVector<QPointF> &points, const QCPScatterStyle &style) const;\par
5694   \par
5695   {\cf20 // non-virtual methods:}\par
5696   {\cf18 void} getCurveLines(QVector<QPointF> *lines, const QCPDataRange &dataRange, {\cf18 double} penWidth) const;\par
5697   {\cf18 void} getScatters(QVector<QPointF> *scatters, const QCPDataRange &dataRange, {\cf18 double} scatterWidth) const;\par
5698   {\cf18 int} getRegion({\cf18 double} key, {\cf18 double} value, {\cf18 double} keyMin, {\cf18 double} valueMax, {\cf18 double} keyMax, {\cf18 double} valueMin) const;\par
5699   QPointF getOptimizedPoint({\cf18 int} otherRegion, {\cf18 double} otherKey, {\cf18 double} otherValue, {\cf18 double} key, {\cf18 double} value, {\cf18 double} keyMin, {\cf18 double} valueMax, {\cf18 double} keyMax, {\cf18 double} valueMin) const;\par
5700   QVector<QPointF> getOptimizedCornerPoints({\cf18 int} prevRegion, {\cf18 int} currentRegion, {\cf18 double} prevKey, {\cf18 double} prevValue, {\cf18 double} key, {\cf18 double} value, {\cf18 double} keyMin, {\cf18 double} valueMax, {\cf18 double} keyMax, {\cf18 double} valueMin) const;\par
5701   {\cf18 bool} mayTraverse({\cf18 int} prevRegion, {\cf18 int} currentRegion) const;\par
5702   {\cf18 bool} getTraverse({\cf18 double} prevKey, {\cf18 double} prevValue, {\cf18 double} key, {\cf18 double} value, {\cf18 double} keyMin, {\cf18 double} valueMax, {\cf18 double} keyMax, {\cf18 double} valueMin, QPointF &crossA, QPointF &crossB) const;\par
5703   {\cf18 void} getTraverseCornerPoints({\cf18 int} prevRegion, {\cf18 int} currentRegion, {\cf18 double} keyMin, {\cf18 double} valueMax, {\cf18 double} keyMax, {\cf18 double} valueMin, QVector<QPointF> &beforeTraverse, QVector<QPointF> &afterTraverse) const;\par
5704   {\cf18 double} pointDistance(const QPointF &pixelPoint, QCPCurveDataContainer::const_iterator &closestData) const;\par
5705   \par
5706   friend class QCustomPlot;\par
5707   friend class QCPLegend;\par
5708 \};\par
5709 Q_DECLARE_METATYPE(QCPCurve::LineStyle)\par
5710 \par
5711 {\cf20 /* end of 'src/plottables/plottable-curve.h' */}\par
5712 \par
5713 \par
5714 {\cf20 /* including file 'src/plottables/plottable-bars.h' */}\par
5715 {\cf20 /* modified 2022-11-06T12:45:56, size 8955          */}\par
5716 \par
5717 class QCP_LIB_DECL QCPBarsGroup : public QObject\par
5718 \{\par
5719   Q_OBJECT\par
5721   Q_PROPERTY(SpacingType spacingType READ spacingType WRITE setSpacingType)\par
5722   Q_PROPERTY({\cf18 double} spacing READ spacing WRITE setSpacing)\par
5724 {\cf17 public}:\par
5731   {\cf17 enum} SpacingType \{ stAbsolute       \par
5732                      ,stAxisRectRatio \par
5733                      ,stPlotCoords    \par
5734                    \};\par
5735   Q_ENUMS(SpacingType)\par
5736   \par
5737   explicit QCPBarsGroup(QCustomPlot *parentPlot);\par
5738   virtual ~QCPBarsGroup();\par
5739   \par
5740   {\cf20 // getters:}\par
5741   SpacingType spacingType(){\cf17  const }\{ {\cf19 return} mSpacingType; \}\par
5742   {\cf18 double} spacing(){\cf17  const }\{ {\cf19 return} mSpacing; \}\par
5743   \par
5744   {\cf20 // setters:}\par
5745   {\cf18 void} setSpacingType(SpacingType spacingType);\par
5746   {\cf18 void} setSpacing({\cf18 double} spacing);\par
5747   \par
5748   {\cf20 // non-virtual methods:}\par
5749   QList<QCPBars*> bars(){\cf17  const }\{ {\cf19 return} mBars; \}\par
5750   QCPBars* bars({\cf18 int} index) {\cf17 const};\par
5751   {\cf18 int} size(){\cf17  const }\{ {\cf19 return} mBars.size(); \}\par
5752   {\cf18 bool} isEmpty(){\cf17  const }\{ {\cf19 return} mBars.isEmpty(); \}\par
5753   {\cf18 void} clear();\par
5754   {\cf18 bool} contains(QCPBars *bars){\cf17  const }\{ {\cf19 return} mBars.contains(bars); \}\par
5755   {\cf18 void} append(QCPBars *bars);\par
5756   {\cf18 void} insert({\cf18 int} i, QCPBars *bars);\par
5757   {\cf18 void} remove(QCPBars *bars);\par
5758   \par
5759 {\cf17 protected}:\par
5760   {\cf20 // non-property members:}\par
5761   QCustomPlot *mParentPlot;\par
5762   SpacingType mSpacingType;\par
5763   {\cf18 double} mSpacing;\par
5764   QList<QCPBars*> mBars;\par
5765   \par
5766   {\cf20 // non-virtual methods:}\par
5767   {\cf18 void} registerBars(QCPBars *bars);\par
5768   {\cf18 void} unregisterBars(QCPBars *bars);\par
5769   \par
5770   {\cf20 // virtual methods:}\par
5771   {\cf18 double} keyPixelOffset({\cf17 const} QCPBars *bars, {\cf18 double} keyCoord);\par
5772   {\cf18 double} getPixelSpacing({\cf17 const} QCPBars *bars, {\cf18 double} keyCoord);\par
5773   \par
5774 {\cf17 private}:\par
5775   Q_DISABLE_COPY(QCPBarsGroup)\par
5776   \par
5777   friend class QCPBars;\par
5778 \};\par
5779 Q_DECLARE_METATYPE(QCPBarsGroup::SpacingType)\par
5780 \par
5781 \par
5782 class QCP_LIB_DECL QCPBarsData\par
5783 \{\par
5784 {\cf17 public}:\par
5785   QCPBarsData();\par
5786   QCPBarsData({\cf18 double} key, {\cf18 double} value);\par
5787   \par
5788   {\cf17 inline} {\cf18 double} sortKey(){\cf17  const }\{ {\cf19 return} key; \}\par
5789   {\cf17 inline} {\cf17 static} QCPBarsData fromSortKey({\cf18 double} sortKey) \{ {\cf19 return} QCPBarsData(sortKey, 0); \}\par
5790   {\cf17 inline} {\cf17 static} {\cf18 bool} sortKeyIsMainKey() \{ {\cf19 return} {\cf17 true}; \} \par
5791   \par
5792   {\cf17 inline} {\cf18 double} mainKey(){\cf17  const }\{ {\cf19 return} key; \}\par
5793   {\cf17 inline} {\cf18 double} mainValue(){\cf17  const }\{ {\cf19 return} value; \}\par
5794   \par
5795   {\cf17 inline} QCPRange valueRange(){\cf17  const }\{ {\cf19 return} QCPRange(value, value); \} {\cf20 // note that bar base value isn't held in each QCPBarsData and thus can't/shouldn't be returned here}\par
5796   \par
5797   {\cf18 double} key, value;\par
5798 \};\par
5799 Q_DECLARE_TYPEINFO(QCPBarsData, Q_PRIMITIVE_TYPE);\par
5800 \par
5801 \par
5811 {\cf17 typedef} QCPDataContainer<QCPBarsData> QCPBarsDataContainer;\par
5812 \par
5813 {\cf17 class }QCP_LIB_DECL QCPBars : {\cf17 public} QCPAbstractPlottable1D<QCPBarsData>\par
5814 \{\par
5815   Q_OBJECT\par
5817   Q_PROPERTY({\cf18 double} width READ width WRITE setWidth)\par
5818   Q_PROPERTY(WidthType widthType READ widthType WRITE setWidthType)\par
5819   Q_PROPERTY(QCPBarsGroup* barsGroup READ barsGroup WRITE setBarsGroup)\par
5820   Q_PROPERTY({\cf18 double} baseValue READ baseValue WRITE setBaseValue)\par
5821   Q_PROPERTY({\cf18 double} stackingGap READ stackingGap WRITE setStackingGap)\par
5822   Q_PROPERTY(QCPBars* barBelow READ barBelow)\par
5823   Q_PROPERTY(QCPBars* barAbove READ barAbove)\par
5825 {\cf17 public}:\par
5832   {\cf17 enum} WidthType \{ wtAbsolute       \par
5833                    ,wtAxisRectRatio \par
5834                    ,wtPlotCoords    \par
5835                  \};\par
5836   Q_ENUMS(WidthType)\par
5837   \par
5838   explicit QCPBars(QCPAxis *keyAxis, QCPAxis *valueAxis);\par
5839   virtual ~QCPBars() Q_DECL_OVERRIDE;\par
5840   \par
5841   {\cf20 // getters:}\par
5842   {\cf18 double} width(){\cf17  const }\{ {\cf19 return} mWidth; \}\par
5843   WidthType widthType(){\cf17  const }\{ {\cf19 return} mWidthType; \}\par
5844   QCPBarsGroup *barsGroup(){\cf17  const }\{ {\cf19 return} mBarsGroup; \}\par
5845   {\cf18 double} baseValue(){\cf17  const }\{ {\cf19 return} mBaseValue; \}\par
5846   {\cf18 double} stackingGap(){\cf17  const }\{ {\cf19 return} mStackingGap; \}\par
5847   QCPBars *barBelow(){\cf17  const }\{ {\cf19 return} mBarBelow.data(); \}\par
5848   QCPBars *barAbove(){\cf17  const }\{ {\cf19 return} mBarAbove.data(); \}\par
5849   QSharedPointer<QCPBarsDataContainer> data(){\cf17  const }\{ {\cf19 return} mDataContainer; \}\par
5850   \par
5851   {\cf20 // setters:}\par
5852   {\cf18 void} setData(QSharedPointer<QCPBarsDataContainer> data);\par
5853   {\cf18 void} setData({\cf17 const} QVector<double> &keys, {\cf17 const} QVector<double> &values, {\cf18 bool} alreadySorted={\cf17 false});\par
5854   {\cf18 void} setWidth({\cf18 double} width);\par
5855   {\cf18 void} setWidthType(WidthType widthType);\par
5856   {\cf18 void} setBarsGroup(QCPBarsGroup *barsGroup);\par
5857   {\cf18 void} setBaseValue({\cf18 double} baseValue);\par
5858   {\cf18 void} setStackingGap({\cf18 double} pixels);\par
5859   \par
5860   {\cf20 // non-property methods:}\par
5861   {\cf18 void} addData({\cf17 const} QVector<double> &keys, {\cf17 const} QVector<double> &values, {\cf18 bool} alreadySorted={\cf17 false});\par
5862   {\cf18 void} addData({\cf18 double} key, {\cf18 double} value);\par
5863   {\cf18 void} moveBelow(QCPBars *bars);\par
5864   {\cf18 void} moveAbove(QCPBars *bars);\par
5865   \par
5866   {\cf20 // reimplemented virtual methods:}\par
5867   {\cf17 virtual} QCPDataSelection selectTestRect({\cf17 const} QRectF &rect, {\cf18 bool} onlySelectable) {\cf17 const} Q_DECL_OVERRIDE;\par
5868   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
5869   virtual QCPRange getKeyRange({\cf18 bool} &foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth) const Q_DECL_OVERRIDE;\par
5870   virtual QCPRange getValueRange({\cf18 bool} &foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth, const QCPRange &inKeyRange=QCPRange()) const Q_DECL_OVERRIDE;\par
5871   virtual QPointF dataPixelPosition({\cf18 int} index) const Q_DECL_OVERRIDE;\par
5872   \par
5873 protected:\par
5874   {\cf20 // property members:}\par
5875   {\cf18 double} mWidth;\par
5876   WidthType mWidthType;\par
5877   QCPBarsGroup *mBarsGroup;\par
5878   {\cf18 double} mBaseValue;\par
5879   {\cf18 double} mStackingGap;\par
5880   QPointer<QCPBars> mBarBelow, mBarAbove;\par
5881   \par
5882   {\cf20 // reimplemented virtual methods:}\par
5883   virtual {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
5884   virtual {\cf18 void} drawLegendIcon(QCPPainter *painter, const QRectF &rect) const Q_DECL_OVERRIDE;\par
5885   \par
5886   {\cf20 // non-virtual methods:}\par
5887   {\cf18 void} getVisibleDataBounds(QCPBarsDataContainer::const_iterator &begin, QCPBarsDataContainer::const_iterator &end) const;\par
5888   QRectF getBarRect({\cf18 double} key, {\cf18 double} value) const;\par
5889   {\cf18 void} getPixelWidth({\cf18 double} key, {\cf18 double} &lower, {\cf18 double} &upper) const;\par
5890   {\cf18 double} getStackedBaseValue({\cf18 double} key, {\cf18 bool} positive) const;\par
5891   static {\cf18 void} connectBars(QCPBars* lower, QCPBars* upper);\par
5892   \par
5893   friend class QCustomPlot;\par
5894   friend class QCPLegend;\par
5895   friend class QCPBarsGroup;\par
5896 \};\par
5897 Q_DECLARE_METATYPE(QCPBars::WidthType)\par
5898 \par
5899 {\cf20 /* end of 'src/plottables/plottable-bars.h' */}\par
5900 \par
5901 \par
5902 {\cf20 /* including file 'src/plottables/plottable-statisticalbox.h' */}\par
5903 {\cf20 /* modified 2022-11-06T12:45:56, size 7522                    */}\par
5904 \par
5905 class QCP_LIB_DECL QCPStatisticalBoxData\par
5906 \{\par
5907 {\cf17 public}:\par
5908   QCPStatisticalBoxData();\par
5909   QCPStatisticalBoxData({\cf18 double} key, {\cf18 double} minimum, {\cf18 double} lowerQuartile, {\cf18 double} median, {\cf18 double} upperQuartile, {\cf18 double} maximum, {\cf17 const} QVector<double>& outliers=QVector<double>());\par
5910   \par
5911   {\cf17 inline} {\cf18 double} sortKey(){\cf17  const }\{ {\cf19 return} key; \}\par
5912   {\cf17 inline} {\cf17 static} QCPStatisticalBoxData fromSortKey({\cf18 double} sortKey) \{ {\cf19 return} QCPStatisticalBoxData(sortKey, 0, 0, 0, 0, 0); \}\par
5913   {\cf17 inline} {\cf17 static} {\cf18 bool} sortKeyIsMainKey() \{ {\cf19 return} {\cf17 true}; \}\par
5914   \par
5915   {\cf17 inline} {\cf18 double} mainKey(){\cf17  const }\{ {\cf19 return} key; \}\par
5916   {\cf17 inline} {\cf18 double} mainValue(){\cf17  const }\{ {\cf19 return} median; \}\par
5917   \par
5918   {\cf17 inline} QCPRange valueRange(){\cf17  const}\par
5919 {\cf17   }\{\par
5920     QCPRange result(minimum, maximum);\par
5921     {\cf19 for} (QVector<double>::const_iterator it = outliers.constBegin(); it != outliers.constEnd(); ++it)\par
5922       result.expand(*it);\par
5923     {\cf19 return} result;\par
5924   \}\par
5925   \par
5926   {\cf18 double} key, minimum, lowerQuartile, median, upperQuartile, maximum;\par
5927   QVector<double> outliers;\par
5928 \};\par
5929 Q_DECLARE_TYPEINFO(QCPStatisticalBoxData, Q_MOVABLE_TYPE);\par
5930 \par
5931 \par
5942 {\cf17 typedef} QCPDataContainer<QCPStatisticalBoxData> QCPStatisticalBoxDataContainer;\par
5943 \par
5944 {\cf17 class }QCP_LIB_DECL QCPStatisticalBox : {\cf17 public} QCPAbstractPlottable1D<QCPStatisticalBoxData>\par
5945 \{\par
5946   Q_OBJECT\par
5948   Q_PROPERTY({\cf18 double} width READ width WRITE setWidth)\par
5949   Q_PROPERTY({\cf18 double} whiskerWidth READ whiskerWidth WRITE setWhiskerWidth)\par
5950   Q_PROPERTY(QPen whiskerPen READ whiskerPen WRITE setWhiskerPen)\par
5951   Q_PROPERTY(QPen whiskerBarPen READ whiskerBarPen WRITE setWhiskerBarPen)\par
5952   Q_PROPERTY({\cf18 bool} whiskerAntialiased READ whiskerAntialiased WRITE setWhiskerAntialiased)\par
5953   Q_PROPERTY(QPen medianPen READ medianPen WRITE setMedianPen)\par
5954   Q_PROPERTY(QCPScatterStyle outlierStyle READ outlierStyle WRITE setOutlierStyle)\par
5956 {\cf17 public}:\par
5957   {\cf17 explicit} QCPStatisticalBox(QCPAxis *keyAxis, QCPAxis *valueAxis);\par
5958   \par
5959   {\cf20 // getters:}\par
5960   QSharedPointer<QCPStatisticalBoxDataContainer> data(){\cf17  const }\{ {\cf19 return} mDataContainer; \}\par
5961   {\cf18 double} width(){\cf17  const }\{ {\cf19 return} mWidth; \}\par
5962   {\cf18 double} whiskerWidth(){\cf17  const }\{ {\cf19 return} mWhiskerWidth; \}\par
5963   QPen whiskerPen(){\cf17  const }\{ {\cf19 return} mWhiskerPen; \}\par
5964   QPen whiskerBarPen(){\cf17  const }\{ {\cf19 return} mWhiskerBarPen; \}\par
5965   {\cf18 bool} whiskerAntialiased(){\cf17  const }\{ {\cf19 return} mWhiskerAntialiased; \}\par
5966   QPen medianPen(){\cf17  const }\{ {\cf19 return} mMedianPen; \}\par
5967   QCPScatterStyle outlierStyle(){\cf17  const }\{ {\cf19 return} mOutlierStyle; \}\par
5968 \par
5969   {\cf20 // setters:}\par
5970   {\cf18 void} setData(QSharedPointer<QCPStatisticalBoxDataContainer> data);\par
5971   {\cf18 void} setData({\cf17 const} QVector<double> &keys, {\cf17 const} QVector<double> &minimum, {\cf17 const} QVector<double> &lowerQuartile, {\cf17 const} QVector<double> &median, {\cf17 const} QVector<double> &upperQuartile, {\cf17 const} QVector<double> &maximum, {\cf18 bool} alreadySorted={\cf17 false});\par
5972   {\cf18 void} setWidth({\cf18 double} width);\par
5973   {\cf18 void} setWhiskerWidth({\cf18 double} width);\par
5974   {\cf18 void} setWhiskerPen({\cf17 const} QPen &pen);\par
5975   {\cf18 void} setWhiskerBarPen({\cf17 const} QPen &pen);\par
5976   {\cf18 void} setWhiskerAntialiased({\cf18 bool} enabled);\par
5977   {\cf18 void} setMedianPen({\cf17 const} QPen &pen);\par
5978   {\cf18 void} setOutlierStyle({\cf17 const} QCPScatterStyle &style);\par
5979   \par
5980   {\cf20 // non-property methods:}\par
5981   {\cf18 void} addData({\cf17 const} QVector<double> &keys, {\cf17 const} QVector<double> &minimum, {\cf17 const} QVector<double> &lowerQuartile, {\cf17 const} QVector<double> &median, {\cf17 const} QVector<double> &upperQuartile, {\cf17 const} QVector<double> &maximum, {\cf18 bool} alreadySorted={\cf17 false});\par
5982   {\cf18 void} addData({\cf18 double} key, {\cf18 double} minimum, {\cf18 double} lowerQuartile, {\cf18 double} median, {\cf18 double} upperQuartile, {\cf18 double} maximum, {\cf17 const} QVector<double> &outliers=QVector<double>());\par
5983   \par
5984   {\cf20 // reimplemented virtual methods:}\par
5985   {\cf17 virtual} QCPDataSelection selectTestRect({\cf17 const} QRectF &rect, {\cf18 bool} onlySelectable) {\cf17 const} Q_DECL_OVERRIDE;\par
5986   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
5987   virtual QCPRange getKeyRange({\cf18 bool} &foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth) const Q_DECL_OVERRIDE;\par
5988   virtual QCPRange getValueRange({\cf18 bool} &foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth, const QCPRange &inKeyRange=QCPRange()) const Q_DECL_OVERRIDE;\par
5989   \par
5990 protected:\par
5991   {\cf20 // property members:}\par
5992   {\cf18 double} mWidth;\par
5993   {\cf18 double} mWhiskerWidth;\par
5994   QPen mWhiskerPen, mWhiskerBarPen;\par
5995   {\cf18 bool} mWhiskerAntialiased;\par
5996   QPen mMedianPen;\par
5997   QCPScatterStyle mOutlierStyle;\par
5998   \par
5999   {\cf20 // reimplemented virtual methods:}\par
6000   virtual {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
6001   virtual {\cf18 void} drawLegendIcon(QCPPainter *painter, const QRectF &rect) const Q_DECL_OVERRIDE;\par
6002   \par
6003   {\cf20 // introduced virtual methods:}\par
6004   virtual {\cf18 void} drawStatisticalBox(QCPPainter *painter, QCPStatisticalBoxDataContainer::const_iterator it, const QCPScatterStyle &outlierStyle) const;\par
6005   \par
6006   {\cf20 // non-virtual methods:}\par
6007   {\cf18 void} getVisibleDataBounds(QCPStatisticalBoxDataContainer::const_iterator &begin, QCPStatisticalBoxDataContainer::const_iterator &end) const;\par
6008   QRectF getQuartileBox(QCPStatisticalBoxDataContainer::const_iterator it) const;\par
6009   QVector<QLineF> getWhiskerBackboneLines(QCPStatisticalBoxDataContainer::const_iterator it) const;\par
6010   QVector<QLineF> getWhiskerBarLines(QCPStatisticalBoxDataContainer::const_iterator it) const;\par
6011   \par
6012   friend class QCustomPlot;\par
6013   friend class QCPLegend;\par
6014 \};\par
6015 \par
6016 {\cf20 /* end of 'src/plottables/plottable-statisticalbox.h' */}\par
6017 \par
6018 \par
6019 {\cf20 /* including file 'src/plottables/plottable-colormap.h' */}\par
6020 {\cf20 /* modified 2022-11-06T12:45:56, size 7092              */}\par
6021 \par
6022 class QCP_LIB_DECL QCPColorMapData\par
6023 \{\par
6024 {\cf17 public}:\par
6025   QCPColorMapData({\cf18 int} keySize, {\cf18 int} valueSize, {\cf17 const} QCPRange &keyRange, {\cf17 const} QCPRange &valueRange);\par
6026   ~QCPColorMapData();\par
6027   QCPColorMapData({\cf17 const} QCPColorMapData &other);\par
6028   QCPColorMapData &operator=({\cf17 const} QCPColorMapData &other);\par
6029   \par
6030   {\cf20 // getters:}\par
6031   {\cf18 int} keySize(){\cf17  const }\{ {\cf19 return} mKeySize; \}\par
6032   {\cf18 int} valueSize(){\cf17  const }\{ {\cf19 return} mValueSize; \}\par
6033   QCPRange keyRange(){\cf17  const }\{ {\cf19 return} mKeyRange; \}\par
6034   QCPRange valueRange(){\cf17  const }\{ {\cf19 return} mValueRange; \}\par
6035   QCPRange dataBounds(){\cf17  const }\{ {\cf19 return} mDataBounds; \}\par
6036   {\cf18 double} data({\cf18 double} key, {\cf18 double} value);\par
6037   {\cf18 double} cell({\cf18 int} keyIndex, {\cf18 int} valueIndex);\par
6038   {\cf18 unsigned} {\cf18 char} alpha({\cf18 int} keyIndex, {\cf18 int} valueIndex);\par
6039   \par
6040   {\cf20 // setters:}\par
6041   {\cf18 void} setSize({\cf18 int} keySize, {\cf18 int} valueSize);\par
6042   {\cf18 void} setKeySize({\cf18 int} keySize);\par
6043   {\cf18 void} setValueSize({\cf18 int} valueSize);\par
6044   {\cf18 void} setRange({\cf17 const} QCPRange &keyRange, {\cf17 const} QCPRange &valueRange);\par
6045   {\cf18 void} setKeyRange({\cf17 const} QCPRange &keyRange);\par
6046   {\cf18 void} setValueRange({\cf17 const} QCPRange &valueRange);\par
6047   {\cf18 void} setData({\cf18 double} key, {\cf18 double} value, {\cf18 double} z);\par
6048   {\cf18 void} setCell({\cf18 int} keyIndex, {\cf18 int} valueIndex, {\cf18 double} z);\par
6049   {\cf18 void} setAlpha({\cf18 int} keyIndex, {\cf18 int} valueIndex, {\cf18 unsigned} {\cf18 char} alpha);\par
6050   \par
6051   {\cf20 // non-property methods:}\par
6052   {\cf18 void} recalculateDataBounds();\par
6053   {\cf18 void} clear();\par
6054   {\cf18 void} clearAlpha();\par
6055   {\cf18 void} fill({\cf18 double} z);\par
6056   {\cf18 void} fillAlpha({\cf18 unsigned} {\cf18 char} alpha);\par
6057   {\cf18 bool} isEmpty(){\cf17  const }\{ {\cf19 return} mIsEmpty; \}\par
6058   {\cf18 void} coordToCell({\cf18 double} key, {\cf18 double} value, {\cf18 int} *keyIndex, {\cf18 int} *valueIndex) {\cf17 const};\par
6059   {\cf18 void} cellToCoord({\cf18 int} keyIndex, {\cf18 int} valueIndex, {\cf18 double} *key, {\cf18 double} *value) {\cf17 const};\par
6060   \par
6061 {\cf17 protected}:\par
6062   {\cf20 // property members:}\par
6063   {\cf18 int} mKeySize, mValueSize;\par
6064   QCPRange mKeyRange, mValueRange;\par
6065   {\cf18 bool} mIsEmpty;\par
6066   \par
6067   {\cf20 // non-property members:}\par
6068   {\cf18 double} *mData;\par
6069   {\cf18 unsigned} {\cf18 char} *mAlpha;\par
6070   QCPRange mDataBounds;\par
6071   {\cf18 bool} mDataModified;\par
6072   \par
6073   {\cf18 bool} createAlpha({\cf18 bool} initializeOpaque={\cf17 true});\par
6074   \par
6075   {\cf17 friend} {\cf17 class }QCPColorMap;\par
6076 \};\par
6077 \par
6078 \par
6079 {\cf17 class }QCP_LIB_DECL QCPColorMap : {\cf17 public} QCPAbstractPlottable\par
6080 \{\par
6081   Q_OBJECT\par
6083   Q_PROPERTY(QCPRange dataRange READ dataRange WRITE setDataRange NOTIFY dataRangeChanged)\par
6084   Q_PROPERTY(QCPAxis::ScaleType dataScaleType READ dataScaleType WRITE setDataScaleType NOTIFY dataScaleTypeChanged)\par
6085   Q_PROPERTY(QCPColorGradient gradient READ gradient WRITE setGradient NOTIFY gradientChanged)\par
6086   Q_PROPERTY({\cf18 bool} interpolate READ interpolate WRITE setInterpolate)\par
6087   Q_PROPERTY({\cf18 bool} tightBoundary READ tightBoundary WRITE setTightBoundary)\par
6088   Q_PROPERTY(QCPColorScale* colorScale READ colorScale WRITE setColorScale)\par
6090 {\cf17 public}:\par
6091   {\cf17 explicit} QCPColorMap(QCPAxis *keyAxis, QCPAxis *valueAxis);\par
6092   {\cf17 virtual} ~QCPColorMap() Q_DECL_OVERRIDE;\par
6093   \par
6094   {\cf20 // getters:}\par
6095   QCPColorMapData *data(){\cf17  const }\{ {\cf19 return} mMapData; \}\par
6096   QCPRange dataRange(){\cf17  const }\{ {\cf19 return} mDataRange; \}\par
6097   QCPAxis::ScaleType dataScaleType(){\cf17  const }\{ {\cf19 return} mDataScaleType; \}\par
6098   {\cf18 bool} interpolate(){\cf17  const }\{ {\cf19 return} mInterpolate; \}\par
6099   {\cf18 bool} tightBoundary(){\cf17  const }\{ {\cf19 return} mTightBoundary; \}\par
6100   QCPColorGradient gradient(){\cf17  const }\{ {\cf19 return} mGradient; \}\par
6101   QCPColorScale *colorScale(){\cf17  const }\{ {\cf19 return} mColorScale.data(); \}\par
6102   \par
6103   {\cf20 // setters:}\par
6104   {\cf18 void} setData(QCPColorMapData *data, {\cf18 bool} copy={\cf17 false});\par
6105   Q_SLOT {\cf18 void} setDataRange({\cf17 const} QCPRange &dataRange);\par
6106   Q_SLOT {\cf18 void} setDataScaleType(QCPAxis::ScaleType scaleType);\par
6107   Q_SLOT {\cf18 void} setGradient({\cf17 const} QCPColorGradient &gradient);\par
6108   {\cf18 void} setInterpolate({\cf18 bool} enabled);\par
6109   {\cf18 void} setTightBoundary({\cf18 bool} enabled);\par
6110   {\cf18 void} setColorScale(QCPColorScale *colorScale);\par
6111   \par
6112   {\cf20 // non-property methods:}\par
6113   {\cf18 void} rescaleDataRange({\cf18 bool} recalculateDataBounds={\cf17 false});\par
6114   Q_SLOT {\cf18 void} updateLegendIcon(Qt::TransformationMode transformMode=Qt::SmoothTransformation, {\cf17 const} QSize &thumbSize=QSize(32, 18));\par
6115   \par
6116   {\cf20 // reimplemented virtual methods:}\par
6117   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
6118   virtual QCPRange getKeyRange({\cf18 bool} &foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth) const Q_DECL_OVERRIDE;\par
6119   virtual QCPRange getValueRange({\cf18 bool} &foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth, const QCPRange &inKeyRange=QCPRange()) const Q_DECL_OVERRIDE;\par
6120   \par
6121 signals:\par
6122   {\cf18 void} dataRangeChanged(const QCPRange &newRange);\par
6123   {\cf18 void} dataScaleTypeChanged(QCPAxis::ScaleType scaleType);\par
6124   {\cf18 void} gradientChanged(const QCPColorGradient &newGradient);\par
6125   \par
6126 protected:\par
6127   {\cf20 // property members:}\par
6128   QCPRange mDataRange;\par
6129   QCPAxis::ScaleType mDataScaleType;\par
6130   QCPColorMapData *mMapData;\par
6131   QCPColorGradient mGradient;\par
6132   {\cf18 bool} mInterpolate;\par
6133   {\cf18 bool} mTightBoundary;\par
6134   QPointer<QCPColorScale> mColorScale;\par
6135   \par
6136   {\cf20 // non-property members:}\par
6137   QImage mMapImage, mUndersampledMapImage;\par
6138   QPixmap mLegendIcon;\par
6139   {\cf18 bool} mMapImageInvalidated;\par
6140   \par
6141   {\cf20 // introduced virtual methods:}\par
6142   virtual {\cf18 void} updateMapImage();\par
6143   \par
6144   {\cf20 // reimplemented virtual methods:}\par
6145   virtual {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
6146   virtual {\cf18 void} drawLegendIcon(QCPPainter *painter, const QRectF &rect) const Q_DECL_OVERRIDE;\par
6147   \par
6148   friend class QCustomPlot;\par
6149   friend class QCPLegend;\par
6150 \};\par
6151 \par
6152 {\cf20 /* end of 'src/plottables/plottable-colormap.h' */}\par
6153 \par
6154 \par
6155 {\cf20 /* including file 'src/plottables/plottable-financial.h' */}\par
6156 {\cf20 /* modified 2022-11-06T12:45:56, size 8644               */}\par
6157 \par
6158 class QCP_LIB_DECL QCPFinancialData\par
6159 \{\par
6160 {\cf17 public}:\par
6161   QCPFinancialData();\par
6162   QCPFinancialData({\cf18 double} key, {\cf18 double} open, {\cf18 double} high, {\cf18 double} low, {\cf18 double} close);\par
6163   \par
6164   {\cf17 inline} {\cf18 double} sortKey(){\cf17  const }\{ {\cf19 return} key; \}\par
6165   {\cf17 inline} {\cf17 static} QCPFinancialData fromSortKey({\cf18 double} sortKey) \{ {\cf19 return} QCPFinancialData(sortKey, 0, 0, 0, 0); \}\par
6166   {\cf17 inline} {\cf17 static} {\cf18 bool} sortKeyIsMainKey() \{ {\cf19 return} {\cf17 true}; \} \par
6167   \par
6168   {\cf17 inline} {\cf18 double} mainKey(){\cf17  const }\{ {\cf19 return} key; \}\par
6169   {\cf17 inline} {\cf18 double} mainValue(){\cf17  const }\{ {\cf19 return} open; \}\par
6170   \par
6171   {\cf17 inline} QCPRange valueRange(){\cf17  const }\{ {\cf19 return} QCPRange(low, high); \} {\cf20 // open and close must lie between low and high, so we don't need to check them}\par
6172   \par
6173   {\cf18 double} key, open, high, low, close;\par
6174 \};\par
6175 Q_DECLARE_TYPEINFO(QCPFinancialData, Q_PRIMITIVE_TYPE);\par
6176 \par
6177 \par
6187 {\cf17 typedef} QCPDataContainer<QCPFinancialData> QCPFinancialDataContainer;\par
6188 \par
6189 {\cf17 class }QCP_LIB_DECL QCPFinancial : {\cf17 public} QCPAbstractPlottable1D<QCPFinancialData>\par
6190 \{\par
6191   Q_OBJECT\par
6193   Q_PROPERTY(ChartStyle chartStyle READ chartStyle WRITE setChartStyle)\par
6194   Q_PROPERTY({\cf18 double} width READ width WRITE setWidth)\par
6195   Q_PROPERTY(WidthType widthType READ widthType WRITE setWidthType)\par
6196   Q_PROPERTY({\cf18 bool} twoColored READ twoColored WRITE setTwoColored)\par
6197   Q_PROPERTY(QBrush brushPositive READ brushPositive WRITE setBrushPositive)\par
6198   Q_PROPERTY(QBrush brushNegative READ brushNegative WRITE setBrushNegative)\par
6199   Q_PROPERTY(QPen penPositive READ penPositive WRITE setPenPositive)\par
6200   Q_PROPERTY(QPen penNegative READ penNegative WRITE setPenNegative)\par
6202 {\cf17 public}:\par
6209   {\cf17 enum} WidthType \{ wtAbsolute       \par
6210                    ,wtAxisRectRatio \par
6211                    ,wtPlotCoords    \par
6212                  \};\par
6213   Q_ENUMS(WidthType)\par
6214   \par
6215   \par
6220   enum ChartStyle \{ csOhlc         \par
6221                    ,csCandlestick  \par
6222                   \};\par
6223   Q_ENUMS(ChartStyle)\par
6224   \par
6225   explicit QCPFinancial(QCPAxis *keyAxis, QCPAxis *valueAxis);\par
6226   virtual ~QCPFinancial() Q_DECL_OVERRIDE;\par
6227   \par
6228   {\cf20 // getters:}\par
6229   QSharedPointer<QCPFinancialDataContainer> data(){\cf17  const }\{ {\cf19 return} mDataContainer; \}\par
6230   ChartStyle chartStyle(){\cf17  const }\{ {\cf19 return} mChartStyle; \}\par
6231   {\cf18 double} width(){\cf17  const }\{ {\cf19 return} mWidth; \}\par
6232   WidthType widthType(){\cf17  const }\{ {\cf19 return} mWidthType; \}\par
6233   {\cf18 bool} twoColored(){\cf17  const }\{ {\cf19 return} mTwoColored; \}\par
6234   QBrush brushPositive(){\cf17  const }\{ {\cf19 return} mBrushPositive; \}\par
6235   QBrush brushNegative(){\cf17  const }\{ {\cf19 return} mBrushNegative; \}\par
6236   QPen penPositive(){\cf17  const }\{ {\cf19 return} mPenPositive; \}\par
6237   QPen penNegative(){\cf17  const }\{ {\cf19 return} mPenNegative; \}\par
6238   \par
6239   {\cf20 // setters:}\par
6240   {\cf18 void} setData(QSharedPointer<QCPFinancialDataContainer> data);\par
6241   {\cf18 void} setData({\cf17 const} QVector<double> &keys, {\cf17 const} QVector<double> &open, {\cf17 const} QVector<double> &high, {\cf17 const} QVector<double> &low, {\cf17 const} QVector<double> &close, {\cf18 bool} alreadySorted={\cf17 false});\par
6242   {\cf18 void} setChartStyle(ChartStyle style);\par
6243   {\cf18 void} setWidth({\cf18 double} width);\par
6244   {\cf18 void} setWidthType(WidthType widthType);\par
6245   {\cf18 void} setTwoColored({\cf18 bool} twoColored);\par
6246   {\cf18 void} setBrushPositive({\cf17 const} QBrush &brush);\par
6247   {\cf18 void} setBrushNegative({\cf17 const} QBrush &brush);\par
6248   {\cf18 void} setPenPositive({\cf17 const} QPen &pen);\par
6249   {\cf18 void} setPenNegative({\cf17 const} QPen &pen);\par
6250   \par
6251   {\cf20 // non-property methods:}\par
6252   {\cf18 void} addData({\cf17 const} QVector<double> &keys, {\cf17 const} QVector<double> &open, {\cf17 const} QVector<double> &high, {\cf17 const} QVector<double> &low, {\cf17 const} QVector<double> &close, {\cf18 bool} alreadySorted={\cf17 false});\par
6253   {\cf18 void} addData({\cf18 double} key, {\cf18 double} open, {\cf18 double} high, {\cf18 double} low, {\cf18 double} close);\par
6254   \par
6255   {\cf20 // reimplemented virtual methods:}\par
6256   {\cf17 virtual} QCPDataSelection selectTestRect({\cf17 const} QRectF &rect, {\cf18 bool} onlySelectable) {\cf17 const} Q_DECL_OVERRIDE;\par
6257   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
6258   virtual QCPRange getKeyRange({\cf18 bool} &foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth) const Q_DECL_OVERRIDE;\par
6259   virtual QCPRange getValueRange({\cf18 bool} &foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth, const QCPRange &inKeyRange=QCPRange()) const Q_DECL_OVERRIDE;\par
6260   \par
6261   {\cf20 // static methods:}\par
6262   static QCPFinancialDataContainer timeSeriesToOhlc(const QVector<{\cf18 double}> &time, const QVector<{\cf18 double}> &value, {\cf18 double} timeBinSize, {\cf18 double} timeBinOffset = 0);\par
6263   \par
6264 protected:\par
6265   {\cf20 // property members:}\par
6266   ChartStyle mChartStyle;\par
6267   {\cf18 double} mWidth;\par
6268   WidthType mWidthType;\par
6269   {\cf18 bool} mTwoColored;\par
6270   QBrush mBrushPositive, mBrushNegative;\par
6271   QPen mPenPositive, mPenNegative;\par
6272   \par
6273   {\cf20 // reimplemented virtual methods:}\par
6274   virtual {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
6275   virtual {\cf18 void} drawLegendIcon(QCPPainter *painter, const QRectF &rect) const Q_DECL_OVERRIDE;\par
6276   \par
6277   {\cf20 // non-virtual methods:}\par
6278   {\cf18 void} drawOhlcPlot(QCPPainter *painter, const QCPFinancialDataContainer::const_iterator &begin, const QCPFinancialDataContainer::const_iterator &end, {\cf18 bool} isSelected);\par
6279   {\cf18 void} drawCandlestickPlot(QCPPainter *painter, const QCPFinancialDataContainer::const_iterator &begin, const QCPFinancialDataContainer::const_iterator &end, {\cf18 bool} isSelected);\par
6280   {\cf18 double} getPixelWidth({\cf18 double} key, {\cf18 double} keyPixel) const;\par
6281   {\cf18 double} ohlcSelectTest(const QPointF &pos, const QCPFinancialDataContainer::const_iterator &begin, const QCPFinancialDataContainer::const_iterator &end, QCPFinancialDataContainer::const_iterator &closestDataPoint) const;\par
6282   {\cf18 double} candlestickSelectTest(const QPointF &pos, const QCPFinancialDataContainer::const_iterator &begin, const QCPFinancialDataContainer::const_iterator &end, QCPFinancialDataContainer::const_iterator &closestDataPoint) const;\par
6283   {\cf18 void} getVisibleDataBounds(QCPFinancialDataContainer::const_iterator &begin, QCPFinancialDataContainer::const_iterator &end) const;\par
6284   QRectF selectionHitBox(QCPFinancialDataContainer::const_iterator it) const;\par
6285   \par
6286   friend class QCustomPlot;\par
6287   friend class QCPLegend;\par
6288 \};\par
6289 Q_DECLARE_METATYPE(QCPFinancial::ChartStyle)\par
6290 \par
6291 {\cf20 /* end of 'src/plottables/plottable-financial.h' */}\par
6292 \par
6293 \par
6294 {\cf20 /* including file 'src/plottables/plottable-errorbar.h' */}\par
6295 {\cf20 /* modified 2022-11-06T12:45:56, size 7749              */}\par
6296 \par
6297 class QCP_LIB_DECL QCPErrorBarsData\par
6298 \{\par
6299 {\cf17 public}:\par
6300   QCPErrorBarsData();\par
6301   {\cf17 explicit} QCPErrorBarsData({\cf18 double} error);\par
6302   QCPErrorBarsData({\cf18 double} errorMinus, {\cf18 double} errorPlus);\par
6303   \par
6304   {\cf18 double} errorMinus, errorPlus;\par
6305 \};\par
6306 Q_DECLARE_TYPEINFO(QCPErrorBarsData, Q_PRIMITIVE_TYPE);\par
6307 \par
6308 \par
6324 {\cf17 typedef} QVector<QCPErrorBarsData> QCPErrorBarsDataContainer;\par
6325 \par
6326 {\cf17 class }QCP_LIB_DECL QCPErrorBars : {\cf17 public} QCPAbstractPlottable, {\cf17 public} QCPPlottableInterface1D\par
6327 \{\par
6328   Q_OBJECT\par
6330   Q_PROPERTY(QSharedPointer<QCPErrorBarsDataContainer> data READ data WRITE setData)\par
6331   Q_PROPERTY(QCPAbstractPlottable* dataPlottable READ dataPlottable WRITE setDataPlottable)\par
6332   Q_PROPERTY(ErrorType errorType READ errorType WRITE setErrorType)\par
6333   Q_PROPERTY({\cf18 double} whiskerWidth READ whiskerWidth WRITE setWhiskerWidth)\par
6334   Q_PROPERTY({\cf18 double} symbolGap READ symbolGap WRITE setSymbolGap)\par
6336 {\cf17 public}:\par
6337   \par
6344   {\cf17 enum} ErrorType \{ etKeyError    \par
6345                    ,etValueError \par
6346   \};\par
6347   Q_ENUMS(ErrorType)\par
6348   \par
6349   explicit QCPErrorBars(QCPAxis *keyAxis, QCPAxis *valueAxis);\par
6350   virtual ~QCPErrorBars() Q_DECL_OVERRIDE;\par
6351   {\cf20 // getters:}\par
6352   QSharedPointer<QCPErrorBarsDataContainer> data(){\cf17  const }\{ {\cf19 return} mDataContainer; \}\par
6353   QCPAbstractPlottable *dataPlottable(){\cf17  const }\{ {\cf19 return} mDataPlottable.data(); \}\par
6354   ErrorType errorType(){\cf17  const }\{ {\cf19 return} mErrorType; \}\par
6355   {\cf18 double} whiskerWidth(){\cf17  const }\{ {\cf19 return} mWhiskerWidth; \}\par
6356   {\cf18 double} symbolGap(){\cf17  const }\{ {\cf19 return} mSymbolGap; \}\par
6357   \par
6358   {\cf20 // setters:}\par
6359   {\cf18 void} setData(QSharedPointer<QCPErrorBarsDataContainer> data);\par
6360   {\cf18 void} setData({\cf17 const} QVector<double> &error);\par
6361   {\cf18 void} setData({\cf17 const} QVector<double> &errorMinus, {\cf17 const} QVector<double> &errorPlus);\par
6362   {\cf18 void} setDataPlottable(QCPAbstractPlottable* plottable);\par
6363   {\cf18 void} setErrorType(ErrorType type);\par
6364   {\cf18 void} setWhiskerWidth({\cf18 double} pixels);\par
6365   {\cf18 void} setSymbolGap({\cf18 double} pixels);\par
6366   \par
6367   {\cf20 // non-property methods:}\par
6368   {\cf18 void} addData({\cf17 const} QVector<double> &error);\par
6369   {\cf18 void} addData({\cf17 const} QVector<double> &errorMinus, {\cf17 const} QVector<double> &errorPlus);\par
6370   {\cf18 void} addData({\cf18 double} error);\par
6371   {\cf18 void} addData({\cf18 double} errorMinus, {\cf18 double} errorPlus);\par
6372   \par
6373   {\cf20 // virtual methods of 1d plottable interface:}\par
6374   {\cf17 virtual} {\cf18 int} dataCount() const Q_DECL_OVERRIDE;\par
6375   virtual {\cf18 double} dataMainKey({\cf18 int} index) const Q_DECL_OVERRIDE;\par
6376   virtual {\cf18 double} dataSortKey({\cf18 int} index) const Q_DECL_OVERRIDE;\par
6377   virtual {\cf18 double} dataMainValue({\cf18 int} index) const Q_DECL_OVERRIDE;\par
6378   virtual QCPRange dataValueRange({\cf18 int} index) const Q_DECL_OVERRIDE;\par
6379   virtual QPointF dataPixelPosition({\cf18 int} index) const Q_DECL_OVERRIDE;\par
6380   virtual {\cf18 bool} sortKeyIsMainKey() const Q_DECL_OVERRIDE;\par
6381   virtual QCPDataSelection selectTestRect(const QRectF &rect, {\cf18 bool} onlySelectable) const Q_DECL_OVERRIDE;\par
6382   virtual {\cf18 int} findBegin({\cf18 double} sortKey, {\cf18 bool} expandedRange=true) const Q_DECL_OVERRIDE;\par
6383   virtual {\cf18 int} findEnd({\cf18 double} sortKey, {\cf18 bool} expandedRange=true) const Q_DECL_OVERRIDE;\par
6384   \par
6385   {\cf20 // reimplemented virtual methods:}\par
6386   virtual {\cf18 double} selectTest(const QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf18 nullptr}) const Q_DECL_OVERRIDE;\par
6387   virtual QCPPlottableInterface1D *interface1D() Q_DECL_OVERRIDE \{ {\cf19 return} {\cf17 this}; \}\par
6388   \par
6389 {\cf17 protected}:\par
6390   {\cf20 // property members:}\par
6391   QSharedPointer<QCPErrorBarsDataContainer> mDataContainer;\par
6392   QPointer<QCPAbstractPlottable> mDataPlottable;\par
6393   ErrorType mErrorType;\par
6394   {\cf18 double} mWhiskerWidth;\par
6395   {\cf18 double} mSymbolGap;\par
6396   \par
6397   {\cf20 // reimplemented virtual methods:}\par
6398   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
6399   {\cf17 virtual} {\cf18 void} drawLegendIcon(QCPPainter *painter, {\cf17 const} QRectF &rect) {\cf17 const} Q_DECL_OVERRIDE;\par
6400   {\cf17 virtual} QCPRange getKeyRange({\cf18 bool} &foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth) {\cf17 const} Q_DECL_OVERRIDE;\par
6401   {\cf17 virtual} QCPRange getValueRange({\cf18 bool} &foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth, {\cf17 const} QCPRange &inKeyRange=QCPRange()) const Q_DECL_OVERRIDE;\par
6402   \par
6403   {\cf20 // non-virtual methods:}\par
6404   {\cf18 void} getErrorBarLines(QCPErrorBarsDataContainer::const_iterator it, QVector<QLineF> &backbones, QVector<QLineF> &whiskers) const;\par
6405   {\cf18 void} getVisibleDataBounds(QCPErrorBarsDataContainer::const_iterator &begin, QCPErrorBarsDataContainer::const_iterator &end, const QCPDataRange &rangeRestriction) const;\par
6406   {\cf18 double} pointDistance(const QPointF &pixelPoint, QCPErrorBarsDataContainer::const_iterator &closestData) const;\par
6407   {\cf20 // helpers:}\par
6408   {\cf18 void} getDataSegments(QList<QCPDataRange> &selectedSegments, QList<QCPDataRange> &unselectedSegments) const;\par
6409   {\cf18 bool} errorBarVisible({\cf18 int} index) const;\par
6410   {\cf18 bool} rectIntersectsLine(const QRectF &pixelRect, const QLineF &line) const;\par
6411   \par
6412   friend class QCustomPlot;\par
6413   friend class QCPLegend;\par
6414 \};\par
6415 \par
6416 {\cf20 /* end of 'src/plottables/plottable-errorbar.h' */}\par
6417 \par
6418 \par
6419 {\cf20 /* including file 'src/items/item-straightline.h' */}\par
6420 {\cf20 /* modified 2022-11-06T12:45:56, size 3137        */}\par
6421 \par
6422 class QCP_LIB_DECL QCPItemStraightLine : public QCPAbstractItem\par
6423 \{\par
6424   Q_OBJECT\par
6426   Q_PROPERTY(QPen pen READ pen WRITE setPen)\par
6427   Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)\par
6429 {\cf17 public}:\par
6430   {\cf17 explicit} QCPItemStraightLine(QCustomPlot *parentPlot);\par
6431   {\cf17 virtual} ~QCPItemStraightLine() Q_DECL_OVERRIDE;\par
6432   \par
6433   {\cf20 // getters:}\par
6434   QPen pen(){\cf17  const }\{ {\cf19 return} mPen; \}\par
6435   QPen selectedPen(){\cf17  const }\{ {\cf19 return} mSelectedPen; \}\par
6436   \par
6437   {\cf20 // setters;}\par
6438   {\cf18 void} setPen({\cf17 const} QPen &pen);\par
6439   {\cf18 void} setSelectedPen({\cf17 const} QPen &pen);\par
6440   \par
6441   {\cf20 // reimplemented virtual methods:}\par
6442   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
6443   \par
6444   QCPItemPosition * const point1;\par
6445   QCPItemPosition * const point2;\par
6446   \par
6447 protected:\par
6448   {\cf20 // property members:}\par
6449   QPen mPen, mSelectedPen;\par
6450   \par
6451   {\cf20 // reimplemented virtual methods:}\par
6452   virtual {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
6453   \par
6454   {\cf20 // non-virtual methods:}\par
6455   QLineF getRectClippedStraightLine(const QCPVector2D &base, const QCPVector2D &vec, const QRect &rect) const;\par
6456   QPen mainPen() const;\par
6457 \};\par
6458 \par
6459 {\cf20 /* end of 'src/items/item-straightline.h' */}\par
6460 \par
6461 \par
6462 {\cf20 /* including file 'src/items/item-line.h'  */}\par
6463 {\cf20 /* modified 2022-11-06T12:45:56, size 3429 */}\par
6464 \par
6465 class QCP_LIB_DECL QCPItemLine : public QCPAbstractItem\par
6466 \{\par
6467   Q_OBJECT\par
6469   Q_PROPERTY(QPen pen READ pen WRITE setPen)\par
6470   Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)\par
6471   Q_PROPERTY(QCPLineEnding head READ head WRITE setHead)\par
6472   Q_PROPERTY(QCPLineEnding tail READ tail WRITE setTail)\par
6474 {\cf17 public}:\par
6475   {\cf17 explicit} QCPItemLine(QCustomPlot *parentPlot);\par
6476   {\cf17 virtual} ~QCPItemLine() Q_DECL_OVERRIDE;\par
6477   \par
6478   {\cf20 // getters:}\par
6479   QPen pen(){\cf17  const }\{ {\cf19 return} mPen; \}\par
6480   QPen selectedPen(){\cf17  const }\{ {\cf19 return} mSelectedPen; \}\par
6481   QCPLineEnding head(){\cf17  const }\{ {\cf19 return} mHead; \}\par
6482   QCPLineEnding tail(){\cf17  const }\{ {\cf19 return} mTail; \}\par
6483   \par
6484   {\cf20 // setters;}\par
6485   {\cf18 void} setPen({\cf17 const} QPen &pen);\par
6486   {\cf18 void} setSelectedPen({\cf17 const} QPen &pen);\par
6487   {\cf18 void} setHead({\cf17 const} QCPLineEnding &head);\par
6488   {\cf18 void} setTail({\cf17 const} QCPLineEnding &tail);\par
6489   \par
6490   {\cf20 // reimplemented virtual methods:}\par
6491   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
6492   \par
6493   QCPItemPosition * const start;\par
6494   QCPItemPosition * const end;\par
6495   \par
6496 protected:\par
6497   {\cf20 // property members:}\par
6498   QPen mPen, mSelectedPen;\par
6499   QCPLineEnding mHead, mTail;\par
6500   \par
6501   {\cf20 // reimplemented virtual methods:}\par
6502   virtual {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
6503   \par
6504   {\cf20 // non-virtual methods:}\par
6505   QLineF getRectClippedLine(const QCPVector2D &start, const QCPVector2D &end, const QRect &rect) const;\par
6506   QPen mainPen() const;\par
6507 \};\par
6508 \par
6509 {\cf20 /* end of 'src/items/item-line.h' */}\par
6510 \par
6511 \par
6512 {\cf20 /* including file 'src/items/item-curve.h' */}\par
6513 {\cf20 /* modified 2022-11-06T12:45:56, size 3401 */}\par
6514 \par
6515 class QCP_LIB_DECL QCPItemCurve : public QCPAbstractItem\par
6516 \{\par
6517   Q_OBJECT\par
6519   Q_PROPERTY(QPen pen READ pen WRITE setPen)\par
6520   Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)\par
6521   Q_PROPERTY(QCPLineEnding head READ head WRITE setHead)\par
6522   Q_PROPERTY(QCPLineEnding tail READ tail WRITE setTail)\par
6524 {\cf17 public}:\par
6525   {\cf17 explicit} QCPItemCurve(QCustomPlot *parentPlot);\par
6526   {\cf17 virtual} ~QCPItemCurve() Q_DECL_OVERRIDE;\par
6527   \par
6528   {\cf20 // getters:}\par
6529   QPen pen(){\cf17  const }\{ {\cf19 return} mPen; \}\par
6530   QPen selectedPen(){\cf17  const }\{ {\cf19 return} mSelectedPen; \}\par
6531   QCPLineEnding head(){\cf17  const }\{ {\cf19 return} mHead; \}\par
6532   QCPLineEnding tail(){\cf17  const }\{ {\cf19 return} mTail; \}\par
6533   \par
6534   {\cf20 // setters;}\par
6535   {\cf18 void} setPen({\cf17 const} QPen &pen);\par
6536   {\cf18 void} setSelectedPen({\cf17 const} QPen &pen);\par
6537   {\cf18 void} setHead({\cf17 const} QCPLineEnding &head);\par
6538   {\cf18 void} setTail({\cf17 const} QCPLineEnding &tail);\par
6539   \par
6540   {\cf20 // reimplemented virtual methods:}\par
6541   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
6542   \par
6543   QCPItemPosition * const start;\par
6544   QCPItemPosition * const startDir;\par
6545   QCPItemPosition * const endDir;\par
6546   QCPItemPosition * const end;\par
6547   \par
6548 protected:\par
6549   {\cf20 // property members:}\par
6550   QPen mPen, mSelectedPen;\par
6551   QCPLineEnding mHead, mTail;\par
6552   \par
6553   {\cf20 // reimplemented virtual methods:}\par
6554   virtual {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
6555   \par
6556   {\cf20 // non-virtual methods:}\par
6557   QPen mainPen() const;\par
6558 \};\par
6559 \par
6560 {\cf20 /* end of 'src/items/item-curve.h' */}\par
6561 \par
6562 \par
6563 {\cf20 /* including file 'src/items/item-rect.h'  */}\par
6564 {\cf20 /* modified 2022-11-06T12:45:56, size 3710 */}\par
6565 \par
6566 class QCP_LIB_DECL QCPItemRect : public QCPAbstractItem\par
6567 \{\par
6568   Q_OBJECT\par
6570   Q_PROPERTY(QPen pen READ pen WRITE setPen)\par
6571   Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)\par
6572   Q_PROPERTY(QBrush brush READ brush WRITE setBrush)\par
6573   Q_PROPERTY(QBrush selectedBrush READ selectedBrush WRITE setSelectedBrush)\par
6575 {\cf17 public}:\par
6576   {\cf17 explicit} QCPItemRect(QCustomPlot *parentPlot);\par
6577   {\cf17 virtual} ~QCPItemRect() Q_DECL_OVERRIDE;\par
6578   \par
6579   {\cf20 // getters:}\par
6580   QPen pen(){\cf17  const }\{ {\cf19 return} mPen; \}\par
6581   QPen selectedPen(){\cf17  const }\{ {\cf19 return} mSelectedPen; \}\par
6582   QBrush brush(){\cf17  const }\{ {\cf19 return} mBrush; \}\par
6583   QBrush selectedBrush(){\cf17  const }\{ {\cf19 return} mSelectedBrush; \}\par
6584   \par
6585   {\cf20 // setters;}\par
6586   {\cf18 void} setPen({\cf17 const} QPen &pen);\par
6587   {\cf18 void} setSelectedPen({\cf17 const} QPen &pen);\par
6588   {\cf18 void} setBrush({\cf17 const} QBrush &brush);\par
6589   {\cf18 void} setSelectedBrush({\cf17 const} QBrush &brush);\par
6590   \par
6591   {\cf20 // reimplemented virtual methods:}\par
6592   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
6593   \par
6594   QCPItemPosition * const topLeft;\par
6595   QCPItemPosition * const bottomRight;\par
6596   QCPItemAnchor * const top;\par
6597   QCPItemAnchor * const topRight;\par
6598   QCPItemAnchor * const right;\par
6599   QCPItemAnchor * const bottom;\par
6600   QCPItemAnchor * const bottomLeft;\par
6601   QCPItemAnchor * const left;\par
6602   \par
6603 protected:\par
6604   enum AnchorIndex \{aiTop, aiTopRight, aiRight, aiBottom, aiBottomLeft, aiLeft\};\par
6605   \par
6606   {\cf20 // property members:}\par
6607   QPen mPen, mSelectedPen;\par
6608   QBrush mBrush, mSelectedBrush;\par
6609   \par
6610   {\cf20 // reimplemented virtual methods:}\par
6611   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
6612   {\cf17 virtual} QPointF anchorPixelPosition({\cf18 int} anchorId) {\cf17 const} Q_DECL_OVERRIDE;\par
6613   \par
6614   {\cf20 // non-virtual methods:}\par
6615   QPen mainPen() {\cf17 const};\par
6616   QBrush mainBrush() {\cf17 const};\par
6617 \};\par
6618 \par
6619 {\cf20 /* end of 'src/items/item-rect.h' */}\par
6620 \par
6621 \par
6622 {\cf20 /* including file 'src/items/item-text.h'  */}\par
6623 {\cf20 /* modified 2022-11-06T12:45:56, size 5576 */}\par
6624 \par
6625 {\cf17 class }QCP_LIB_DECL QCPItemText : {\cf17 public} QCPAbstractItem\par
6626 \{\par
6627   Q_OBJECT\par
6629   Q_PROPERTY(QColor color READ color WRITE setColor)\par
6630   Q_PROPERTY(QColor selectedColor READ selectedColor WRITE setSelectedColor)\par
6631   Q_PROPERTY(QPen pen READ pen WRITE setPen)\par
6632   Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)\par
6633   Q_PROPERTY(QBrush brush READ brush WRITE setBrush)\par
6634   Q_PROPERTY(QBrush selectedBrush READ selectedBrush WRITE setSelectedBrush)\par
6635   Q_PROPERTY(QFont font READ font WRITE setFont)\par
6636   Q_PROPERTY(QFont selectedFont READ selectedFont WRITE setSelectedFont)\par
6637   Q_PROPERTY(QString text READ text WRITE setText)\par
6638   Q_PROPERTY(Qt::Alignment positionAlignment READ positionAlignment WRITE setPositionAlignment)\par
6639   Q_PROPERTY(Qt::Alignment textAlignment READ textAlignment WRITE setTextAlignment)\par
6640   Q_PROPERTY({\cf18 double} rotation READ rotation WRITE setRotation)\par
6641   Q_PROPERTY(QMargins padding READ padding WRITE setPadding)\par
6643 {\cf17 public}:\par
6644   {\cf17 explicit} QCPItemText(QCustomPlot *parentPlot);\par
6645   {\cf17 virtual} ~QCPItemText() Q_DECL_OVERRIDE;\par
6646   \par
6647   {\cf20 // getters:}\par
6648   QColor color(){\cf17  const }\{ {\cf19 return} mColor; \}\par
6649   QColor selectedColor(){\cf17  const }\{ {\cf19 return} mSelectedColor; \}\par
6650   QPen pen(){\cf17  const }\{ {\cf19 return} mPen; \}\par
6651   QPen selectedPen(){\cf17  const }\{ {\cf19 return} mSelectedPen; \}\par
6652   QBrush brush(){\cf17  const }\{ {\cf19 return} mBrush; \}\par
6653   QBrush selectedBrush(){\cf17  const }\{ {\cf19 return} mSelectedBrush; \}\par
6654   QFont font(){\cf17  const }\{ {\cf19 return} mFont; \}\par
6655   QFont selectedFont(){\cf17  const }\{ {\cf19 return} mSelectedFont; \}\par
6656   QString text(){\cf17  const }\{ {\cf19 return} mText; \}\par
6657   Qt::Alignment positionAlignment(){\cf17  const }\{ {\cf19 return} mPositionAlignment; \}\par
6658   Qt::Alignment textAlignment(){\cf17  const }\{ {\cf19 return} mTextAlignment; \}\par
6659   {\cf18 double} rotation(){\cf17  const }\{ {\cf19 return} mRotation; \}\par
6660   QMargins padding(){\cf17  const }\{ {\cf19 return} mPadding; \}\par
6661   \par
6662   {\cf20 // setters;}\par
6663   {\cf18 void} setColor({\cf17 const} QColor &color);\par
6664   {\cf18 void} setSelectedColor({\cf17 const} QColor &color);\par
6665   {\cf18 void} setPen({\cf17 const} QPen &pen);\par
6666   {\cf18 void} setSelectedPen({\cf17 const} QPen &pen);\par
6667   {\cf18 void} setBrush({\cf17 const} QBrush &brush);\par
6668   {\cf18 void} setSelectedBrush({\cf17 const} QBrush &brush);\par
6669   {\cf18 void} setFont({\cf17 const} QFont &font);\par
6670   {\cf18 void} setSelectedFont({\cf17 const} QFont &font);\par
6671   {\cf18 void} setText({\cf17 const} QString &text);\par
6672   {\cf18 void} setPositionAlignment(Qt::Alignment alignment);\par
6673   {\cf18 void} setTextAlignment(Qt::Alignment alignment);\par
6674   {\cf18 void} setRotation({\cf18 double} degrees);\par
6675   {\cf18 void} setPadding({\cf17 const} QMargins &padding);\par
6676   \par
6677   {\cf20 // reimplemented virtual methods:}\par
6678   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
6679   \par
6680   QCPItemPosition * const position;\par
6681   QCPItemAnchor * const topLeft;\par
6682   QCPItemAnchor * const top;\par
6683   QCPItemAnchor * const topRight;\par
6684   QCPItemAnchor * const right;\par
6685   QCPItemAnchor * const bottomRight;\par
6686   QCPItemAnchor * const bottom;\par
6687   QCPItemAnchor * const bottomLeft;\par
6688   QCPItemAnchor * const left;\par
6689   \par
6690 protected:\par
6691   enum AnchorIndex \{aiTopLeft, aiTop, aiTopRight, aiRight, aiBottomRight, aiBottom, aiBottomLeft, aiLeft\};\par
6692   \par
6693   {\cf20 // property members:}\par
6694   QColor mColor, mSelectedColor;\par
6695   QPen mPen, mSelectedPen;\par
6696   QBrush mBrush, mSelectedBrush;\par
6697   QFont mFont, mSelectedFont;\par
6698   QString mText;\par
6699   Qt::Alignment mPositionAlignment;\par
6700   Qt::Alignment mTextAlignment;\par
6701   {\cf18 double} mRotation;\par
6702   QMargins mPadding;\par
6703   \par
6704   {\cf20 // reimplemented virtual methods:}\par
6705   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
6706   {\cf17 virtual} QPointF anchorPixelPosition({\cf18 int} anchorId) {\cf17 const} Q_DECL_OVERRIDE;\par
6707   \par
6708   {\cf20 // non-virtual methods:}\par
6709   QPointF getTextDrawPoint({\cf17 const} QPointF &pos, {\cf17 const} QRectF &rect, Qt::Alignment positionAlignment) {\cf17 const};\par
6710   QFont mainFont() {\cf17 const};\par
6711   QColor mainColor() {\cf17 const};\par
6712   QPen mainPen() {\cf17 const};\par
6713   QBrush mainBrush() {\cf17 const};\par
6714 \};\par
6715 \par
6716 {\cf20 /* end of 'src/items/item-text.h' */}\par
6717 \par
6718 \par
6719 {\cf20 /* including file 'src/items/item-ellipse.h' */}\par
6720 {\cf20 /* modified 2022-11-06T12:45:56, size 3890   */}\par
6721 \par
6722 {\cf17 class }QCP_LIB_DECL QCPItemEllipse : {\cf17 public} QCPAbstractItem\par
6723 \{\par
6724   Q_OBJECT\par
6726   Q_PROPERTY(QPen pen READ pen WRITE setPen)\par
6727   Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)\par
6728   Q_PROPERTY(QBrush brush READ brush WRITE setBrush)\par
6729   Q_PROPERTY(QBrush selectedBrush READ selectedBrush WRITE setSelectedBrush)\par
6731 {\cf17 public}:\par
6732   {\cf17 explicit} QCPItemEllipse(QCustomPlot *parentPlot);\par
6733   {\cf17 virtual} ~QCPItemEllipse() Q_DECL_OVERRIDE;\par
6734   \par
6735   {\cf20 // getters:}\par
6736   QPen pen(){\cf17  const }\{ {\cf19 return} mPen; \}\par
6737   QPen selectedPen(){\cf17  const }\{ {\cf19 return} mSelectedPen; \}\par
6738   QBrush brush(){\cf17  const }\{ {\cf19 return} mBrush; \}\par
6739   QBrush selectedBrush(){\cf17  const }\{ {\cf19 return} mSelectedBrush; \}\par
6740   \par
6741   {\cf20 // setters;}\par
6742   {\cf18 void} setPen({\cf17 const} QPen &pen);\par
6743   {\cf18 void} setSelectedPen({\cf17 const} QPen &pen);\par
6744   {\cf18 void} setBrush({\cf17 const} QBrush &brush);\par
6745   {\cf18 void} setSelectedBrush({\cf17 const} QBrush &brush);\par
6746   \par
6747   {\cf20 // reimplemented virtual methods:}\par
6748   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
6749   \par
6750   QCPItemPosition * const topLeft;\par
6751   QCPItemPosition * const bottomRight;\par
6752   QCPItemAnchor * const topLeftRim;\par
6753   QCPItemAnchor * const top;\par
6754   QCPItemAnchor * const topRightRim;\par
6755   QCPItemAnchor * const right;\par
6756   QCPItemAnchor * const bottomRightRim;\par
6757   QCPItemAnchor * const bottom;\par
6758   QCPItemAnchor * const bottomLeftRim;\par
6759   QCPItemAnchor * const left;\par
6760   QCPItemAnchor * const center;\par
6761   \par
6762 protected:\par
6763   enum AnchorIndex \{aiTopLeftRim, aiTop, aiTopRightRim, aiRight, aiBottomRightRim, aiBottom, aiBottomLeftRim, aiLeft, aiCenter\};\par
6764   \par
6765   {\cf20 // property members:}\par
6766   QPen mPen, mSelectedPen;\par
6767   QBrush mBrush, mSelectedBrush;\par
6768   \par
6769   {\cf20 // reimplemented virtual methods:}\par
6770   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
6771   {\cf17 virtual} QPointF anchorPixelPosition({\cf18 int} anchorId) {\cf17 const} Q_DECL_OVERRIDE;\par
6772   \par
6773   {\cf20 // non-virtual methods:}\par
6774   QPen mainPen() {\cf17 const};\par
6775   QBrush mainBrush() {\cf17 const};\par
6776 \};\par
6777 \par
6778 {\cf20 /* end of 'src/items/item-ellipse.h' */}\par
6779 \par
6780 \par
6781 {\cf20 /* including file 'src/items/item-pixmap.h' */}\par
6782 {\cf20 /* modified 2022-11-06T12:45:56, size 4407  */}\par
6783 \par
6784 {\cf17 class }QCP_LIB_DECL QCPItemPixmap : {\cf17 public} QCPAbstractItem\par
6785 \{\par
6786   Q_OBJECT\par
6788   Q_PROPERTY(QPixmap pixmap READ pixmap WRITE setPixmap)\par
6789   Q_PROPERTY({\cf18 bool} scaled READ scaled WRITE setScaled)\par
6790   Q_PROPERTY(Qt::AspectRatioMode aspectRatioMode READ aspectRatioMode)\par
6791   Q_PROPERTY(Qt::TransformationMode transformationMode READ transformationMode)\par
6792   Q_PROPERTY(QPen pen READ pen WRITE setPen)\par
6793   Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)\par
6795 {\cf17 public}:\par
6796   {\cf17 explicit} QCPItemPixmap(QCustomPlot *parentPlot);\par
6797   {\cf17 virtual} ~QCPItemPixmap() Q_DECL_OVERRIDE;\par
6798   \par
6799   {\cf20 // getters:}\par
6800   QPixmap pixmap(){\cf17  const }\{ {\cf19 return} mPixmap; \}\par
6801   {\cf18 bool} scaled(){\cf17  const }\{ {\cf19 return} mScaled; \}\par
6802   Qt::AspectRatioMode aspectRatioMode(){\cf17  const }\{ {\cf19 return} mAspectRatioMode; \}\par
6803   Qt::TransformationMode transformationMode(){\cf17  const }\{ {\cf19 return} mTransformationMode; \}\par
6804   QPen pen(){\cf17  const }\{ {\cf19 return} mPen; \}\par
6805   QPen selectedPen(){\cf17  const }\{ {\cf19 return} mSelectedPen; \}\par
6806   \par
6807   {\cf20 // setters;}\par
6808   {\cf18 void} setPixmap({\cf17 const} QPixmap &pixmap);\par
6809   {\cf18 void} setScaled({\cf18 bool} scaled, Qt::AspectRatioMode aspectRatioMode=Qt::KeepAspectRatio, Qt::TransformationMode transformationMode=Qt::SmoothTransformation);\par
6810   {\cf18 void} setPen({\cf17 const} QPen &pen);\par
6811   {\cf18 void} setSelectedPen({\cf17 const} QPen &pen);\par
6812   \par
6813   {\cf20 // reimplemented virtual methods:}\par
6814   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
6815   \par
6816   QCPItemPosition * const topLeft;\par
6817   QCPItemPosition * const bottomRight;\par
6818   QCPItemAnchor * const top;\par
6819   QCPItemAnchor * const topRight;\par
6820   QCPItemAnchor * const right;\par
6821   QCPItemAnchor * const bottom;\par
6822   QCPItemAnchor * const bottomLeft;\par
6823   QCPItemAnchor * const left;\par
6824   \par
6825 protected:\par
6826   enum AnchorIndex \{aiTop, aiTopRight, aiRight, aiBottom, aiBottomLeft, aiLeft\};\par
6827   \par
6828   {\cf20 // property members:}\par
6829   QPixmap mPixmap;\par
6830   QPixmap mScaledPixmap;\par
6831   {\cf18 bool} mScaled;\par
6832   {\cf18 bool} mScaledPixmapInvalidated;\par
6833   Qt::AspectRatioMode mAspectRatioMode;\par
6834   Qt::TransformationMode mTransformationMode;\par
6835   QPen mPen, mSelectedPen;\par
6836   \par
6837   {\cf20 // reimplemented virtual methods:}\par
6838   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
6839   {\cf17 virtual} QPointF anchorPixelPosition({\cf18 int} anchorId) {\cf17 const} Q_DECL_OVERRIDE;\par
6840   \par
6841   {\cf20 // non-virtual methods:}\par
6842   {\cf18 void} updateScaledPixmap(QRect finalRect=QRect(), {\cf18 bool} flipHorz={\cf17 false}, {\cf18 bool} flipVert={\cf17 false});\par
6843   QRect getFinalRect({\cf18 bool} *flippedHorz={\cf17 nullptr}, {\cf18 bool} *flippedVert={\cf17 nullptr}) {\cf17 const};\par
6844   QPen mainPen() {\cf17 const};\par
6845 \};\par
6846 \par
6847 {\cf20 /* end of 'src/items/item-pixmap.h' */}\par
6848 \par
6849 \par
6850 {\cf20 /* including file 'src/items/item-tracer.h' */}\par
6851 {\cf20 /* modified 2022-11-06T12:45:56, size 4811  */}\par
6852 \par
6853 {\cf17 class }QCP_LIB_DECL QCPItemTracer : {\cf17 public} QCPAbstractItem\par
6854 \{\par
6855   Q_OBJECT\par
6857   Q_PROPERTY(QPen pen READ pen WRITE setPen)\par
6858   Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)\par
6859   Q_PROPERTY(QBrush brush READ brush WRITE setBrush)\par
6860   Q_PROPERTY(QBrush selectedBrush READ selectedBrush WRITE setSelectedBrush)\par
6861   Q_PROPERTY({\cf18 double} size READ size WRITE setSize)\par
6862   Q_PROPERTY(TracerStyle style READ style WRITE setStyle)\par
6863   Q_PROPERTY(QCPGraph* graph READ graph WRITE setGraph)\par
6864   Q_PROPERTY({\cf18 double} graphKey READ graphKey WRITE setGraphKey)\par
6865   Q_PROPERTY({\cf18 bool} interpolating READ interpolating WRITE setInterpolating)\par
6867 {\cf17 public}:\par
6873   {\cf17 enum} TracerStyle \{ tsNone        \par
6874                      ,tsPlus       \par
6875                      ,tsCrosshair  \par
6876                      ,tsCircle     \par
6877                      ,tsSquare     \par
6878                    \};\par
6879   Q_ENUMS(TracerStyle)\par
6880 \par
6881   explicit QCPItemTracer(QCustomPlot *parentPlot);\par
6882   virtual ~QCPItemTracer() Q_DECL_OVERRIDE;\par
6883 \par
6884   {\cf20 // getters:}\par
6885   QPen pen(){\cf17  const }\{ {\cf19 return} mPen; \}\par
6886   QPen selectedPen(){\cf17  const }\{ {\cf19 return} mSelectedPen; \}\par
6887   QBrush brush(){\cf17  const }\{ {\cf19 return} mBrush; \}\par
6888   QBrush selectedBrush(){\cf17  const }\{ {\cf19 return} mSelectedBrush; \}\par
6889   {\cf18 double} size(){\cf17  const }\{ {\cf19 return} mSize; \}\par
6890   TracerStyle style(){\cf17  const }\{ {\cf19 return} mStyle; \}\par
6891   QCPGraph *graph(){\cf17  const }\{ {\cf19 return} mGraph; \}\par
6892   {\cf18 double} graphKey(){\cf17  const }\{ {\cf19 return} mGraphKey; \}\par
6893   {\cf18 bool} interpolating(){\cf17  const }\{ {\cf19 return} mInterpolating; \}\par
6894 \par
6895   {\cf20 // setters;}\par
6896   {\cf18 void} setPen({\cf17 const} QPen &pen);\par
6897   {\cf18 void} setSelectedPen({\cf17 const} QPen &pen);\par
6898   {\cf18 void} setBrush({\cf17 const} QBrush &brush);\par
6899   {\cf18 void} setSelectedBrush({\cf17 const} QBrush &brush);\par
6900   {\cf18 void} setSize({\cf18 double} size);\par
6901   {\cf18 void} setStyle(TracerStyle style);\par
6902   {\cf18 void} setGraph(QCPGraph *graph);\par
6903   {\cf18 void} setGraphKey({\cf18 double} key);\par
6904   {\cf18 void} setInterpolating({\cf18 bool} enabled);\par
6905 \par
6906   {\cf20 // reimplemented virtual methods:}\par
6907   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
6908   \par
6909   {\cf20 // non-virtual methods:}\par
6910   {\cf18 void} updatePosition();\par
6911 \par
6912   QCPItemPosition * const position;\par
6913 \par
6914 protected:\par
6915   {\cf20 // property members:}\par
6916   QPen mPen, mSelectedPen;\par
6917   QBrush mBrush, mSelectedBrush;\par
6918   {\cf18 double} mSize;\par
6919   TracerStyle mStyle;\par
6920   QCPGraph *mGraph;\par
6921   {\cf18 double} mGraphKey;\par
6922   {\cf18 bool} mInterpolating;\par
6923 \par
6924   {\cf20 // reimplemented virtual methods:}\par
6925   virtual {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
6926 \par
6927   {\cf20 // non-virtual methods:}\par
6928   QPen mainPen() const;\par
6929   QBrush mainBrush() const;\par
6930 \};\par
6931 Q_DECLARE_METATYPE(QCPItemTracer::TracerStyle)\par
6932 \par
6933 {\cf20 /* end of 'src/items/item-tracer.h' */}\par
6934 \par
6935 \par
6936 {\cf20 /* including file 'src/items/item-bracket.h' */}\par
6937 {\cf20 /* modified 2022-11-06T12:45:56, size 3991   */}\par
6938 \par
6939 class QCP_LIB_DECL QCPItemBracket : public QCPAbstractItem\par
6940 \{\par
6941   Q_OBJECT\par
6943   Q_PROPERTY(QPen pen READ pen WRITE setPen)\par
6944   Q_PROPERTY(QPen selectedPen READ selectedPen WRITE setSelectedPen)\par
6945   Q_PROPERTY({\cf18 double} length READ length WRITE setLength)\par
6946   Q_PROPERTY(BracketStyle style READ style WRITE setStyle)\par
6948 {\cf17 public}:\par
6955   {\cf17 enum} BracketStyle \{ bsSquare  \par
6956                       ,bsRound  \par
6957                       ,bsCurly  \par
6958                       ,bsCalligraphic \par
6959   \};\par
6960   Q_ENUMS(BracketStyle)\par
6961 \par
6962   explicit QCPItemBracket(QCustomPlot *parentPlot);\par
6963   virtual ~QCPItemBracket() Q_DECL_OVERRIDE;\par
6964   \par
6965   {\cf20 // getters:}\par
6966   QPen pen(){\cf17  const }\{ {\cf19 return} mPen; \}\par
6967   QPen selectedPen(){\cf17  const }\{ {\cf19 return} mSelectedPen; \}\par
6968   {\cf18 double} length(){\cf17  const }\{ {\cf19 return} mLength; \}\par
6969   BracketStyle style(){\cf17  const }\{ {\cf19 return} mStyle; \}\par
6970   \par
6971   {\cf20 // setters;}\par
6972   {\cf18 void} setPen({\cf17 const} QPen &pen);\par
6973   {\cf18 void} setSelectedPen({\cf17 const} QPen &pen);\par
6974   {\cf18 void} setLength({\cf18 double} length);\par
6975   {\cf18 void} setStyle(BracketStyle style);\par
6976   \par
6977   {\cf20 // reimplemented virtual methods:}\par
6978   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details={\cf17 nullptr}) const Q_DECL_OVERRIDE;\par
6979   \par
6980   QCPItemPosition * const left;\par
6981   QCPItemPosition * const right;\par
6982   QCPItemAnchor * const center;\par
6983   \par
6984 protected:\par
6985   {\cf20 // property members:}\par
6986   enum AnchorIndex \{aiCenter\};\par
6987   QPen mPen, mSelectedPen;\par
6988   {\cf18 double} mLength;\par
6989   BracketStyle mStyle;\par
6990   \par
6991   {\cf20 // reimplemented virtual methods:}\par
6992   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
6993   {\cf17 virtual} QPointF anchorPixelPosition({\cf18 int} anchorId) {\cf17 const} Q_DECL_OVERRIDE;\par
6994   \par
6995   {\cf20 // non-virtual methods:}\par
6996   QPen mainPen() {\cf17 const};\par
6997 \};\par
6998 Q_DECLARE_METATYPE(QCPItemBracket::BracketStyle)\par
6999 \par
7000 {\cf20 /* end of 'src/items/item-bracket.h' */}\par
7001 \par
7002 \par
7003 {\cf20 /* including file 'src/polar/radialaxis.h'  */}\par
7004 {\cf20 /* modified 2022-11-06T12:45:56, size 12227 */}\par
7005 \par
7006 \par
7007 class QCP_LIB_DECL QCPPolarAxisRadial : public QCPLayerable\par
7008 \{\par
7009   Q_OBJECT\par
7011   \par
7013 {\cf17 public}:\par
7017   {\cf17 enum} AngleReference \{ arAbsolute    \par
7018                        ,arAngularAxis \par
7019                       \};\par
7020   Q_ENUMS(AngleReference)\par
7025   enum ScaleType \{ stLinear       \par
7026                    ,stLogarithmic \par
7027                  \};\par
7028   Q_ENUMS(ScaleType)\par
7033   enum SelectablePart \{ spNone        = 0      \par
7034                         ,spAxis       = 0x001  \par
7035                         ,spTickLabels = 0x002  \par
7036                         ,spAxisLabel  = 0x004  \par
7037                       \};\par
7038   Q_ENUMS(SelectablePart)\par
7039   Q_FLAGS(SelectableParts)\par
7040   Q_DECLARE_FLAGS(SelectableParts, SelectablePart)\par
7041   \par
7042   enum LabelMode \{ lmUpright   \par
7043                    ,lmRotated \par
7044                  \};\par
7045   Q_ENUMS(LabelMode)\par
7046   \par
7047   explicit QCPPolarAxisRadial(QCPPolarAxisAngular *parent);\par
7048   virtual ~QCPPolarAxisRadial();\par
7049   \par
7050   {\cf20 // getters:}\par
7051   {\cf18 bool} rangeDrag(){\cf17  const }\{ {\cf19 return} mRangeDrag; \}\par
7052   {\cf18 bool} rangeZoom(){\cf17  const }\{ {\cf19 return} mRangeZoom; \}\par
7053   {\cf18 double} rangeZoomFactor(){\cf17  const }\{ {\cf19 return} mRangeZoomFactor; \}\par
7054   \par
7055   QCPPolarAxisAngular *angularAxis(){\cf17  const }\{ {\cf19 return} mAngularAxis; \}\par
7056   ScaleType scaleType(){\cf17  const }\{ {\cf19 return} mScaleType; \}\par
7057   {\cf17 const} QCPRange range(){\cf17  const }\{ {\cf19 return} mRange; \}\par
7058   {\cf18 bool} rangeReversed(){\cf17  const }\{ {\cf19 return} mRangeReversed; \}\par
7059   {\cf18 double} angle(){\cf17  const }\{ {\cf19 return} mAngle; \}\par
7060   AngleReference angleReference(){\cf17  const }\{ {\cf19 return} mAngleReference; \}\par
7061   QSharedPointer<QCPAxisTicker> ticker(){\cf17  const }\{ {\cf19 return} mTicker; \}\par
7062   {\cf18 bool} ticks(){\cf17  const }\{ {\cf19 return} mTicks; \}\par
7063   {\cf18 bool} tickLabels(){\cf17  const }\{ {\cf19 return} mTickLabels; \}\par
7064   {\cf18 int} tickLabelPadding(){\cf17  const }\{ {\cf19 return} mLabelPainter.padding(); \}\par
7065   QFont tickLabelFont(){\cf17  const }\{ {\cf19 return} mTickLabelFont; \}\par
7066   QColor tickLabelColor(){\cf17  const }\{ {\cf19 return} mTickLabelColor; \}\par
7067   {\cf18 double} tickLabelRotation(){\cf17  const }\{ {\cf19 return} mLabelPainter.rotation(); \}\par
7068   LabelMode tickLabelMode() {\cf17 const};\par
7069   QString numberFormat() {\cf17 const};\par
7070   {\cf18 int} numberPrecision(){\cf17  const }\{ {\cf19 return} mNumberPrecision; \}\par
7071   QVector<double> tickVector(){\cf17  const }\{ {\cf19 return} mTickVector; \}\par
7072   QVector<double> subTickVector(){\cf17  const }\{ {\cf19 return} mSubTickVector; \}\par
7073   QVector<QString> tickVectorLabels(){\cf17  const }\{ {\cf19 return} mTickVectorLabels; \}\par
7074   {\cf18 int} tickLengthIn() {\cf17 const};\par
7075   {\cf18 int} tickLengthOut() {\cf17 const};\par
7076   {\cf18 bool} subTicks(){\cf17  const }\{ {\cf19 return} mSubTicks; \}\par
7077   {\cf18 int} subTickLengthIn() {\cf17 const};\par
7078   {\cf18 int} subTickLengthOut() {\cf17 const};\par
7079   QPen basePen(){\cf17  const }\{ {\cf19 return} mBasePen; \}\par
7080   QPen tickPen(){\cf17  const }\{ {\cf19 return} mTickPen; \}\par
7081   QPen subTickPen(){\cf17  const }\{ {\cf19 return} mSubTickPen; \}\par
7082   QFont labelFont(){\cf17  const }\{ {\cf19 return} mLabelFont; \}\par
7083   QColor labelColor(){\cf17  const }\{ {\cf19 return} mLabelColor; \}\par
7084   QString label(){\cf17  const }\{ {\cf19 return} mLabel; \}\par
7085   {\cf18 int} labelPadding() {\cf17 const};\par
7086   SelectableParts selectedParts(){\cf17  const }\{ {\cf19 return} mSelectedParts; \}\par
7087   SelectableParts selectableParts(){\cf17  const }\{ {\cf19 return} mSelectableParts; \}\par
7088   QFont selectedTickLabelFont(){\cf17  const }\{ {\cf19 return} mSelectedTickLabelFont; \}\par
7089   QFont selectedLabelFont(){\cf17  const }\{ {\cf19 return} mSelectedLabelFont; \}\par
7090   QColor selectedTickLabelColor(){\cf17  const }\{ {\cf19 return} mSelectedTickLabelColor; \}\par
7091   QColor selectedLabelColor(){\cf17  const }\{ {\cf19 return} mSelectedLabelColor; \}\par
7092   QPen selectedBasePen(){\cf17  const }\{ {\cf19 return} mSelectedBasePen; \}\par
7093   QPen selectedTickPen(){\cf17  const }\{ {\cf19 return} mSelectedTickPen; \}\par
7094   QPen selectedSubTickPen(){\cf17  const }\{ {\cf19 return} mSelectedSubTickPen; \}\par
7095   \par
7096   {\cf20 // setters:}\par
7097   {\cf18 void} setRangeDrag({\cf18 bool} enabled);\par
7098   {\cf18 void} setRangeZoom({\cf18 bool} enabled);\par
7099   {\cf18 void} setRangeZoomFactor({\cf18 double} factor);\par
7100   \par
7101   Q_SLOT {\cf18 void} setScaleType(QCPPolarAxisRadial::ScaleType type);\par
7102   Q_SLOT {\cf18 void} setRange({\cf17 const} QCPRange &range);\par
7103   {\cf18 void} setRange({\cf18 double} lower, {\cf18 double} upper);\par
7104   {\cf18 void} setRange({\cf18 double} position, {\cf18 double} size, Qt::AlignmentFlag alignment);\par
7105   {\cf18 void} setRangeLower({\cf18 double} lower);\par
7106   {\cf18 void} setRangeUpper({\cf18 double} upper);\par
7107   {\cf18 void} setRangeReversed({\cf18 bool} reversed);\par
7108   {\cf18 void} setAngle({\cf18 double} degrees);\par
7109   {\cf18 void} setAngleReference(AngleReference reference);\par
7110   {\cf18 void} setTicker(QSharedPointer<QCPAxisTicker> ticker);\par
7111   {\cf18 void} setTicks({\cf18 bool} show);\par
7112   {\cf18 void} setTickLabels({\cf18 bool} show);\par
7113   {\cf18 void} setTickLabelPadding({\cf18 int} padding);\par
7114   {\cf18 void} setTickLabelFont({\cf17 const} QFont &font);\par
7115   {\cf18 void} setTickLabelColor({\cf17 const} QColor &color);\par
7116   {\cf18 void} setTickLabelRotation({\cf18 double} degrees);\par
7117   {\cf18 void} setTickLabelMode(LabelMode mode);\par
7118   {\cf18 void} setNumberFormat({\cf17 const} QString &formatCode);\par
7119   {\cf18 void} setNumberPrecision({\cf18 int} precision);\par
7120   {\cf18 void} setTickLength({\cf18 int} inside, {\cf18 int} outside=0);\par
7121   {\cf18 void} setTickLengthIn({\cf18 int} inside);\par
7122   {\cf18 void} setTickLengthOut({\cf18 int} outside);\par
7123   {\cf18 void} setSubTicks({\cf18 bool} show);\par
7124   {\cf18 void} setSubTickLength({\cf18 int} inside, {\cf18 int} outside=0);\par
7125   {\cf18 void} setSubTickLengthIn({\cf18 int} inside);\par
7126   {\cf18 void} setSubTickLengthOut({\cf18 int} outside);\par
7127   {\cf18 void} setBasePen({\cf17 const} QPen &pen);\par
7128   {\cf18 void} setTickPen({\cf17 const} QPen &pen);\par
7129   {\cf18 void} setSubTickPen({\cf17 const} QPen &pen);\par
7130   {\cf18 void} setLabelFont({\cf17 const} QFont &font);\par
7131   {\cf18 void} setLabelColor({\cf17 const} QColor &color);\par
7132   {\cf18 void} setLabel({\cf17 const} QString &str);\par
7133   {\cf18 void} setLabelPadding({\cf18 int} padding);\par
7134   {\cf18 void} setSelectedTickLabelFont({\cf17 const} QFont &font);\par
7135   {\cf18 void} setSelectedLabelFont({\cf17 const} QFont &font);\par
7136   {\cf18 void} setSelectedTickLabelColor({\cf17 const} QColor &color);\par
7137   {\cf18 void} setSelectedLabelColor({\cf17 const} QColor &color);\par
7138   {\cf18 void} setSelectedBasePen({\cf17 const} QPen &pen);\par
7139   {\cf18 void} setSelectedTickPen({\cf17 const} QPen &pen);\par
7140   {\cf18 void} setSelectedSubTickPen({\cf17 const} QPen &pen);\par
7141   Q_SLOT {\cf18 void} setSelectableParts({\cf17 const} QCPPolarAxisRadial::SelectableParts &selectableParts);\par
7142   Q_SLOT {\cf18 void} setSelectedParts({\cf17 const} QCPPolarAxisRadial::SelectableParts &selectedParts);\par
7143   \par
7144   {\cf20 // reimplemented virtual methods:}\par
7145   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details=0) const Q_DECL_OVERRIDE;\par
7146   \par
7147   {\cf20 // non-property methods:}\par
7148   {\cf18 void} moveRange({\cf18 double} diff);\par
7149   {\cf18 void} scaleRange({\cf18 double} factor);\par
7150   {\cf18 void} scaleRange({\cf18 double} factor, {\cf18 double} center);\par
7151   {\cf18 void} rescale({\cf18 bool} onlyVisiblePlottables=false);\par
7152   {\cf18 void} pixelToCoord(QPointF pixelPos, {\cf18 double} &angleCoord, {\cf18 double} &radiusCoord) const;\par
7153   QPointF coordToPixel({\cf18 double} angleCoord, {\cf18 double} radiusCoord) const;\par
7154   {\cf18 double} coordToRadius({\cf18 double} coord) const;\par
7155   {\cf18 double} radiusToCoord({\cf18 double} radius) const;\par
7156   SelectablePart getPartAt(const QPointF &pos) const;\par
7157   \par
7158 signals:\par
7159   {\cf18 void} rangeChanged(const QCPRange &newRange);\par
7160   {\cf18 void} rangeChanged(const QCPRange &newRange, const QCPRange &oldRange);\par
7161   {\cf18 void} scaleTypeChanged(QCPPolarAxisRadial::ScaleType scaleType);\par
7162   {\cf18 void} selectionChanged(const QCPPolarAxisRadial::SelectableParts &parts);\par
7163   {\cf18 void} selectableChanged(const QCPPolarAxisRadial::SelectableParts &parts);\par
7164 \par
7165 protected:\par
7166   {\cf20 // property members:}\par
7167   {\cf18 bool} mRangeDrag;\par
7168   {\cf18 bool} mRangeZoom;\par
7169   {\cf18 double} mRangeZoomFactor;\par
7170   \par
7171   {\cf20 // axis base:}\par
7172   QCPPolarAxisAngular *mAngularAxis;\par
7173   {\cf18 double} mAngle;\par
7174   AngleReference mAngleReference;\par
7175   SelectableParts mSelectableParts, mSelectedParts;\par
7176   QPen mBasePen, mSelectedBasePen;\par
7177   {\cf20 // axis label:}\par
7178   {\cf18 int} mLabelPadding;\par
7179   QString mLabel;\par
7180   QFont mLabelFont, mSelectedLabelFont;\par
7181   QColor mLabelColor, mSelectedLabelColor;\par
7182   {\cf20 // tick labels:}\par
7183   {\cf20 //int mTickLabelPadding; in label painter}\par
7184   {\cf18 bool} mTickLabels;\par
7185   {\cf20 //double mTickLabelRotation; in label painter}\par
7186   QFont mTickLabelFont, mSelectedTickLabelFont;\par
7187   QColor mTickLabelColor, mSelectedTickLabelColor;\par
7188   {\cf18 int} mNumberPrecision;\par
7189   QLatin1Char mNumberFormatChar;\par
7190   {\cf18 bool} mNumberBeautifulPowers;\par
7191   {\cf18 bool} mNumberMultiplyCross;\par
7192   {\cf20 // ticks and subticks:}\par
7193   {\cf18 bool} mTicks;\par
7194   {\cf18 bool} mSubTicks;\par
7195   {\cf18 int} mTickLengthIn, mTickLengthOut, mSubTickLengthIn, mSubTickLengthOut;\par
7196   QPen mTickPen, mSelectedTickPen;\par
7197   QPen mSubTickPen, mSelectedSubTickPen;\par
7198   {\cf20 // scale and range:}\par
7199   QCPRange mRange;\par
7200   {\cf18 bool} mRangeReversed;\par
7201   ScaleType mScaleType;\par
7202   \par
7203   {\cf20 // non-property members:}\par
7204   QPointF mCenter;\par
7205   {\cf18 double} mRadius;\par
7206   QSharedPointer<QCPAxisTicker> mTicker;\par
7207   QVector<{\cf18 double}> mTickVector;\par
7208   QVector<QString> mTickVectorLabels;\par
7209   QVector<{\cf18 double}> mSubTickVector;\par
7210   {\cf18 bool} mDragging;\par
7211   QCPRange mDragStartRange;\par
7212   QCP::AntialiasedElements mAADragBackup, mNotAADragBackup;\par
7213   QCPLabelPainterPrivate mLabelPainter;\par
7214   \par
7215   {\cf20 // reimplemented virtual methods:}\par
7216   virtual {\cf18 void} applyDefaultAntialiasingHint(QCPPainter *painter) const Q_DECL_OVERRIDE;\par
7217   virtual {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
7218   virtual QCP::Interaction selectionCategory() const Q_DECL_OVERRIDE;\par
7219   {\cf20 // events:}\par
7220   virtual {\cf18 void} selectEvent(QMouseEvent *event, {\cf18 bool} additive, const QVariant &details, {\cf18 bool} *selectionStateChanged) Q_DECL_OVERRIDE;\par
7221   virtual {\cf18 void} deselectEvent({\cf18 bool} *selectionStateChanged) Q_DECL_OVERRIDE;\par
7222   {\cf20 // mouse events:}\par
7223   virtual {\cf18 void} mousePressEvent(QMouseEvent *event, const QVariant &details) Q_DECL_OVERRIDE;\par
7224   virtual {\cf18 void} mouseMoveEvent(QMouseEvent *event, const QPointF &startPos) Q_DECL_OVERRIDE;\par
7225   virtual {\cf18 void} mouseReleaseEvent(QMouseEvent *event, const QPointF &startPos) Q_DECL_OVERRIDE;\par
7226   virtual {\cf18 void} wheelEvent(QWheelEvent *event) Q_DECL_OVERRIDE;\par
7227   \par
7228   {\cf20 // non-virtual methods:}\par
7229   {\cf18 void} updateGeometry(const QPointF &center, {\cf18 double} radius);\par
7230   {\cf18 void} setupTickVectors();\par
7231   QPen getBasePen() const;\par
7232   QPen getTickPen() const;\par
7233   QPen getSubTickPen() const;\par
7234   QFont getTickLabelFont() const;\par
7235   QFont getLabelFont() const;\par
7236   QColor getTickLabelColor() const;\par
7237   QColor getLabelColor() const;\par
7238   \par
7239 private:\par
7240   Q_DISABLE_COPY(QCPPolarAxisRadial)\par
7241   \par
7242   friend class QCustomPlot;\par
7243   friend class QCPPolarAxisAngular;\par
7244 \};\par
7245 Q_DECLARE_OPERATORS_FOR_FLAGS(QCPPolarAxisRadial::SelectableParts)\par
7246 Q_DECLARE_METATYPE(QCPPolarAxisRadial::AngleReference)\par
7247 Q_DECLARE_METATYPE(QCPPolarAxisRadial::ScaleType)\par
7248 Q_DECLARE_METATYPE(QCPPolarAxisRadial::SelectablePart)\par
7249 \par
7250 \par
7251 \par
7252 {\cf20 /* end of 'src/polar/radialaxis.h' */}\par
7253 \par
7254 \par
7255 {\cf20 /* including file 'src/polar/layoutelement-angularaxis.h' */}\par
7256 {\cf20 /* modified 2022-11-06T12:45:56, size 13461               */}\par
7257 \par
7258 class QCP_LIB_DECL QCPPolarAxisAngular : public QCPLayoutElement\par
7259 \{\par
7260   Q_OBJECT\par
7262   \par
7264 {\cf17 public}:\par
7269   {\cf17 enum} SelectablePart \{ spNone        = 0      \par
7270                         ,spAxis       = 0x001  \par
7271                         ,spTickLabels = 0x002  \par
7272                         ,spAxisLabel  = 0x004  \par
7273                       \};\par
7274   Q_ENUMS(SelectablePart)\par
7275   Q_FLAGS(SelectableParts)\par
7276   Q_DECLARE_FLAGS(SelectableParts, SelectablePart)\par
7277   \par
7278   \par
7281   enum LabelMode \{ lmUpright   \par
7282                    ,lmRotated \par
7283                  \};\par
7284   Q_ENUMS(LabelMode)\par
7285   \par
7286   explicit QCPPolarAxisAngular(QCustomPlot *parentPlot);\par
7287   virtual ~QCPPolarAxisAngular();\par
7288   \par
7289   {\cf20 // getters:}\par
7290   QPixmap background(){\cf17  const }\{ {\cf19 return} mBackgroundPixmap; \}\par
7291   QBrush backgroundBrush(){\cf17  const }\{ {\cf19 return} mBackgroundBrush; \}\par
7292   {\cf18 bool} backgroundScaled(){\cf17  const }\{ {\cf19 return} mBackgroundScaled; \}\par
7293   Qt::AspectRatioMode backgroundScaledMode(){\cf17  const }\{ {\cf19 return} mBackgroundScaledMode; \}\par
7294   {\cf18 bool} rangeDrag(){\cf17  const }\{ {\cf19 return} mRangeDrag; \}\par
7295   {\cf18 bool} rangeZoom(){\cf17  const }\{ {\cf19 return} mRangeZoom; \}\par
7296   {\cf18 double} rangeZoomFactor(){\cf17  const }\{ {\cf19 return} mRangeZoomFactor; \}\par
7297   \par
7298   {\cf17 const} QCPRange range(){\cf17  const }\{ {\cf19 return} mRange; \}\par
7299   {\cf18 bool} rangeReversed(){\cf17  const }\{ {\cf19 return} mRangeReversed; \}\par
7300   {\cf18 double} angle(){\cf17  const }\{ {\cf19 return} mAngle; \}\par
7301   QSharedPointer<QCPAxisTicker> ticker(){\cf17  const }\{ {\cf19 return} mTicker; \}\par
7302   {\cf18 bool} ticks(){\cf17  const }\{ {\cf19 return} mTicks; \}\par
7303   {\cf18 bool} tickLabels(){\cf17  const }\{ {\cf19 return} mTickLabels; \}\par
7304   {\cf18 int} tickLabelPadding(){\cf17  const }\{ {\cf19 return} mLabelPainter.padding(); \}\par
7305   QFont tickLabelFont(){\cf17  const }\{ {\cf19 return} mTickLabelFont; \}\par
7306   QColor tickLabelColor(){\cf17  const }\{ {\cf19 return} mTickLabelColor; \}\par
7307   {\cf18 double} tickLabelRotation(){\cf17  const }\{ {\cf19 return} mLabelPainter.rotation(); \}\par
7308   LabelMode tickLabelMode() {\cf17 const};\par
7309   QString numberFormat() {\cf17 const};\par
7310   {\cf18 int} numberPrecision(){\cf17  const }\{ {\cf19 return} mNumberPrecision; \}\par
7311   QVector<double> tickVector(){\cf17  const }\{ {\cf19 return} mTickVector; \}\par
7312   QVector<QString> tickVectorLabels(){\cf17  const }\{ {\cf19 return} mTickVectorLabels; \}\par
7313   {\cf18 int} tickLengthIn(){\cf17  const }\{ {\cf19 return} mTickLengthIn; \}\par
7314   {\cf18 int} tickLengthOut(){\cf17  const }\{ {\cf19 return} mTickLengthOut; \}\par
7315   {\cf18 bool} subTicks(){\cf17  const }\{ {\cf19 return} mSubTicks; \}\par
7316   {\cf18 int} subTickLengthIn(){\cf17  const }\{ {\cf19 return} mSubTickLengthIn; \}\par
7317   {\cf18 int} subTickLengthOut(){\cf17  const }\{ {\cf19 return} mSubTickLengthOut; \}\par
7318   QPen basePen(){\cf17  const }\{ {\cf19 return} mBasePen; \}\par
7319   QPen tickPen(){\cf17  const }\{ {\cf19 return} mTickPen; \}\par
7320   QPen subTickPen(){\cf17  const }\{ {\cf19 return} mSubTickPen; \}\par
7321   QFont labelFont(){\cf17  const }\{ {\cf19 return} mLabelFont; \}\par
7322   QColor labelColor(){\cf17  const }\{ {\cf19 return} mLabelColor; \}\par
7323   QString label(){\cf17  const }\{ {\cf19 return} mLabel; \}\par
7324   {\cf18 int} labelPadding(){\cf17  const }\{ {\cf19 return} mLabelPadding; \}\par
7325   SelectableParts selectedParts(){\cf17  const }\{ {\cf19 return} mSelectedParts; \}\par
7326   SelectableParts selectableParts(){\cf17  const }\{ {\cf19 return} mSelectableParts; \}\par
7327   QFont selectedTickLabelFont(){\cf17  const }\{ {\cf19 return} mSelectedTickLabelFont; \}\par
7328   QFont selectedLabelFont(){\cf17  const }\{ {\cf19 return} mSelectedLabelFont; \}\par
7329   QColor selectedTickLabelColor(){\cf17  const }\{ {\cf19 return} mSelectedTickLabelColor; \}\par
7330   QColor selectedLabelColor(){\cf17  const }\{ {\cf19 return} mSelectedLabelColor; \}\par
7331   QPen selectedBasePen(){\cf17  const }\{ {\cf19 return} mSelectedBasePen; \}\par
7332   QPen selectedTickPen(){\cf17  const }\{ {\cf19 return} mSelectedTickPen; \}\par
7333   QPen selectedSubTickPen(){\cf17  const }\{ {\cf19 return} mSelectedSubTickPen; \}\par
7334   QCPPolarGrid *grid(){\cf17  const }\{ {\cf19 return} mGrid; \}\par
7335   \par
7336   {\cf20 // setters:}\par
7337   {\cf18 void} setBackground({\cf17 const} QPixmap &pm);\par
7338   {\cf18 void} setBackground({\cf17 const} QPixmap &pm, {\cf18 bool} scaled, Qt::AspectRatioMode mode=Qt::KeepAspectRatioByExpanding);\par
7339   {\cf18 void} setBackground({\cf17 const} QBrush &brush);\par
7340   {\cf18 void} setBackgroundScaled({\cf18 bool} scaled);\par
7341   {\cf18 void} setBackgroundScaledMode(Qt::AspectRatioMode mode);\par
7342   {\cf18 void} setRangeDrag({\cf18 bool} enabled);\par
7343   {\cf18 void} setRangeZoom({\cf18 bool} enabled);\par
7344   {\cf18 void} setRangeZoomFactor({\cf18 double} factor);\par
7345   \par
7346   Q_SLOT {\cf18 void} setRange({\cf17 const} QCPRange &range);\par
7347   {\cf18 void} setRange({\cf18 double} lower, {\cf18 double} upper);\par
7348   {\cf18 void} setRange({\cf18 double} position, {\cf18 double} size, Qt::AlignmentFlag alignment);\par
7349   {\cf18 void} setRangeLower({\cf18 double} lower);\par
7350   {\cf18 void} setRangeUpper({\cf18 double} upper);\par
7351   {\cf18 void} setRangeReversed({\cf18 bool} reversed);\par
7352   {\cf18 void} setAngle({\cf18 double} degrees);\par
7353   {\cf18 void} setTicker(QSharedPointer<QCPAxisTicker> ticker);\par
7354   {\cf18 void} setTicks({\cf18 bool} show);\par
7355   {\cf18 void} setTickLabels({\cf18 bool} show);\par
7356   {\cf18 void} setTickLabelPadding({\cf18 int} padding);\par
7357   {\cf18 void} setTickLabelFont({\cf17 const} QFont &font);\par
7358   {\cf18 void} setTickLabelColor({\cf17 const} QColor &color);\par
7359   {\cf18 void} setTickLabelRotation({\cf18 double} degrees);\par
7360   {\cf18 void} setTickLabelMode(LabelMode mode);\par
7361   {\cf18 void} setNumberFormat({\cf17 const} QString &formatCode);\par
7362   {\cf18 void} setNumberPrecision({\cf18 int} precision);\par
7363   {\cf18 void} setTickLength({\cf18 int} inside, {\cf18 int} outside=0);\par
7364   {\cf18 void} setTickLengthIn({\cf18 int} inside);\par
7365   {\cf18 void} setTickLengthOut({\cf18 int} outside);\par
7366   {\cf18 void} setSubTicks({\cf18 bool} show);\par
7367   {\cf18 void} setSubTickLength({\cf18 int} inside, {\cf18 int} outside=0);\par
7368   {\cf18 void} setSubTickLengthIn({\cf18 int} inside);\par
7369   {\cf18 void} setSubTickLengthOut({\cf18 int} outside);\par
7370   {\cf18 void} setBasePen({\cf17 const} QPen &pen);\par
7371   {\cf18 void} setTickPen({\cf17 const} QPen &pen);\par
7372   {\cf18 void} setSubTickPen({\cf17 const} QPen &pen);\par
7373   {\cf18 void} setLabelFont({\cf17 const} QFont &font);\par
7374   {\cf18 void} setLabelColor({\cf17 const} QColor &color);\par
7375   {\cf18 void} setLabel({\cf17 const} QString &str);\par
7376   {\cf18 void} setLabelPadding({\cf18 int} padding);\par
7377   {\cf18 void} setLabelPosition(Qt::AlignmentFlag position);\par
7378   {\cf18 void} setSelectedTickLabelFont({\cf17 const} QFont &font);\par
7379   {\cf18 void} setSelectedLabelFont({\cf17 const} QFont &font);\par
7380   {\cf18 void} setSelectedTickLabelColor({\cf17 const} QColor &color);\par
7381   {\cf18 void} setSelectedLabelColor({\cf17 const} QColor &color);\par
7382   {\cf18 void} setSelectedBasePen({\cf17 const} QPen &pen);\par
7383   {\cf18 void} setSelectedTickPen({\cf17 const} QPen &pen);\par
7384   {\cf18 void} setSelectedSubTickPen({\cf17 const} QPen &pen);\par
7385   Q_SLOT {\cf18 void} setSelectableParts({\cf17 const} QCPPolarAxisAngular::SelectableParts &selectableParts);\par
7386   Q_SLOT {\cf18 void} setSelectedParts({\cf17 const} QCPPolarAxisAngular::SelectableParts &selectedParts);\par
7387   \par
7388   {\cf20 // reimplemented virtual methods:}\par
7389   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details=0) const Q_DECL_OVERRIDE;\par
7390   virtual {\cf18 void} update(UpdatePhase phase) Q_DECL_OVERRIDE;\par
7391   virtual QList<QCPLayoutElement*> elements({\cf18 bool} recursive) const Q_DECL_OVERRIDE;\par
7392   \par
7393   {\cf20 // non-property methods:}\par
7394   {\cf18 bool} removeGraph(QCPPolarGraph *graph);\par
7395   {\cf18 int} radialAxisCount() const;\par
7396   QCPPolarAxisRadial *radialAxis({\cf18 int} index=0) const;\par
7397   QList<QCPPolarAxisRadial*> radialAxes() const;\par
7398   QCPPolarAxisRadial *addRadialAxis(QCPPolarAxisRadial *axis=0);\par
7399   {\cf18 bool} removeRadialAxis(QCPPolarAxisRadial *axis);\par
7400   QCPLayoutInset *insetLayout(){\cf17  const }\{ {\cf19 return} mInsetLayout; \}\par
7401   QRegion exactClipRegion() {\cf17 const};\par
7402   \par
7403   {\cf18 void} moveRange({\cf18 double} diff);\par
7404   {\cf18 void} scaleRange({\cf18 double} factor);\par
7405   {\cf18 void} scaleRange({\cf18 double} factor, {\cf18 double} center);\par
7406   {\cf18 void} rescale({\cf18 bool} onlyVisiblePlottables={\cf17 false});\par
7407   {\cf18 double} coordToAngleRad({\cf18 double} coord){\cf17  const }\{ {\cf19 return} mAngleRad+(coord-mRange.lower)/mRange.size()*(mRangeReversed ? -2.0*M_PI : 2.0*M_PI); \} {\cf20 // mention in doc that return doesn't wrap}\par
7408   {\cf18 double} angleRadToCoord({\cf18 double} angleRad){\cf17  const }\{ {\cf19 return} mRange.lower+(angleRad-mAngleRad)/(mRangeReversed ? -2.0*M_PI : 2.0*M_PI)*mRange.size(); \}\par
7409   {\cf18 void} pixelToCoord(QPointF pixelPos, {\cf18 double} &angleCoord, {\cf18 double} &radiusCoord) {\cf17 const};\par
7410   QPointF coordToPixel({\cf18 double} angleCoord, {\cf18 double} radiusCoord) {\cf17 const};\par
7411   SelectablePart getPartAt({\cf17 const} QPointF &pos) {\cf17 const};\par
7412   \par
7413   {\cf20 // read-only interface imitating a QRect:}\par
7414   {\cf18 int} left(){\cf17  const }\{ {\cf19 return} mRect.left(); \}\par
7415   {\cf18 int} right(){\cf17  const }\{ {\cf19 return} mRect.right(); \}\par
7416   {\cf18 int} top(){\cf17  const }\{ {\cf19 return} mRect.top(); \}\par
7417   {\cf18 int} bottom(){\cf17  const }\{ {\cf19 return} mRect.bottom(); \}\par
7418   {\cf18 int} width(){\cf17  const }\{ {\cf19 return} mRect.width(); \}\par
7419   {\cf18 int} height(){\cf17  const }\{ {\cf19 return} mRect.height(); \}\par
7420   QSize size(){\cf17  const }\{ {\cf19 return} mRect.size(); \}\par
7421   QPoint topLeft(){\cf17  const }\{ {\cf19 return} mRect.topLeft(); \}\par
7422   QPoint topRight(){\cf17  const }\{ {\cf19 return} mRect.topRight(); \}\par
7423   QPoint bottomLeft(){\cf17  const }\{ {\cf19 return} mRect.bottomLeft(); \}\par
7424   QPoint bottomRight(){\cf17  const }\{ {\cf19 return} mRect.bottomRight(); \}\par
7425   QPointF center(){\cf17  const }\{ {\cf19 return} mCenter; \}\par
7426   {\cf18 double} radius(){\cf17  const }\{ {\cf19 return} mRadius; \}\par
7427   \par
7428 signals:\par
7429   {\cf18 void} rangeChanged({\cf17 const} QCPRange &newRange);\par
7430   {\cf18 void} rangeChanged({\cf17 const} QCPRange &newRange, {\cf17 const} QCPRange &oldRange);\par
7431   {\cf18 void} selectionChanged({\cf17 const} QCPPolarAxisAngular::SelectableParts &parts);\par
7432   {\cf18 void} selectableChanged({\cf17 const} QCPPolarAxisAngular::SelectableParts &parts);\par
7433   \par
7434 {\cf17 protected}:\par
7435   {\cf20 // property members:}\par
7436   QBrush mBackgroundBrush;\par
7437   QPixmap mBackgroundPixmap;\par
7438   QPixmap mScaledBackgroundPixmap;\par
7439   {\cf18 bool} mBackgroundScaled;\par
7440   Qt::AspectRatioMode mBackgroundScaledMode;\par
7441   QCPLayoutInset *mInsetLayout;\par
7442   {\cf18 bool} mRangeDrag;\par
7443   {\cf18 bool} mRangeZoom;\par
7444   {\cf18 double} mRangeZoomFactor;\par
7445   \par
7446   {\cf20 // axis base:}\par
7447   {\cf18 double} mAngle, mAngleRad;\par
7448   SelectableParts mSelectableParts, mSelectedParts;\par
7449   QPen mBasePen, mSelectedBasePen;\par
7450   {\cf20 // axis label:}\par
7451   {\cf18 int} mLabelPadding;\par
7452   QString mLabel;\par
7453   QFont mLabelFont, mSelectedLabelFont;\par
7454   QColor mLabelColor, mSelectedLabelColor;\par
7455   {\cf20 // tick labels:}\par
7456   {\cf20 //int mTickLabelPadding; in label painter}\par
7457   {\cf18 bool} mTickLabels;\par
7458   {\cf20 //double mTickLabelRotation; in label painter}\par
7459   QFont mTickLabelFont, mSelectedTickLabelFont;\par
7460   QColor mTickLabelColor, mSelectedTickLabelColor;\par
7461   {\cf18 int} mNumberPrecision;\par
7462   QLatin1Char mNumberFormatChar;\par
7463   {\cf18 bool} mNumberBeautifulPowers;\par
7464   {\cf18 bool} mNumberMultiplyCross;\par
7465   {\cf20 // ticks and subticks:}\par
7466   {\cf18 bool} mTicks;\par
7467   {\cf18 bool} mSubTicks;\par
7468   {\cf18 int} mTickLengthIn, mTickLengthOut, mSubTickLengthIn, mSubTickLengthOut;\par
7469   QPen mTickPen, mSelectedTickPen;\par
7470   QPen mSubTickPen, mSelectedSubTickPen;\par
7471   {\cf20 // scale and range:}\par
7472   QCPRange mRange;\par
7473   {\cf18 bool} mRangeReversed;\par
7474   \par
7475   {\cf20 // non-property members:}\par
7476   QPointF mCenter;\par
7477   {\cf18 double} mRadius;\par
7478   QList<QCPPolarAxisRadial*> mRadialAxes;\par
7479   QCPPolarGrid *mGrid;\par
7480   QList<QCPPolarGraph*> mGraphs;\par
7481   QSharedPointer<QCPAxisTicker> mTicker;\par
7482   QVector<double> mTickVector;\par
7483   QVector<QString> mTickVectorLabels;\par
7484   QVector<QPointF> mTickVectorCosSin;\par
7485   QVector<double> mSubTickVector;\par
7486   QVector<QPointF> mSubTickVectorCosSin;\par
7487   {\cf18 bool} mDragging;\par
7488   QCPRange mDragAngularStart;\par
7489   QList<QCPRange> mDragRadialStart;\par
7490   QCP::AntialiasedElements mAADragBackup, mNotAADragBackup;\par
7491   QCPLabelPainterPrivate mLabelPainter;\par
7492   \par
7493   {\cf20 // reimplemented virtual methods:}\par
7494   {\cf17 virtual} {\cf18 void} applyDefaultAntialiasingHint(QCPPainter *painter) {\cf17 const} Q_DECL_OVERRIDE;\par
7495   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
7496   {\cf17 virtual} QCP::Interaction selectionCategory() const Q_DECL_OVERRIDE;\par
7497   {\cf20 // events:}\par
7498   virtual {\cf18 void} mousePressEvent(QMouseEvent *event, const QVariant &details) Q_DECL_OVERRIDE;\par
7499   virtual {\cf18 void} mouseMoveEvent(QMouseEvent *event, const QPointF &startPos) Q_DECL_OVERRIDE;\par
7500   virtual {\cf18 void} mouseReleaseEvent(QMouseEvent *event, const QPointF &startPos) Q_DECL_OVERRIDE;\par
7501   virtual {\cf18 void} wheelEvent(QWheelEvent *event) Q_DECL_OVERRIDE;\par
7502   \par
7503   {\cf20 // non-virtual methods:}\par
7504   {\cf18 bool} registerPolarGraph(QCPPolarGraph *graph);\par
7505   {\cf18 void} drawBackground(QCPPainter *painter, const QPointF &center, {\cf18 double} radius);\par
7506   {\cf18 void} setupTickVectors();\par
7507   QPen getBasePen() const;\par
7508   QPen getTickPen() const;\par
7509   QPen getSubTickPen() const;\par
7510   QFont getTickLabelFont() const;\par
7511   QFont getLabelFont() const;\par
7512   QColor getTickLabelColor() const;\par
7513   QColor getLabelColor() const;\par
7514   \par
7515 private:\par
7516   Q_DISABLE_COPY(QCPPolarAxisAngular)\par
7517   \par
7518   friend class QCustomPlot;\par
7519   friend class QCPPolarGrid;\par
7520   friend class QCPPolarGraph;\par
7521 \};\par
7522 Q_DECLARE_OPERATORS_FOR_FLAGS(QCPPolarAxisAngular::SelectableParts)\par
7523 Q_DECLARE_METATYPE(QCPPolarAxisAngular::SelectablePart)\par
7524 \par
7525 {\cf20 /* end of 'src/polar/layoutelement-angularaxis.h' */}\par
7526 \par
7527 \par
7528 {\cf20 /* including file 'src/polar/polargrid.h'  */}\par
7529 {\cf20 /* modified 2022-11-06T12:45:56, size 4506 */}\par
7530 \par
7531 class QCP_LIB_DECL QCPPolarGrid :public QCPLayerable\par
7532 \{\par
7533   Q_OBJECT\par
7535   \par
7537 {\cf17 public}:\par
7541   {\cf17 enum} GridType \{ gtAngular = 0x01 \par
7542                   ,gtRadial = 0x02 \par
7543                   ,gtAll    = 0xFF \par
7544                   ,gtNone   = 0x00 \par
7545                 \};\par
7546   Q_ENUMS(GridType)\par
7547   Q_FLAGS(GridTypes)\par
7548   Q_DECLARE_FLAGS(GridTypes, GridType)\par
7549   \par
7550   explicit QCPPolarGrid(QCPPolarAxisAngular *parentAxis);\par
7551   \par
7552   {\cf20 // getters:}\par
7553   QCPPolarAxisRadial *radialAxis(){\cf17  const }\{ {\cf19 return} mRadialAxis.data(); \}\par
7554   GridTypes type(){\cf17  const }\{ {\cf19 return} mType; \}\par
7555   GridTypes subGridType(){\cf17  const }\{ {\cf19 return} mSubGridType; \}\par
7556   {\cf18 bool} antialiasedSubGrid(){\cf17  const }\{ {\cf19 return} mAntialiasedSubGrid; \}\par
7557   {\cf18 bool} antialiasedZeroLine(){\cf17  const }\{ {\cf19 return} mAntialiasedZeroLine; \}\par
7558   QPen angularPen(){\cf17  const }\{ {\cf19 return} mAngularPen; \}\par
7559   QPen angularSubGridPen(){\cf17  const }\{ {\cf19 return} mAngularSubGridPen; \}\par
7560   QPen radialPen(){\cf17  const }\{ {\cf19 return} mRadialPen; \}\par
7561   QPen radialSubGridPen(){\cf17  const }\{ {\cf19 return} mRadialSubGridPen; \}\par
7562   QPen radialZeroLinePen(){\cf17  const }\{ {\cf19 return} mRadialZeroLinePen; \}\par
7563   \par
7564   {\cf20 // setters:}\par
7565   {\cf18 void} setRadialAxis(QCPPolarAxisRadial *axis);\par
7566   {\cf18 void} setType(GridTypes type);\par
7567   {\cf18 void} setSubGridType(GridTypes type);\par
7568   {\cf18 void} setAntialiasedSubGrid({\cf18 bool} enabled);\par
7569   {\cf18 void} setAntialiasedZeroLine({\cf18 bool} enabled);\par
7570   {\cf18 void} setAngularPen({\cf17 const} QPen &pen);\par
7571   {\cf18 void} setAngularSubGridPen({\cf17 const} QPen &pen);\par
7572   {\cf18 void} setRadialPen({\cf17 const} QPen &pen);\par
7573   {\cf18 void} setRadialSubGridPen({\cf17 const} QPen &pen);\par
7574   {\cf18 void} setRadialZeroLinePen({\cf17 const} QPen &pen);\par
7575   \par
7576 {\cf17 protected}:\par
7577   {\cf20 // property members:}\par
7578   GridTypes mType;\par
7579   GridTypes mSubGridType;\par
7580   {\cf18 bool} mAntialiasedSubGrid, mAntialiasedZeroLine;\par
7581   QPen mAngularPen, mAngularSubGridPen;\par
7582   QPen mRadialPen, mRadialSubGridPen, mRadialZeroLinePen;\par
7583   \par
7584   {\cf20 // non-property members:}\par
7585   QCPPolarAxisAngular *mParentAxis;\par
7586   QPointer<QCPPolarAxisRadial> mRadialAxis;\par
7587   \par
7588   {\cf20 // reimplemented virtual methods:}\par
7589   {\cf17 virtual} {\cf18 void} applyDefaultAntialiasingHint(QCPPainter *painter) {\cf17 const} Q_DECL_OVERRIDE;\par
7590   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
7591   \par
7592   {\cf20 // non-virtual methods:}\par
7593   {\cf18 void} drawRadialGrid(QCPPainter *painter, {\cf17 const} QPointF &center, {\cf17 const} QVector<double> &coords, {\cf17 const} QPen &pen, {\cf17 const} QPen &zeroPen=Qt::NoPen);\par
7594   {\cf18 void} drawAngularGrid(QCPPainter *painter, {\cf17 const} QPointF &center, {\cf18 double} radius, {\cf17 const} QVector<QPointF> &ticksCosSin, {\cf17 const} QPen &pen);\par
7595   \par
7596 {\cf17 private}:\par
7597   Q_DISABLE_COPY(QCPPolarGrid)\par
7598   \par
7599 \};\par
7600 \par
7601 Q_DECLARE_OPERATORS_FOR_FLAGS(QCPPolarGrid::GridTypes)\par
7602 Q_DECLARE_METATYPE(QCPPolarGrid::GridType)\par
7603 \par
7604 \par
7605 {\cf20 /* end of 'src/polar/polargrid.h' */}\par
7606 \par
7607 \par
7608 {\cf20 /* including file 'src/polar/polargraph.h' */}\par
7609 {\cf20 /* modified 2022-11-06T12:45:56, size 9606 */}\par
7610 \par
7611 \par
7612 class QCP_LIB_DECL QCPPolarLegendItem : public QCPAbstractLegendItem\par
7613 \{\par
7614   Q_OBJECT\par
7615 {\cf17 public}:\par
7616   QCPPolarLegendItem(QCPLegend *parent, QCPPolarGraph *graph);\par
7617   \par
7618   {\cf20 // getters:}\par
7619   QCPPolarGraph *polarGraph() \{ {\cf19 return} mPolarGraph; \}\par
7620   \par
7621 {\cf17 protected}:\par
7622   {\cf20 // property members:}\par
7623   QCPPolarGraph *mPolarGraph;\par
7624   \par
7625   {\cf20 // reimplemented virtual methods:}\par
7626   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter) Q_DECL_OVERRIDE;\par
7627   {\cf17 virtual} QSize minimumOuterSizeHint() const Q_DECL_OVERRIDE;\par
7628   \par
7629   {\cf20 // non-virtual methods:}\par
7630   QPen getIconBorderPen() const;\par
7631   QColor getTextColor() const;\par
7632   QFont getFont() const;\par
7633 \};\par
7634 \par
7635 \par
7636 class QCP_LIB_DECL QCPPolarGraph : public QCPLayerable\par
7637 \{\par
7638   Q_OBJECT\par
7640   \par
7642 {\cf17 public}:\par
7648   {\cf17 enum} LineStyle \{ lsNone        \par
7650                    ,lsLine       \par
7651                  \};\par
7652   Q_ENUMS(LineStyle)\par
7653   \par
7654   QCPPolarGraph(QCPPolarAxisAngular *keyAxis, QCPPolarAxisRadial *valueAxis);\par
7655   virtual ~QCPPolarGraph();\par
7656   \par
7657   {\cf20 // getters:}\par
7658   QString name(){\cf17  const }\{ {\cf19 return} mName; \}\par
7659   {\cf18 bool} antialiasedFill(){\cf17  const }\{ {\cf19 return} mAntialiasedFill; \}\par
7660   {\cf18 bool} antialiasedScatters(){\cf17  const }\{ {\cf19 return} mAntialiasedScatters; \}\par
7661   QPen pen(){\cf17  const }\{ {\cf19 return} mPen; \}\par
7662   QBrush brush(){\cf17  const }\{ {\cf19 return} mBrush; \}\par
7663   {\cf18 bool} periodic(){\cf17  const }\{ {\cf19 return} mPeriodic; \}\par
7664   QCPPolarAxisAngular *keyAxis(){\cf17  const }\{ {\cf19 return} mKeyAxis.data(); \}\par
7665   QCPPolarAxisRadial *valueAxis(){\cf17  const }\{ {\cf19 return} mValueAxis.data(); \}\par
7666   QCP::SelectionType selectable(){\cf17  const }\{ {\cf19 return} mSelectable; \}\par
7667   {\cf18 bool} selected(){\cf17  const }\{ {\cf19 return} !mSelection.isEmpty(); \}\par
7668   QCPDataSelection selection(){\cf17  const }\{ {\cf19 return} mSelection; \}\par
7669   {\cf20 //QCPSelectionDecorator *selectionDecorator() const \{ return mSelectionDecorator; \}}\par
7670   QSharedPointer<QCPGraphDataContainer> data(){\cf17  const }\{ {\cf19 return} mDataContainer; \}\par
7671   LineStyle lineStyle(){\cf17  const }\{ {\cf19 return} mLineStyle; \}\par
7672   QCPScatterStyle scatterStyle(){\cf17  const }\{ {\cf19 return} mScatterStyle; \}\par
7673   \par
7674   {\cf20 // setters:}\par
7675   {\cf18 void} setName({\cf17 const} QString &name);\par
7676   {\cf18 void} setAntialiasedFill({\cf18 bool} enabled);\par
7677   {\cf18 void} setAntialiasedScatters({\cf18 bool} enabled);\par
7678   {\cf18 void} setPen({\cf17 const} QPen &pen);\par
7679   {\cf18 void} setBrush({\cf17 const} QBrush &brush);\par
7680   {\cf18 void} setPeriodic({\cf18 bool} enabled);\par
7681   {\cf18 void} setKeyAxis(QCPPolarAxisAngular *axis);\par
7682   {\cf18 void} setValueAxis(QCPPolarAxisRadial *axis);\par
7683   Q_SLOT {\cf18 void} setSelectable(QCP::SelectionType selectable);\par
7684   Q_SLOT {\cf18 void} setSelection(QCPDataSelection selection);\par
7685   {\cf20 //void setSelectionDecorator(QCPSelectionDecorator *decorator);}\par
7686   {\cf18 void} setData(QSharedPointer<QCPGraphDataContainer> data);\par
7687   {\cf18 void} setData({\cf17 const} QVector<double> &keys, {\cf17 const} QVector<double> &values, {\cf18 bool} alreadySorted={\cf17 false});\par
7688   {\cf18 void} setLineStyle(LineStyle ls);\par
7689   {\cf18 void} setScatterStyle({\cf17 const} QCPScatterStyle &style);\par
7690 \par
7691   {\cf20 // non-property methods:}\par
7692   {\cf18 void} addData({\cf17 const} QVector<double> &keys, {\cf17 const} QVector<double> &values, {\cf18 bool} alreadySorted={\cf17 false});\par
7693   {\cf18 void} addData({\cf18 double} key, {\cf18 double} value);\par
7694   {\cf18 void} coordsToPixels({\cf18 double} key, {\cf18 double} value, {\cf18 double} &x, {\cf18 double} &y) {\cf17 const};\par
7695   {\cf17 const} QPointF coordsToPixels({\cf18 double} key, {\cf18 double} value) {\cf17 const};\par
7696   {\cf18 void} pixelsToCoords({\cf18 double} x, {\cf18 double} y, {\cf18 double} &key, {\cf18 double} &value) {\cf17 const};\par
7697   {\cf18 void} pixelsToCoords({\cf17 const} QPointF &pixelPos, {\cf18 double} &key, {\cf18 double} &value) {\cf17 const};\par
7698   {\cf18 void} rescaleAxes({\cf18 bool} onlyEnlarge={\cf17 false}) {\cf17 const};\par
7699   {\cf18 void} rescaleKeyAxis({\cf18 bool} onlyEnlarge={\cf17 false}) {\cf17 const};\par
7700   {\cf18 void} rescaleValueAxis({\cf18 bool} onlyEnlarge={\cf17 false}, {\cf18 bool} inKeyRange={\cf17 false}) {\cf17 const};\par
7701   {\cf18 bool} addToLegend(QCPLegend *legend);\par
7702   {\cf18 bool} addToLegend();\par
7703   {\cf18 bool} removeFromLegend(QCPLegend *legend) {\cf17 const};\par
7704   {\cf18 bool} removeFromLegend() {\cf17 const};\par
7705   \par
7706   {\cf20 // introduced virtual methods:}\par
7707   {\cf17 virtual} {\cf18 double} selectTest({\cf17 const} QPointF &pos, {\cf18 bool} onlySelectable, QVariant *details=0) {\cf17 const}; {\cf20 // actually introduced in QCPLayerable as non-pure, but we want to force reimplementation for plottables}\par
7708   {\cf17 virtual} QCPPlottableInterface1D *interface1D() \{ {\cf19 return} 0; \} {\cf20 // TODO: return this later, when QCPAbstractPolarPlottable is created}\par
7709   {\cf17 virtual} QCPRange getKeyRange({\cf18 bool} &foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth) {\cf17 const};\par
7710   {\cf17 virtual} QCPRange getValueRange({\cf18 bool} &foundRange, QCP::SignDomain inSignDomain=QCP::sdBoth, {\cf17 const} QCPRange &inKeyRange=QCPRange()) {\cf17 const};\par
7711   \par
7712 signals:\par
7713   {\cf18 void} selectionChanged({\cf18 bool} selected);\par
7714   {\cf18 void} selectionChanged({\cf17 const} QCPDataSelection &selection);\par
7715   {\cf18 void} selectableChanged(QCP::SelectionType selectable);\par
7716   \par
7717 {\cf17 protected}:\par
7718   {\cf20 // property members:}\par
7719   QSharedPointer<QCPGraphDataContainer> mDataContainer;\par
7720   LineStyle mLineStyle;\par
7721   QCPScatterStyle mScatterStyle;\par
7722   QString mName;\par
7723   {\cf18 bool} mAntialiasedFill, mAntialiasedScatters;\par
7724   QPen mPen;\par
7725   QBrush mBrush;\par
7726   {\cf18 bool} mPeriodic;\par
7727   QPointer<QCPPolarAxisAngular> mKeyAxis;\par
7728   QPointer<QCPPolarAxisRadial> mValueAxis;\par
7729   QCP::SelectionType mSelectable;\par
7730   QCPDataSelection mSelection;\par
7731   {\cf20 //QCPSelectionDecorator *mSelectionDecorator;}\par
7732   \par
7733   {\cf20 // introduced virtual methods (later reimplemented TODO from QCPAbstractPolarPlottable):}\par
7734   {\cf17 virtual} QRect clipRect() {\cf17 const};\par
7735   {\cf17 virtual} {\cf18 void} draw(QCPPainter *painter);\par
7736   {\cf17 virtual} QCP::Interaction selectionCategory() {\cf17 const};\par
7737   {\cf18 void} applyDefaultAntialiasingHint(QCPPainter *painter) {\cf17 const};\par
7738   {\cf20 // events:}\par
7739   {\cf17 virtual} {\cf18 void} selectEvent(QMouseEvent *event, {\cf18 bool} additive, {\cf17 const} QVariant &details, {\cf18 bool} *selectionStateChanged);\par
7740   {\cf17 virtual} {\cf18 void} deselectEvent({\cf18 bool} *selectionStateChanged);\par
7741   {\cf20 // virtual drawing helpers:}\par
7742   {\cf17 virtual} {\cf18 void} drawLinePlot(QCPPainter *painter, {\cf17 const} QVector<QPointF> &lines) {\cf17 const};\par
7743   {\cf17 virtual} {\cf18 void} drawFill(QCPPainter *painter, QVector<QPointF> *lines) {\cf17 const};\par
7744   {\cf17 virtual} {\cf18 void} drawScatterPlot(QCPPainter *painter, {\cf17 const} QVector<QPointF> &scatters, {\cf17 const} QCPScatterStyle &style) {\cf17 const};\par
7745   \par
7746   {\cf20 // introduced virtual methods:}\par
7747   {\cf17 virtual} {\cf18 void} drawLegendIcon(QCPPainter *painter, {\cf17 const} QRectF &rect) {\cf17 const};\par
7748   \par
7749   {\cf20 // non-virtual methods:}\par
7750   {\cf18 void} applyFillAntialiasingHint(QCPPainter *painter) {\cf17 const};\par
7751   {\cf18 void} applyScattersAntialiasingHint(QCPPainter *painter) {\cf17 const};\par
7752   {\cf18 double} pointDistance({\cf17 const} QPointF &pixelPoint, QCPGraphDataContainer::const_iterator &closestData) {\cf17 const};\par
7753   {\cf20 // drawing helpers:}\par
7754   {\cf17 virtual} {\cf18 int} dataCount() {\cf17 const};\par
7755   {\cf18 void} getDataSegments(QList<QCPDataRange> &selectedSegments, QList<QCPDataRange> &unselectedSegments) {\cf17 const};\par
7756   {\cf18 void} drawPolyline(QCPPainter *painter, {\cf17 const} QVector<QPointF> &lineData) {\cf17 const};\par
7757   {\cf18 void} getVisibleDataBounds(QCPGraphDataContainer::const_iterator &begin, QCPGraphDataContainer::const_iterator &end, {\cf17 const} QCPDataRange &rangeRestriction) {\cf17 const};\par
7758   {\cf18 void} getLines(QVector<QPointF> *lines, {\cf17 const} QCPDataRange &dataRange) {\cf17 const};\par
7759   {\cf18 void} getScatters(QVector<QPointF> *scatters, {\cf17 const} QCPDataRange &dataRange) {\cf17 const};\par
7760   {\cf18 void} getOptimizedLineData(QVector<QCPGraphData> *lineData, {\cf17 const} QCPGraphDataContainer::const_iterator &begin, {\cf17 const} QCPGraphDataContainer::const_iterator &end) {\cf17 const};\par
7761   {\cf18 void} getOptimizedScatterData(QVector<QCPGraphData> *scatterData, QCPGraphDataContainer::const_iterator begin, QCPGraphDataContainer::const_iterator end) {\cf17 const};\par
7762   QVector<QPointF> dataToLines({\cf17 const} QVector<QCPGraphData> &data) {\cf17 const};\par
7763 \par
7764 {\cf17 private}:\par
7765   Q_DISABLE_COPY(QCPPolarGraph)\par
7766   \par
7767   friend class QCPPolarLegendItem;\par
7768 \};\par
7769 \par
7770 {\cf20 /* end of 'src/polar/polargraph.h' */}\par
7771 \par
7772 \par
7773 {\cf21 #endif }{\cf20 // QCUSTOMPLOT_H}\par
7774 \par
}
}